{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>SQLDelight 2.0</p> <p>If you are currently using SQLDelight 1.x, check out the docs on upgrading to SQLDelight 2.0!</p> <p>SQLDelight generates typesafe Kotlin APIs from your SQL statements. It verifies your schema, statements, and migrations at compile-time and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple.</p> <p>SQLDelight takes your existing SQL schema,</p> <pre><code>CREATE TABLE hockey_player (\n  id INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\n  name TEXT NOT NULL,\n  number INTEGER NOT NULL\n);\n</code></pre> <p>and generates typesafe code to run your SQL statements and queries.</p> <p></p>"},{"location":"#supported-dialects-and-platforms","title":"Supported Dialects and Platforms","text":"<p>SQLDelight supports a variety of SQL dialects and platforms.</p> <p> SQLite</p> <p> Android Native (iOS, macOS, Linux, Windows) JVM JavaScript (Browser) JavaScript (Node) Multiplatform </p> <p> MySQL</p> <p> JVM (JDBC) JVM (R2DBC)  </p> <p> PostgresSQL</p> <p> JVM (JDBC) JVM (R2DBC) Native (macOS, Linux)</p> <p>HSQL / H2(Experimental)</p> <p> JVM (JDBC) JVM (R2DBC)  </p>"},{"location":"#third-party-dialects","title":"Third party dialects","text":"<p> CockroachDB</p> <p> JVM </p> <p> DB2</p> <p> JVM </p> <p> Oracle DB</p> <p> JVM </p>"},{"location":"#snapshots","title":"Snapshots","text":"<p>Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's <code>snapshots</code> repository. Note that all coordinates are app.cash.sqldelight instead of com.squareup.sqldelight for 2.0.0+ SNAPSHOTs.</p> <p>Documentation pages for the latest snapshot version can be found here.</p> KotlinGroovy <pre><code>// settings.gradle.kts\npluginManagement {\n    repositories {\n        gradlePluginPortal()\n        maven(url = \"https://oss.sonatype.org/content/repositories/snapshots\")\n    }\n}\n\n// build.gradle.kts\nplugins {\n    id(\"app.cash.sqldelight\") version \"SNAPSHOT-VERSION\"\n}\n\nrepositories {\n    maven(url = \"https://oss.sonatype.org/content/repositories/snapshots\")\n}\n</code></pre> <pre><code>// settings.gradle\npluginManagement {\n    repositories {\n        gradlePluginPortal()\n        maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" }\n    }\n}\n\n// build.gradle\nplugins {\n    id \"app.cash.sqldelight\" version \"SNAPSHOT-VERSION\"\n}\n\nrepositories {\n    maven { url \"https://oss.sonatype.org/content/repositories/snapshots\" }\n}\n</code></pre> <p>Alpha IDE plugins are also available by using the alpha channel in IntelliJ: <code>https://plugins.jetbrains.com/plugins/alpha/com.squareup.sqldelight</code>. Snapshots are also available in the EAP channel: <code>https://plugins.jetbrains.com/plugins/eap/com.squareup.sqldelight</code> </p> <p></p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#210-2025-05-16","title":"[2.1.0] - 2025-05-16","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>[WASM Driver] Add support for wasmJs to web worker driver (#5534 by Ilya Gulya)</li> <li>[PostgreSQL Dialect] Support PostgreSql UnNest Array to rows  (#5673 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql TSRANGE/TSTZRANGE support (#5297 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql Right Full Join (#5086 by Griffio)</li> <li>[PostgreSQL Dialect] Postrgesql extract from temporal types (#5273 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql array contains operators (#4933 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql drop constraint (#5288 by Griffio)</li> <li>[PostgreSQL Dialect] Postgresql type casting (#5089 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql lateral join operator for subquery (#5122 by Griffio)</li> <li>[PostgreSQL Dialect] Postgresql ILIKE operator (#5330 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql XML type (#5331 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql AT TIME ZONE (#5243 by Griffio)</li> <li>[PostgreSQL Dialect] Support postgresql order by nulls (#5199 by Griffio)</li> <li>[PostgreSQL Dialect] Add PostgreSQL current date/time function support (#5226 by Drew Dobson)</li> <li>[PostgreSQL Dialect] PostgreSql Regex operators (#5137 by Griffio)</li> <li>[PostgreSQL Dialect] add brin gist (#5059 by Griffio)</li> <li>[MySQL Dialect] Support RENAME INDEX for MySql dialect (#5212 by Oren Kislev)</li> <li>[JSON Extension] Add alias to json table function (#5372 by Griffio)</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>[Compiler] Generated query files return row counts for simple mutators (#4578 by Marius Volkhart)</li> <li>[Native Driver] Update NativeSqlDatabase.kt to change readonly flag for DELETE, INSERT, and UPDATE statements (#5680 by Griffio)</li> <li>[PostgreSQL Dialect] Change PgInterval to String (#5403 by Griffio)</li> <li>[PostgreSQL Dialect] Support SqlDelight modules to implement PostgreSql extensions (#5677 by Griffio)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>[Compiler] fix: notify queries when executing group statements with result (#5006 by Vitor Hugo Schwaab)</li> <li>[Compiler] Fix SqlDelightModule type resolver (#5625 by Griffio)</li> <li>[Compiler] Fix 5501 insert object escaped column (#5503 by Griffio)</li> <li>[Compiler] Compiler: Improve error message such that path links are clickable with the correct line &amp; char position. (#5604 by Niklas Baudy)</li> <li>[Compiler] Fix issue 5298: allow keywords to be used as table names</li> <li>[Compiler] fix named executes and add test</li> <li>[Compiler] Consider foreign key table constraints when sorting initialization statements (#5325 by Leon Linhart)</li> <li>[Compiler] Align error underlines properly when tabs are involved (#5224 by Drew Dobson)</li> <li>[JDBC Driver] Fix memory leak for connectionManager during end of transaction</li> <li>[JDBC Driver] Run SQLite migrations inside transaction as mentioned in documentation (#5218 by Luk\u00e1\u0161 Moravec)</li> <li>[JDBC Driver] Fix leaking connections after transaction commit / rollback (#5205 by Luk\u00e1\u0161 Moravec)</li> <li>[Gradle Plugin] Execute <code>DriverInitializer</code> before <code>GenerateSchemaTask</code> (#5562 by Emeka Nwagu)</li> <li>[Runtime] Fix crash in LogSqliteDriver when real driver is Async (#5723 by Eric Denman)</li> <li>[Runtime] Fix StringBuilder capacity (#5192 by Jan B\u00edna)</li> <li>[PostgreSQL Dialect] PostgreSql create or replace view (#5407 by Griffio)</li> <li>[PostgreSQL Dialect] Postgresql to_json (#5606 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql numeric resolver (#5399 by Griffio)</li> <li>[PostgreSQL Dialect] sqlite windows function (#2799 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql SELECT DISTINCT ON (#5345 by Griffio)</li> <li>[PostgreSQL Dialect] alter table add column if not exists (#5309 by Griffio)</li> <li>[PostgreSQL Dialect] Postgresql async bind parameter (#5313 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql boolean literals (#5262 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql window functions (#5155 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql isNull isNotNull types (#5173 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSql select distinct (#5172 by Griffio)</li> <li>[Paging Extension] paging refresh initial load fix (#5615 by Eva)</li> <li>[Paging Extension] Add MacOS native targets (#5324 by Vitor Hugo Schwaab)</li> <li>[IntelliJ Plugin] K2 Support</li> </ul>"},{"location":"changelog/#202-2024-04-05","title":"[2.0.2] - 2024-04-05","text":""},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>[PostgreSQL Dialect] Add PostgreSQL STRING_AGG function (#4950 by Andr\u00e9 Danielsson)</li> <li>[PostgreSQL Dialect] Add SET statement to pg dialect (#4927 by Bastien de Luca)</li> <li>[PostgreSQL Dialect] Add PostgreSql alter column sequence parameters (#4916 by Griffio)</li> <li>[PostgreSQL Dialect] Add postgresql alter column default support for insert statement (#4912 by Griffio)</li> <li>[PostgreSQL Dialect] Add PostgreSql alter sequence and drop sequence (#4920 by Griffio)</li> <li>[PostgreSQL Dialect] Add Postgres Regex function definitions (#5025 by Marius Volkhart)</li> <li>[PostgreSQL Dialect] Add grammar for GIN (#5027 by Griffio)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>[IDE Plugin] Minimum version of 2023.1 / Android Studio Iguana</li> <li>[Compiler] Allow overriding the type nullability in encapsulatingType (#4882 by Eliezer Graber)</li> <li>[Compiler] Inline the column names for SELECT *</li> <li>[Gradle Plugin] switch to processIsolation (#5068 by Emeka Nwagu)</li> <li>[Android Runtime] Increase Android minSDK to 21 (#5094 by Philip Wedemann)</li> <li>[Drivers] Expose more JDBC/R2DBC statement methods for dialect authors (#5098 by Philip Wedemann)</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>[PostgreSQL Dialect] Fix postgresql alter table alter column (#4868 by Griffio)</li> <li>[PostgreSQL Dialect] Fix 4448 missing import for table model (#4885 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 4932 postgresql default constraint functions (#4934 by Griffio)</li> <li>[PostgreSQL Dialect] fixes 4879 postgresql class-cast error in alter table rename column during migrations (#4880 by Griffio)</li> <li>[PostgreSQL Dialect] Fix 4474 PostgreSql create extension (#4541 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 5018 PostgreSql add Primary Key not nullable types (#5020 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 4703 aggregate expressions (#5071 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 5028 PostgreSql json (#5030 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 5040 PostgreSql json operators (#5041 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes json operator binding for 5040 (#5100 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 5082 tsvector (#5104 by Griffio)</li> <li>[PostgreSQL Dialect] Fixes 5032 column adjacency for PostgreSql UPDATE FROM statement (#5035 by Griffio)</li> <li>[SQLite Dialect] fixes 4897 sqlite alter table rename column (#4899 by Griffio)</li> <li>[IDE Plugin] Fix error handler crash (#4988 by Alexander Perfilyev)</li> <li>[IDE Plugin] BugSnag fails to init in IDEA 2023.3 (by Alexander Perfilyev)</li> <li>[IDE Plugin] PluginException when opening .sq file in IntelliJ via plugin (by Alexander Perfilyev)</li> <li>[IDE Plugin] Dont bundle the kotlin lib into the intellij plugin as its already a plugin dependency (#5126)</li> <li>[IDE Plugin] Use the extensions array instead of stream (#5127)</li> </ul>"},{"location":"changelog/#201-2023-12-01","title":"[2.0.1] - 2023-12-01","text":""},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>[Compiler] Add support multi-column-expr when doing a SELECT (#4453 by Adriel Martinez)</li> <li>[PostgreSQL Dialect] Add support for PostgreSQL CREATE INDEX CONCURRENTLY (#4531 by Griffio)</li> <li>[PostgreSQL Dialect] Allow PostgreSQL CTEs auxiliary statements to reference each other (#4493 by Griffio)</li> <li>[PostgreSQL Dialect] Add support for PostgreSQL types for binary expr and sum (#4539 by Adriel Martinez)</li> <li>[PostgreSQL Dialect] Add support for PostgreSQL SELECT DISTINCT ON syntax (#4584 by Griffio)</li> <li>[PostgreSQL Dialect] Add support for PostgreSQL JSON functions in SELECT statements (#4590 by Marius Volkhart)</li> <li>[PostgreSQL Dialect] Add generate_series PostgreSQL function (#4717 by Griffio)</li> <li>[PostgreSQL Dialect] Add additional Postgres String function definitions (#4752 by Marius Volkhart)</li> <li>[PostgreSQL Dialect] Add DATE PostgreSQL type to min and max aggregate functions (#4816 by Andr\u00e9 Danielsson)</li> <li>[PostgreSQL Dialect] Add PostgreSql temporal types to SqlBinaryExpr (#4657 by Griifio)</li> <li>[PostgreSQL Dialect] Add TRUNCATE to postgres dialect (#4817 by Bastien de Luca)</li> <li>[SQLite 3.35 Dialect] Allow multiple ON CONFLICT clauses that are evaluated in order (#4551 by Griffio)</li> <li>[JDBC Driver] Add Language annotations for more pleasant SQL editing (#4602 by Marius Volkhart)</li> <li>[Native Driver] Native-driver: add support for linuxArm64 (#4792 by Philip Wedemann)</li> <li>[Android Driver] Add a windowSizeBytes parameter to AndroidSqliteDriver (#4804 by Benoit Lubek)</li> <li>[Paging3 Extension] feat: add initialOffset for OffsetQueryPagingSource (#4802 by Mohamad Jaara)</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>[Compiler] Prefer Kotlin types where appropriate (#4517 by Eliezer Graber)</li> <li>[Compiler] When doing a value type insert always include the column names (#4864)</li> <li>[PostgreSQL Dialect] Remove experimental status from PostgreSQL dialect (#4443 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Update docs for PostgreSQL types (#4569 by Marius Volkhart)</li> <li>[R2DBC Driver] Optimize performance when handling integer data types in PostgreSQL (#4588 by Marius Volkhart)</li> </ul>"},{"location":"changelog/#removed","title":"Removed","text":"<ul> <li>[SQLite Javascript Driver] Remove sqljs-driver (#4613, #4670 by Derek Ellis)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>[Compiler] Fix compilation of grouped statements with returns and no parameters (#4699 by Griffio)</li> <li>[Compiler] Bind arguments with SqlBinaryExpr (#4604 by Griffio)</li> <li>[IDE Plugin] Use IDEA Project JDK if set (#4689 by Griffio)</li> <li>[IDE Plugin] Fix \"Unknown element type: TYPE_NAME\" error in IDEA 2023.2 and greater (#4727)</li> <li>[IDE Plugin] Fixed some compatibility issues with 2023.2</li> <li>[Gradle Plugin] Correct documentation of verifyMigrationTask Gradle task (#4713 by Josh Friend)</li> <li>[Gradle Plugin] Add Gradle task output message to help users generate a database before verifying a database (#4684 by Jingwei)</li> <li>[PostgreSQL Dialect] Fix the renaming of PostgreSQL columns multiple times (#4566 by Griffio)</li> <li>[PostgreSQL Dialect] Fix 4714 postgresql alter column nullability (#4831 by Griffio)</li> <li>[PostgreSQL Dialect] Fix 4837 alter table alter column (#4846 by Griffio)</li> <li>[PostgreSQL Dialect] Fix 4501 PostgreSql sequence (#4528 by Griffio)</li> <li>[SQLite Dialect] Allow JSON binary operator to be used on a column expression (#4776 by Eliezer Graber)</li> <li>[SQLite Dialect] Update From false positive for multiple columns found with name (#4777 by Eliezer Graber)</li> <li>[Native Driver] Support named in-memory databases (#4662 by Matthew Nelson)</li> <li>[Native Driver] Ensure thread safety for query listener collection (#4567 by Kevin Galligan)</li> <li>[JDBC Driver] Fix a connection leak in the ConnectionManager (#4589 by Marius Volkhart)</li> <li>[JDBC Driver] Fix JdbcSqliteDriver url parsing when choosing ConnectionManager type (#4656 by Matthew Nelson)</li> </ul>"},{"location":"changelog/#200-2023-07-26","title":"[2.0.0] - 2023-07-26","text":""},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>[MySQL Dialect] MySQL: support timestamp/bigint in IF expression (#4329 by Mike Gershunovsky)</li> <li>[MySQL Dialect] MySQL: Add now (#4431 by Philip Wedemann)</li> <li>[Web Driver] Enable NPM package publishing (#4364)</li> <li>[IDE Plugin] Allow users to show the stacktrace when the gradle tooling connect fails (#4383)</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>[Sqlite Driver] Simplify using schema migrations for JdbcSqliteDriver (#3737 by Luk\u00e1\u0161 Moravec)</li> <li>[R2DBC Driver] Real async R2DBC cursor (#4387 by Philip Wedemann)</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>[IDE Plugin] Dont instantiate the database project service until needed (#4382)</li> <li>[IDE Plugin] Handle process cancellation during find usages (#4340)</li> <li>[IDE Plugin] Fix IDE generation of async code (#4406)</li> <li>[IDE Plugin] Move assembly of the package structure to be one-time computed and off the EDT (#4417)</li> <li>[IDE Plugin] Use the correct stub index key for kotlin type resolution on 2023.2 (#4416)</li> <li>[IDE Plugin] Wait for the index to be ready before performing a search (#4419)</li> <li>[IDE Plugin] Dont perform a goto if the index is unavailable (#4420)</li> <li>[Compiler] Fix result expression for grouped statements (#4378)</li> <li>[Compiler] Don't use virtual table as interface type (#4427 by Philip Wedemann)</li> </ul>"},{"location":"changelog/#200-rc02-2023-06-27","title":"[2.0.0-rc02] - 2023-06-27","text":""},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>[MySQL Dialect] support lowercase date types and min and max on date types (#4243 by Mike Gershunovsky)</li> <li>[MySQL Dialect] support mysql types for binary expr and sum (#4254 by Mike Gershunovsky)</li> <li>[MySQL Dialect] support unsigned ints without display width (#4306 by Mike Gershunovsky)</li> <li>[MySQL Dialect] Support LOCK IN SHARED MODE</li> <li>[PostgreSQL Dialect] Add boolean and Timestamp to min max (#4245 by Griffio)</li> <li>[PostgreSQL Dialect] Postgres: Add window function support (#4283 by Philip Wedemann)</li> <li>[Runtime] Add linuxArm64, androidNative and watchosDeviceArm targets to runtime (#4258 by Philip Wedemann)</li> <li>[Paging Extension] Add linux and mingw x64 target to the paging extension (#4280 by [Cedric Hippmann][chippman])</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>[Gradle Plugin] Add automatic dialect support for Android API 34 (#4251)</li> <li>[Paging Extension] Add support for SuspendingTransacter in QueryPagingSource (#4292 by Ilya Polenov)</li> <li>[Runtime] Improve addListener api (#4244 by Philip Wedemann)</li> <li>[Runtime] Use Long as migration version (#4297 by Philip Wedemann)</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>[Gradle Plugin] Use stable output path for generated source (#4269 by Josh Friend)</li> <li>[Gradle Plugin] Gradle tweaks (#4222 by Matthew Haughton)</li> </ul>"},{"location":"changelog/#200-rc01-2023-05-29","title":"[2.0.0-rc01] - 2023-05-29","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>[Paging] Add js browser target to paging extensions (#3843 by Sean Proctor)</li> <li>[Paging] Add iosSimulatorArm64 target to androidx-paging3 extension (#4117)</li> <li>[PostgreSQL Dialect] add support and test for gen_random_uuid() (#3855 by David Wheeler)</li> <li>[PostgreSQL Dialect] Alter table add constraint postgres (#4116 by Griffio)</li> <li>[PostgreSQL Dialect] Alter table add constraint check (#4120 by Griffio)</li> <li>[PostgreSQL Dialect] Add postgreSql character length functions (#4121 by Griffio)</li> <li>[PostgreSQL Dialect] Add postgreSql column default interval (#4142 by Griffio)</li> <li>[PostgreSQL Dialect] Add postgreSql interval column result (#4152 by Griffio)</li> <li>[PostgreSQL Dialect] Add postgreSql Alter Column (#4165 by Griffio)</li> <li>[PostgreSQL Dialect] PostgreSQL: Add date_part (#4198 by Philip Wedemann)</li> <li>[MySQL Dialect] Add sql char length functions (#4134 by Griffio)</li> <li>[IDE Plugin] Add sqldelight directory suggestions (#3976 by Alexander Perfilyev)</li> <li>[IDE Plugin] Compact middle packages in project tree (#3992 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add join clause completion (#4086 by Alexander Perfilyev)</li> <li>[IDE Plugin] Create view intention and live template (#4074 by Alexander Perfilyev)</li> <li>[IDE Plugin] Warn about missing WHERE inside DELETE or UPDATE (#4058 by Alexander Perfilyev)</li> <li>[Gradle Plugin] Enable typesafe project accessors (#4005 by Philip Wedemann)</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>[Gradle Plugin] Allow registering DriverInitializer for VerifyMigrationTask with ServiceLoader mechanism (#3986 by Alex Doubov)</li> <li>[Gradle Plugin] Create explicit compiler env (#4079 by Philip Wedemann)</li> <li>[JS Driver] Split web worker driver into separate artifact</li> <li>[JS Driver] Don't expose JsWorkerSqlCursor (#3874 by Philip Wedemann)</li> <li>[JS Driver] Disable publication of the sqljs driver (#4108)</li> <li>[Runtime] Enforce that synchronous drivers require a synchronous schema initializer (#4013)</li> <li>[Runtime] Improve async support for Cursors (#4102)</li> <li>[Runtime] Remove deprecated targets (#4149 by Philip Wedemann)</li> <li>[Runtime] Remove support for old MM (#4148 by Philip Wedemann)</li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>[R2DBC Driver] R2DBC: Await closing the driver (#4139 by Philip Wedemann)</li> <li>[Compiler] Include PRAGMAs from migrations in database create(SqlDriver) (#3845 by Marius Volkhart)</li> <li>[Compiler] Fix codegen for RETURNING clause (#3872 by Marius Volkhart)</li> <li>[Compiler] Dont generate types for virtual tables (#4015)</li> <li>[Gradle Plugin] Small Gradle plugin QoL improvements (#3930 by Zac Sweers)</li> <li>[IDE Plugin] Fix unresolved kotlin types (#3924 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix for expand wildcard intention to work with qualifier (#3979 by Alexander Perfilyev)</li> <li>[IDE Plugin] Use available jdk if java home is missing (#3925 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix find usages on package names (#4010)</li> <li>[IDE Plugin] Dont show auto imports for invalid elements (#4008)</li> <li>[IDE Plugin] Do not resolve if a dialect is missing (#4009)</li> <li>[IDE Plugin] Ignore IDE runs of the compiler during an invalidated state (#4016)</li> <li>[IDE Plugin] Add support for IntelliJ 2023.1 (#4037 by Madis Pink)</li> <li>[IDE Plugin] Rename named argument usage on column rename (#4027 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix add migration popup (#4105 by Alexander Perfilyev)</li> <li>[IDE Plugin] Disable SchemaNeedsMigrationInspection in migration files (#4106 by Alexander Perfilyev)</li> <li>[IDE Plugin] Use sql column name for migration generation instead of type name (#4112 by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#200-alpha05-2023-01-20","title":"[2.0.0-alpha05] - 2023-01-20","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>[Paging] Multiplatform paging extension (by Jeff Lockhart)</li> <li>[Runtime] Add fun modifier to Listener interface.</li> <li>[SQLite Dialect] Add SQLite 3.33 support (UPDATE FROM) (by Eliezer Graber))</li> <li>[PostgreSQL Dialect] Support UPDATE FROM in postgresql (by Eliezer Graber))</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>[RDBC Driver] Expose the connection (by Philip Wedemann)</li> <li>[Runtime] Move migration callbacks into main <code>migrate</code> fun</li> <li>[Gradle Plugin] Hide Configurations from downstream projects</li> <li>[Gradle Plugin] Only shade Intellij (by Philip Wedemann)</li> <li>[Gradle Plugin] Support Kotlin 1.8.0-Beta and add multi version Kotlin test (by Philip Wedemann)</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>[RDBC Driver] Use javaObjectType instead (by Philip Wedemann)</li> <li>[RDBC Driver] Fix primitive null values in bindStatement (by Philip Wedemann)</li> <li>[RDBC Driver] Support R2DBC 1.0 (by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Postgres: Fix Array without type parameter (by Philip Wedemann)</li> <li>[IDE Plugin] Bump intellij to 221.6008.13 (by Philip Wedemann)</li> <li>[Compiler] Resolve recursive origin table from pure views (by Philip Wedemann)</li> <li>[Compiler] Use value classes from table foreign key clause (by Philip Wedemann)</li> <li>[Compiler] Fix SelectQueryGenerator to support bind expression without parenthesis (by Doogie Min)</li> <li>[Compiler] Fix duplicate generation of ${name}Indexes variables when using transactions (by Andreas Sacher)</li> </ul>"},{"location":"changelog/#155-2023-01-20","title":"[1.5.5] - 2023-01-20","text":"<p>This is a compatibility release for Kotlin 1.8 and IntelliJ 2021+, supporting JDK 17.</p>"},{"location":"changelog/#154-2022-10-06","title":"[1.5.4] - 2022-10-06","text":"<p>This is a compatibility update for Kotlin 1.7.20 and AGP 7.3.0.</p>"},{"location":"changelog/#200-alpha04-2022-10-03","title":"[2.0.0-alpha04] - 2022-10-03","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The Paging 3 extension API has changed to only allow int types for the count.</li> <li>The coroutines extension now requires a dispatcher to be passed in instead of defaulting.</li> <li>Dialect and Driver classes are final, use delegation instead.</li> </ul>"},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>[HSQL Dialect] Hsql: Support using DEFAULT for generated columns in Insert (#3372 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] PostgreSQL: Support using DEFAULT for generated columns in INSERT  (#3373 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Add NOW() to PostgreSQL (#3403 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] PostgreSQL Add NOT operator (#3504 by Philip Wedemann)</li> <li>[Paging] Allow passing in CoroutineContext to *QueryPagingSource (#3384)</li> <li>[Gradle Plugin] Add better version catalog support for dialects (#3435)</li> <li>[Native Driver] Add callback to hook into DatabaseConfiguration creation of NativeSqliteDriver (#3512 by Sven Jacobs)</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>[Paging] Add a default dispatcher to the KeyedQueryPagingSource backed QueryPagingSource function (#3385)</li> <li>[Paging] Make OffsetQueryPagingSource only work with Int (#3386)</li> <li>[Async Runtime] Move await* to upper class ExecutableQuery (#3524 by Philip Wedemann)</li> <li>[Coroutines Extensions] Remove default params to flow extensions (#3489)</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>[Gradle Plugin] Update to Kotlin 1.7.20 (#3542 by Zac Sweers)</li> <li>[R2DBC Driver] Adopt R2DBC changes which do not always send a value (#3525 by Philip Wedemann)</li> <li>[HSQL Dialect] Fix failing sqlite VerifyMigrationTask with Hsql (#3380 by Philip Wedemann)</li> <li>[Gradle Plugin] Convert tasks to use lazy configuration API (by Matthew Haughton)</li> <li>[Gradle Plugin] Avoid NPEs in Kotlin 1.7.20 (#3398 by Zac Sweers)</li> <li>[Gradle Plugin] Fix description of squash migrations task (#3449)</li> <li>[IDE Plugin] Fix NoSuchFieldError in newer Kotlin plugins (#3422 by Madis Pink)</li> <li>[IDE Plugin] IDEA: UnusedQueryInspection - fix ArrayIndexOutOfBoundsException. (#3427 by Niklas Baudy)</li> <li>[IDE Plugin] Use reflection for old kotlin plugin references</li> <li>[Compiler] Custom dialect with extension function don't create imports (#3338 by Philip Wedemann)</li> <li>[Compiler] Fix escaping CodeBlock.of(\"${CodeBlock.toString()}\") (#3340 by Philip Wedemann)</li> <li>[Compiler] Await async execute statements in migrations (#3352)</li> <li>[Compiler] Fix AS (#3370 by Philip Wedemann)</li> <li>[Compiler] <code>getObject</code>  method supports automatic filling of the actual type. (#3401 by Rob X)</li> <li>[Compiler] Fix codegen for async grouped returning statements (#3411)</li> <li>[Compiler] Infer the Kotlin type of bind parameter, if possible, or fail with a better error message (#3413 by Philip Wedemann)</li> <li>[Compiler] Don't allow ABS(\"foo\") (#3430 by Philip Wedemann)</li> <li>[Compiler] Support inferring kotlin type from other parameters (#3431 by Philip Wedemann)</li> <li>[Compiler] Always create the database implementation (#3540 by Philip Wedemann)</li> <li>[Compiler] Relax javaDoc and add it to custom mapper function too (#3554 Philip Wedemann)</li> <li>[Compiler] Fix DEFAULT in binding (by Philip Wedemann)</li> <li>[Paging] Fix Paging 3 (#3396)</li> <li>[Paging] Allow construction of OffsetQueryPagingSource with Long (#3409)</li> <li>[Paging] Don't statically swap Dispatchers.Main (#3428)</li> </ul>"},{"location":"changelog/#200-alpha03-2022-06-17","title":"[2.0.0-alpha03] - 2022-06-17","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Dialects are now references like actual gradle dependencies. <pre><code>sqldelight {\n  MyDatabase {\n    dialect(\"app.cash.sqldelight:postgres-dialect:2.0.0-alpha03\")\n  }\n}\n</code></pre></li> <li>The <code>AfterVersionWithDriver</code> type was removed in favour of <code>AfterVersion</code> which now always has the driver.</li> <li>The <code>Schema</code> type is no longer a subtype of <code>SqlDriver</code></li> <li><code>PreparedStatement</code> APIs are now called with zero-based indexes.</li> </ul>"},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>[IDE Plugin] Added support for running SQLite, MySQL, and PostgreSQL commands against a running database (#2718 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add support for the android studio DB inspector (#3107 by Alexander Perfilyev)</li> <li>[Runtime] Add support for async drivers (#3168 by Derek Ellis)</li> <li>[Native Driver] Support new kotlin native memory model (#3177 by Kevin Galligan)</li> <li>[JS Driver] Add a driver for SqlJs workers (#3203 by Derek Ellis)</li> <li>[Gradle Plugin] Expose the classpath for SQLDelight tasks</li> <li>[Gradle Plugin] Add a gradle task for squashing migrations</li> <li>[Gradle Plugin] Add a flag to ignore schema definitions during migration checks</li> <li>[MySQL Dialect] Support FOR SHARE and FOR UPDATE in MySQL (#3098)</li> <li>[MySQL Dialect] Support MySQL index hints (#3099)</li> <li>[PostgreSQL Dialect] Add date_trunc (#3295 by Philip Wedemann)</li> <li>[JSON Extensions] Support JSON table functions (#3090)</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>[Runtime] Remove the AfterVersion type without the driver (#3091)</li> <li>[Runtime] Move Schema type to top-level</li> <li>[Runtime] Open dialect and resolver to support 3rd party implementations (#3232 by Philip Wedemann)</li> <li>[Compiler] Include the dialect used to compile in failure reports (#3086)</li> <li>[Compiler] Skip unused adapters (#3162 by Eliezer Graber)</li> <li>[Compiler] Use zero based index in PrepareStatement (#3269 by Philip Wedemann)</li> <li>[Gradle Plugin] Also make the dialect a proper gradle dependency instead of a string (#3085)</li> <li>[Gradle Plugin] Gradle Verify Task: Throw when missing database file. (#3126 by Niklas Baudy)</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>[Gradle Plugin] Minor cleanups and tweaks to the Gradle plugin (#3171 by Matthew Haughton)</li> <li>[Gradle Plugin] Dont use an AGP string for the generated directory</li> <li>[Gradle Plugin] Use AGP namespace attribute (#3220)</li> <li>[Gradle Plugin] Do not add kotlin-stdlib as a runtime dependency of the Gradle plugin (#3245 by [Martin Bonnin][mbonnin])</li> <li>[Gradle Plugin] Simplify the multiplatform configuration (#3246 by [Martin Bonnin][mbonnin])</li> <li>[Gradle Plugin] Support js only projects (#3310 by Philip Wedemann)</li> <li>[IDE Plugin] Use java home for gradle tooling API (#3078)</li> <li>[IDE Plugin] Load the JDBC driver on the correct classLoader inside the IDE plugin (#3080)</li> <li>[IDE Plugin] Mark the file element as null before invalidating to avoid errors during already existing PSI changes (#3082)</li> <li>[IDE Plugin] Dont crash finding usages of the new table name in an ALTER TABLE statement (#3106)</li> <li>[IDE Plugin] Optimize the inspectors and enable them to fail silently for expected exception types (#3121)</li> <li>[IDE Plugin] Delete files that should be generated directories (#3198)</li> <li>[IDE Plugin] Fix a not-safe operator call</li> <li>[Compiler] Ensure updates and deletes with RETURNING statements execute queries. (#3084)</li> <li>[Compiler] Correctly infer argument types in compound selects (#3096)</li> <li>[Compiler] Common tables do not generate data classes so dont return them (#3097)</li> <li>[Compiler] Find the top migration file faster (#3108)</li> <li>[Compiler] Properly inherit nullability on the pipe operator</li> <li>[Compiler] Support the iif ANSI SQL function</li> <li>[Compiler] Don't generate empty query files (#3300 by Philip Wedemann)</li> <li>[Compiler] Fix adapter with question mark only (#3314 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Postgres primary key columns are always non-null (#3092)</li> <li>[PostgreSQL Dialect] Fix copy with same name in multiple tables (#3297 by Philip Wedemann)</li> <li>[SQLite 3.35 Dialect] Only show an error when dropping an indexed column from the altered table (#3158 by Eliezer Graber)</li> </ul>"},{"location":"changelog/#200-alpha02-2022-04-13","title":"[2.0.0-alpha02] - 2022-04-13","text":""},{"location":"changelog/#breaking-changes_2","title":"Breaking Changes","text":"<ul> <li>You'll need to replace all occurrences of <code>app.cash.sqldelight.runtime.rx</code> with <code>app.cash.sqldelight.rx2</code></li> </ul>"},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>[Compiler] Support returning at the end of a grouped statement</li> <li>[Compiler] Support compiler extensions via dialect modules and add a SQLite JSON extension (#1379, #2087)</li> <li>[Compiler] Support PRAGMA statements which return a value (#1106)</li> <li>[Compiler] Support generating value types for marked columns</li> <li>[Compiler] Add support for optimistic locks and validation (#1952)</li> <li>[Compiler] Support multi-update statements</li> <li>[PostgreSQL] Support postgres returning statements</li> <li>[PostgreSQL] Support postgres date types</li> <li>[PostgreSQL] Support pg intervals</li> <li>[PostgreSQL] Support PG Booleans and fix inserts on alter tables</li> <li>[PostgreSQL] Support optional limits in Postgres</li> <li>[PostgreSQL] Support PG BYTEA type</li> <li>[PostgreSQL] Add a test for postgres serials</li> <li>[PostgreSQL] Support for update postgres syntax</li> <li>[PostgreSQL] Support PostgreSQL array types</li> <li>[PostgreSQL] Properly store/retrieve UUID types in PG</li> <li>[PostgreSQL] Support PostgreSQL NUMERIC type (#1882)</li> <li>[PostgreSQL] Support returning queries inside of common table expressions (#2471)</li> <li>[PostgreSQL] Support json specific operators</li> <li>[PostgreSQL] Add Postgres Copy (by Philip Wedemann)</li> <li>[MySQL] Support MySQL Replace</li> <li>[MySQL] Support NUMERIC/BigDecimal MySQL types (#2051)</li> <li>[MySQL] Support MySQL truncate statement</li> <li>[MySQL] Support json specific operators in Mysql (by Eliezer Graber)</li> <li>[MySQL] Support MySql INTERVAL (#2969 by Eliezer Graber)</li> <li>[HSQL] Add HSQL Window functionality</li> <li>[SQLite] Don't replace equality checks for nullable parameters in a WHERE (#1490 by Eliezer Graber)</li> <li>[SQLite] Support Sqlite 3.35 returning statements (#1490 by Eliezer Graber)</li> <li>[SQLite] Support GENERATED clause</li> <li>[SQLite] Add support for Sqlite 3.38 dialect (by Eliezer Graber)</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>[Compiler] Clean up generated code a bit</li> <li>[Compiler] Forbid usage of table parameters in grouped statements (#1822)</li> <li>[Compiler] Put grouped queries inside a transaction (#2785)</li> <li>[Runtime] Return the updated row count from the drivers execute method</li> <li>[Runtime] Confine SqlCursor to the critical section accessing the connection. (#2123 by Anders Ha)</li> <li>[Gradle Plugin] Compare schema definitions for migrations (#841)</li> <li>[PostgreSQL] Disallow double quotes for PG</li> <li>[MySQL] Error on usage of == in MySQL (#2673)</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>[Compiler] Same adapter type from different tables causing a compilation error in 2.0 alpha</li> <li>[Compiler] Problem compiling upsert statement (#2791)</li> <li>[Compiler] Query result should use tables in the select if there are multiple matches (#1874, #2313)</li> <li>[Compiler] Support updating a view which has a INSTEAD OF trigger (#1018)</li> <li>[Compiler] Support from and for in function names</li> <li>[Compiler] Allow SEPARATOR keyword in function expressions</li> <li>[Compiler] Cannot access ROWID of aliased table in ORDER BY</li> <li>[Compiler] Aliased column name is not recognized in HAVING clause in MySQL</li> <li>[Compiler] Erroneous 'Multiple columns found' error</li> <li>[Compiler] Unable to set PRAGMA locking_mode = EXCLUSIVE;</li> <li>[PostgreSQL] Postgresql rename column</li> <li>[MySQL] UNIX_TIMESTAMP, TO_SECONDS, JSON_ARRAYAGG MySQL functions not recognized</li> <li>[SQLite] fix SQLite window functionality</li> <li>[IDE Plugin] Run the goto handler in an empty progress indicator (#2990)</li> <li>[IDE Plugin] Ensure the highlight visitor doesnt run if the project isnt configured (#2981, #2976)</li> <li>[IDE Plugin] Ensure transitive generated code is also updated in the IDE (#1837)</li> <li>[IDE Plugin] Invalidate indexes when updating the dialect</li> </ul>"},{"location":"changelog/#200-alpha01-2022-03-31","title":"[2.0.0-alpha01] - 2022-03-31","text":"<p>This is the first alpha release for 2.0 and has some breaking changes. We expect more ABI breaking changes to come so don't publish any libraries with dependencies on this release (applications should be fine).</p>"},{"location":"changelog/#breaking-changes_3","title":"Breaking Changes","text":"<ul> <li>First, you'll need to replace all occurrences of <code>com.squareup.sqldelight</code> with <code>app.cash.sqldelight</code></li> <li>Second, you'll need to replace all occurrences of <code>app.cash.sqldelight.android</code> with <code>app.cash.sqldelight.driver.android</code></li> <li>Third, you'll need to replace all occurrences of <code>app.cash.sqldelight.sqlite.driver</code> with <code>app.cash.sqldelight.driver.jdbc.sqlite</code></li> <li>Fourth, you'll need to replace all occurrences of <code>app.cash.sqldelight.drivers.native</code> with <code>app.cash.sqldelight.driver.native</code></li> <li>The IDE plugin must be updated to a 2.X version, which can be found in the alpha or eap channel</li> <li>Dialects are now dependencies which you can specify within gradle:</li> </ul> <pre><code>sqldelight {\n  MyDatabase {\n    packageName = \"com.example\"\n    dialect = \"app.cash.sqldelight:mysql-dialect:2.0.0-alpha01\"\n  }\n}\n</code></pre> <p>The currently supported dialects are <code>mysql-dialect</code>, <code>postgresql-dialect</code>, <code>hsql-dialect</code>, <code>sqlite-3-18-dialect</code>, <code>sqlite-3-24-dialect</code>, <code>sqlite-3-25-dialect</code>, <code>sqlite-3-30-dialect</code>, and <code>sqlite-3-35-dialect</code></p> <ul> <li>Primitive types must now be imported (for example <code>INTEGER AS Boolean</code> you have to <code>import kotlin.Boolean</code>), some previously supported types now need an adapter. Primitive adapters are available in <code>app.cash.sqldelight:primitive-adapters:2.0.0-alpha01</code> for most conversions (like <code>IntColumnAdapter</code> for doing <code>Integer AS kotlin.Int</code>).</li> </ul>"},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>[IDE Plugin] Basic suggested migration (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add import hint action (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add kotlin class completion (by Alexander Perfilyev)</li> <li>[Gradle Plugin] Add shortcut for Gradle type safe project accessors (by Philip Wedemann)</li> <li>[Compiler] Customize codegen based on dialect (by Marius Volkhart)</li> <li>[JDBC Driver] Add common types to JdbcDriver (by Marius Volkhart)</li> <li>[SQLite] Add support for the sqlite 3.35 (by Eliezer Graber)</li> <li>[SQLite] Add support for ALTER TABLE DROP COLUMN (by Eliezer Graber)</li> <li>[SQLite] Add support for Sqlite 3.30 dialect (by Eliezer Graber)</li> <li>[SQLite] Support NULLS FIRST/LAST in sqlite (by Eliezer Graber)</li> <li>[HSQL] Add HSQL support for generated clause (by Marius Volkhart)</li> <li>[HSQL] Add support for named parameters in HSQL (by Marius Volkhart)</li> <li>[HSQL] Customize the HSQL insert query (by Marius Volkhart)</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>[Everything] Package name has changed from com.squareup.sqldelight to app.cash.sqldelight.</li> <li>[Runtime] Move dialects into their own isolated gradle modules</li> <li>[Runtime] Switch to driver-implemented query notifications.</li> <li>[Runtime] Extract default column adapters to separate module (#2056, #2060)</li> <li>[Compiler] Let modules generate the queries implementations instead of redoing it in each module</li> <li>[Compiler] Remove the custom toString generation of generated data classes. (by Paul Woitaschek)</li> <li>[JS Driver] Remove sql.js dependency from sqljs-driver (by Derek Ellis)</li> <li>[Paging] Remove the android paging 2 extension</li> <li>[IDE Plugin] Add an editor banner while SQLDelight is syncing (#2511)</li> <li>[IDE Plugin] Minimum supported IntelliJ version is 2021.1</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>[Runtime] Flatten listener list to reduce allocations and pointer chasing. (by Anders Ha)</li> <li>[IDE Plugin] Fix error message to allow jumping to error (by Philip Wedemann)</li> <li>[IDE Plugin] Add missing inspection descriptions (#2768 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix exception in GotoDeclarationHandler (#2531, #2688, #2804 by Alexander Perfilyev)</li> <li>[IDE Plugin] Highlight import keyword (by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix unresolved kotlin types (#1678 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix highlighting for unresolved package (#2543 by Alexander Perfilyev)</li> <li>[IDE Plugin] Dont attempt to inspect mismatched columns if the project index is not yet initialized</li> <li>[IDE Plugin] Dont initialize the file index until a gradle sync has occurred</li> <li>[IDE Plugin] Cancel the SQLDelight import if a gradle sync begins</li> <li>[IDE Plugin] Regenerate the database outside of the thread an undo action is performed on</li> <li>[IDE Plugin] If a reference cannot be resolves use a blank java type</li> <li>[IDE Plugin] Correctly move off the main thread during file parsing and only move back on to write</li> <li>[IDE Plugin] Improve compatibility with older IntelliJ versions (by Matthew Haughton)</li> <li>[IDE Plugin] Use faster annotation API</li> <li>[Gradle Plugin] Explicitly support js/android plugins when adding runtime (by Zac Sweers)</li> <li>[Gradle Plugin] Register migration output task without derviving schemas from migrations (#2744 by Kevin Cianfarini)</li> <li>[Gradle Plugin] If the migration task crashes, print the file it crashed running</li> <li>[Gradle Plugin] Sort files when generating code to ensure idempotent outputs (by Zac Sweers)</li> <li>[Compiler] Use faster APIs for iterating files and dont explore the entire PSI graph</li> <li>[Compiler] Add keyword mangling to select function parameters (#2759 by Alexander Perfilyev)</li> <li>[Compiler] Fix packageName for migration adapter (by Philip Wedemann)</li> <li>[Compiler] Emit annotations on properties instead of types (#2798 by Alexander Perfilyev)</li> <li>[Compiler] Sort arguments before passing to a Query subtype (#2379 by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#153-2021-11-23","title":"[1.5.3] - 2021-11-23","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>[JDBC Driver] Open JdbcDriver for 3rd party driver implementations (#2672 by Philip Wedemann)</li> <li>[MySQL Dialect] Add missing functions for time increments (#2671 by Sam Doward)</li> <li>[Coroutines Extension] Add M1 targets for coroutines-extensions (by Philip Dukhov)</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>[Paging3 Extension] Distribute sqldelight-android-paging3 as JAR instead of AAR (#2634 by Marco Romano)</li> <li>Property names which are also soft keywords will now be suffixed with underscores. For instance <code>value</code> will be exposed as <code>value_</code></li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>[Compiler] Don't extract variables for duplicate array parameters (by Alexander Perfilyev)</li> <li>[Gradle Plugin] add kotlin.mpp.enableCompatibilityMetadataVariant. (#2628 by Martin Bonnin)</li> <li>[IDE Plugin] Find usages processing requires a read action</li> </ul>"},{"location":"changelog/#152-2021-10-12","title":"[1.5.2] - 2021-10-12","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>[Gradle Plugin] HMPP support (#2548 by Martin Bonnin)</li> <li>[IDE Plugin] Add NULL comparison inspection (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add inspection suppressor (#2519 by Alexander Perfilyev)</li> <li>[IDE Plugin] Mixed named and positional parameters inspection (by Alexander Perfilyev)</li> <li>[SQLite Driver] Add mingwX86 target. (#2558 by Nikita Kozhemyakin)</li> <li>[SQLite Driver] Add M1 targets</li> <li>[SQLite Driver] Add linuxX64 support (#2456 by Cedric Hippmann)</li> <li>[MySQL Dialect] Add ROW_COUNT function to mysql (#2523)</li> <li>[PostgreSQL Dialect] postgres rename, drop column (by Juan Liska)</li> <li>[PostgreSQL Dialect] PostgreSQL grammar doesn't recognize CITEXT</li> <li>[PostgreSQL Dialect] Include TIMESTAMP WITH TIME ZONE and TIMESTAMPTZ</li> <li>[PostgreSQL Dialect] Add grammar for PostgreSQL GENERATED columns</li> <li>[Runtime] Provide SqlDriver as a parameter to AfterVersion (#2534, 2614 by Ahmed El-Helw)</li> </ul>"},{"location":"changelog/#changed_12","title":"Changed","text":"<ul> <li>[Gradle Plugin] explicitely require Gradle 7.0 (#2572 by Martin Bonnin)</li> <li>[Gradle Plugin] Make VerifyMigrationTask support Gradle's up-to-date checks (#2533 by Matthew Haughton)</li> <li>[IDE Plugin] Don't warn with \"Join compares two columns of different types\" when joining nullable with non-nullable type (#2550 by Piotr Chmielowski)</li> <li>[IDE Plugin] Clarify the error for the lowercase 'as' in column type (by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>[IDE Plugin] Do not reparse under a new dialect if the project is already disposed (#2609)</li> <li>[IDE Plugin] If the associated virtual file is null, the module is null (#2607)</li> <li>[IDE Plugin] Avoid crashing during the unused query inspection (#2610)</li> <li>[IDE Plugin] Run the database sync write inside of a write action (#2605)</li> <li>[IDE Plugin] Let the IDE schedule SQLDelight syncronization</li> <li>[IDE Plugin] Fix npe in JavaTypeMixin (#2603 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix IndexOutOfBoundsException in MismatchJoinColumnInspection (#2602 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add description for UnusedColumnInspection (#2600 by Alexander Perfilyev)</li> <li>[IDE Plugin] Wrap PsiElement.generatedVirtualFiles into read action (#2599 by Alexander Perfilyev)</li> <li>[IDE Plugin] Remove unnecessary nonnull cast (#2596)</li> <li>[IDE Plugin] Properly handle nulls for find usages (#2595)</li> <li>[IDE Plugin] Fix IDE autocomplete for generated files for Android (#2573 by Martin Bonnin)</li> <li>[IDE Plugin] Fix npe in SqlDelightGotoDeclarationHandler (by Alexander Perfilyev)</li> <li>[IDE Plugin] Mangle kotlin keywords in arguments inside insert stmt (#2433 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix npe in SqlDelightFoldingBuilder (#2382 by Alexander Perfilyev)</li> <li>[IDE Plugin] Catch ClassCastException in CopyPasteProcessor (#2369 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix update live template (by Ilias Redissi)</li> <li>[IDE Plugin] Adds descriptions to intention actions (#2489 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix exception in CreateTriggerMixin if table is not found (by Alexander Perfilyev)</li> <li>[Compiler] Topologically sort table creation statemenets</li> <li>[Compiler] Stop invoking <code>forDatabaseFiles</code> callback on directories (#2532)</li> <li>[Gradle Plugin] Propagate generateDatabaseInterface task dependency to potential consumers (#2518 by Martin Bonnin)</li> </ul>"},{"location":"changelog/#151-2021-07-16","title":"[1.5.1] - 2021-07-16","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>[PostgreSQL Dialect] PostgreSQL JSONB and ON Conflict Do Nothing (by Andrew Stewart)</li> <li>[PostgreSQL Dialect] Adds support for PostgreSQL ON CONFLICT (column, ...) DO UPDATE (by Andrew Stewart)</li> <li>[MySQL Dialect] Support MySQL generated columns (by Jeff Gulbronson)</li> <li>[Native Driver] Add watchosX64 support</li> <li>[IDE Plugin] Add parameter types and annotations (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add action to generate 'select all' query (by Alexander Perfilyev)</li> <li>[IDE Plugin] Show column types in autocomplete (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add icons to autocomplete (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add action to generate 'select by primary key' query (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add action to generate 'insert into' query (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add highlighting for column names, stmt identifiers, function names (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add remaining query generation actions (#489 by Alexander Perfilyev)</li> <li>[IDE Plugin] Show parameter hints from insert-stmt (by Alexander Perfilyev)</li> <li>[IDE Plugin] Table alias intention action (by Alexander Perfilyev)</li> <li>[IDE Plugin] Qualify column name intention (by Alexander Perfilyev)</li> <li>[IDE Plugin] Go to declaration for kotlin property (by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#changed_13","title":"Changed","text":"<ul> <li>[Native Driver] Improve native transaction performance by avoiding freezing and shareable data structures when possible (by Anders Ha)</li> <li>[Paging 3] Bump Paging3 version to 3.0.0 stable</li> <li>[JS Driver] Upgrade sql.js to 1.5.0</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>[JDBC SQLite Driver] Call close() on connection before clearing the ThreadLocal (#2444 by Hannes Stru\u00df)</li> <li>[RX extensions] Fix subscription / disposal race leak (#2403 by Pierre Yves Ricau)</li> <li>[Coroutines extension] Ensure we register query listener before notifying</li> <li>[Compiler] Sort notifyQueries to have consistent kotlin output file (by Jiayu Chen)</li> <li>[Compiler] Don't annotate select query class properties with @JvmField (by Eliezer Graber)</li> <li>[IDE Plugin] Fix import optimizer (#2350 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix unused column inspection (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add nested classes support to import inspection and class annotator (by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix npe in CopyPasteProcessor (#2363 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix crash in InlayParameterHintsProvider (#2359 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix insertion of blank lines when copy-pasting any text into create table stmt (#2431 by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#150-2021-04-23","title":"[1.5.0] - 2021-04-23","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>[SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis)</li> <li>[Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini)</li> </ul>"},{"location":"changelog/#150-2021-04-23_1","title":"[1.5.0] - 2021-04-23","text":""},{"location":"changelog/#added_15","title":"Added","text":"<ul> <li>[SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis)</li> <li>[Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini)</li> <li>[MySQL Dialect] Adds support for mysql's ON DUPLICATE KEY UPDATE conflict resolution. (by Ryan Harter)</li> <li>[SQLite Dialect] Add compiler support for SQLite offsets() (by Quinton Roberts)</li> <li>[IDE Plugin] Add import quick fix for unknown type (#683 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add unused import inspection (#1161 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add unused query inspection (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add unused column inspection (#569 by Alexander Perfilyev)</li> <li>[IDE Plugin] Automatically bring imports on copy/paste (#684 by Alexander Perfilyev)</li> <li>[IDE Plugin] Pop a balloon when there are incompatibilities between gradle/intellij plugin versions</li> <li>[IDE Plugin] Insert Into ... VALUES(?) parameter hints (#506 by Alexander Perfilyev)</li> <li>[IDE Plugin] Inline parameter hints (by Alexander Perfilyev)</li> <li>[Runtime] Include an API in the runtime for running migrations with callbacks (#1844)</li> </ul>"},{"location":"changelog/#changed_14","title":"Changed","text":"<ul> <li>[Compiler] Smart cast \"IS NOT NULL\" queries (#867)</li> <li>[Compiler] Protect against keywords that will fail at runtime (#1471, #1629)</li> <li>[Gradle Plugin] Reduce size of gradle plugin from 60mb -&gt; 13mb.</li> <li>[Gradle Plugin] Properly support android variants, and remove support for KMM target-specific sql (#1039)</li> <li>[Gradle Plugin] Pick a minimum sqlite version based on minsdk (#1684)</li> <li>[Native Driver] Native driver connection pool and performance updates</li> </ul>"},{"location":"changelog/#fixed_14","title":"Fixed","text":"<ul> <li>[Compiler] NBSP before lambdas (by Beno\u00eet Quenaudon)</li> <li>[Compiler] Fix incompatible types in generated bind and cursor.get statements</li> <li>[Compiler] SQL clause should persist adapted type (#2067)</li> <li>[Compiler] Column with only NULL keyword should be nullable</li> <li>[Compiler] Dont generate mapper lambda with type annotations (#1957)</li> <li>[Compiler] If custom queries would clash, use the file name as an additional package suffix (#1057, #1278)</li> <li>[Compiler] Ensure foreign key cascades cause query listeners to be notified (#1325, #1485)</li> <li>[Compiler] If unioning two of the same type, return the table type (#1342)</li> <li>[Compiler] Ensure params to ifnull and coalesce can be nullable (#1263)</li> <li>[Compiler] Correctly use query-imposed nullability for expressions</li> <li>[MySQL Dialect] Support MySQL if statements</li> <li>[PostgreSQL Dialect] Retrieve NUMERIC and DECIMAL as Double in PostgreSQL (#2118)</li> <li>[SQLite Dialect] UPSERT notifications should account for BEFORE/AFTER UPDATE triggers. (#2198 by Anders Ha)</li> <li>[SQLite Driver] Use multiple connections for threads in the SqliteDriver unless we are in memory (#1832)</li> <li>[JDBC Driver] JDBC Driver assumes autoCommit is true (#2041)</li> <li>[JDBC Driver] Ensure that we close connections on exception (#2306)</li> <li>[IDE Plugin] Fix GoToDeclaration/FindUsages being broken on Windows due to path separator bug (#2054 by Angus Holder)</li> <li>[IDE Plugin] Ignore gradle errors instead of crashing in the IDE.</li> <li>[IDE Plugin] If a sqldelight file is moved to a non-sqldelight module, do not attempt codegen</li> <li>[IDE Plugin] Ignore codegen errors in IDE</li> <li>[IDE Plugin] Ensure that we dont try to negatively substring (#2068)</li> <li>[IDE Plugin] Also ensure project is not disposed before running gradle action (#2155)</li> <li>[IDE Plugin] Arithmetic on nullable types should also be nullable (#1853)</li> <li>[IDE Plugin] Make 'expand * intention' work with additional projections (#2173 by Alexander Perfilyev)</li> <li>[IDE Plugin] If kotlin resolution fails during GoTo, dont attempt to go to sqldelight files</li> <li>[IDE Plugin] If IntelliJ encounters an exception while sqldelight is indexing, dont crash</li> <li>[IDE Plugin] Handle exceptions that happen while detecting errors before codegen in the IDE</li> <li>[IDE Plugin] Make the IDE plugin compatible with Dynamic Plugins (#1536)</li> <li>[Gradle Plugin] Race condition generating a database using WorkerApi (#2062 by St\u00e9phane Nicolas)</li> <li>[Gradle Plugin] classLoaderIsolation prevents custom jdbc usage (#2048 by Ben Asher)</li> <li>[Gradle Plugin] Improve missing packageName error message (by Niklas Baudy)</li> <li>[Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998)</li> <li>[Gradle Plugin] Fix gradle build caching (#2075)</li> <li>[Gradle Plugin] Do not depend on kotlin-native-utils in Gradle plugin (by Ilya Matveev)</li> <li>[Gradle Plugin] Also write the database if there are only migration files (#2094)</li> <li>[Gradle Plugin] Ensure diamond dependencies only get picked up once in the final compilation unit (#1455)</li> </ul> <p>Also just a general shoutout to Matthew Haughton who did a lot of work to improve the SQLDelight infrastructure this release.</p>"},{"location":"changelog/#144-2020-10-08","title":"[1.4.4] - 2020-10-08","text":""},{"location":"changelog/#added_16","title":"Added","text":"<ul> <li>[PostgreSQL Dialect] Support data-modifying statements in WITH</li> <li>[PostgreSQL Dialect] Support substring function</li> <li>[Gradle Plugin] Added verifyMigrations flag for validating migrations during SQLDelight compilation (#1872)</li> </ul>"},{"location":"changelog/#changed_15","title":"Changed","text":"<ul> <li>[Compiler] Flag SQLite specific functions as unknown in non-SQLite dialects</li> <li>[Gradle Plugin] Provide a warning when the sqldelight plugin is applied but no databases are configured (#1421)</li> </ul>"},{"location":"changelog/#fixed_15","title":"Fixed","text":"<ul> <li>[Compiler] Report an error when binding a column name in an ORDER BY clause (#1187 by Eliezer Graber)</li> <li>[Compiler] Registry warnings appear when generating the db interface (#1792)</li> <li>[Compiler] Incorrect type inference for case statement (#1811)</li> <li>[Compiler] Provide better errors for migration files with no version (#2006)</li> <li>[Compiler] Required database type to marshal is incorrect for some database type ColumnAdapter's (#2012)</li> <li>[Compiler] Nullability of CAST (#1261)</li> <li>[Compiler] Lots of name shadowed warnings in query wrappers (#1946 by Eliezer Graber)</li> <li>[Compiler] Generated code is using full qualifier names (#1939)</li> <li>[IDE Plugin] Trigger sqldelight code gen from gradle syncs</li> <li>[IDE Plugin] Plugin not regenerating database interface when changing .sq files (#1945)</li> <li>[IDE Plugin] Issue when moving files to new packages (#444)</li> <li>[IDE Plugin] If theres nowhere to move the cursor, do nothing instead of crashing (#1994)</li> <li>[IDE Plugin] Use empty package name for files outside of a gradle project (#1973)</li> <li>[IDE Plugin] Fail gracefully for invalid types (#1943)</li> <li>[IDE Plugin] Throw a better error message when encountering an unknown expression (#1958)</li> <li>[Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998)</li> <li>[Gradle Plugin] \"JavadocIntegrationKt not found\" compilation error when adding method doc in *.sq file (#1982)</li> <li>[Gradle Plugin] SqlDeslight gradle plugin doesn't support Configuration Caching (CoCa). (#1947 by St\u00e9phane Nicolas)</li> <li>[SQLite JDBC Driver] SQLException: database in auto-commit mode (#1832)</li> <li>[Coroutines Extension] Fix IR backend for coroutines-extensions (#1918 by Derek Ellis)</li> </ul>"},{"location":"changelog/#143-2020-09-04","title":"[1.4.3] - 2020-09-04","text":""},{"location":"changelog/#added_17","title":"Added","text":"<ul> <li>[MySQL Dialect] Add support for MySQL last_insert_id function (by Kelvin Law)</li> <li>[PostgreSQL Dialect] Support SERIAL data type (by Veyndan Stuart &amp; Felipe Lima)</li> <li>[PostgreSQL Dialect] Support PostgreSQL RETURNING (by Veyndan Stuart)</li> </ul>"},{"location":"changelog/#fixed_16","title":"Fixed","text":"<ul> <li>[MySQL Dialect] Treat MySQL AUTO_INCREMENT as having a default value (#1823)</li> <li>[Compiler] Fix Upsert statement compiler error (#1809 by Eliezer Graber)</li> <li>[Compiler] Fix issue with invalid Kotlin being generated (#1925 by Eliezer Graber)</li> <li>[Compiler] Have a better error message for unknown functions (#1843)</li> <li>[Compiler] Expose string as the type for the second parameter of instr</li> <li>[IDE Plugin] Fix daemon bloat and UI thread stalling for IDE plugin (#1916)</li> <li>[IDE Plugin] Handle null module scenario (#1902)</li> <li>[IDE Plugin] In unconfigured sq files return empty string for the package name (#1920)</li> <li>[IDE Plugin] Fix grouped statements and add an integration test for them (#1820)</li> <li>[IDE Plugin] Use built in ModuleUtil to find the module for an element (#1854)</li> <li>[IDE Plugin] Only add valid elements to lookups (#1909)</li> <li>[IDE Plugin] Parent can be null (#1857)</li> </ul>"},{"location":"changelog/#142-2020-08-27","title":"[1.4.2] - 2020-08-27","text":""},{"location":"changelog/#added_18","title":"Added","text":"<ul> <li>[Runtime] Support new JS IR backend</li> <li>[Gradle Plugin] Add generateSqlDelightInterface Gradle task. (by Niklas Baudy)</li> <li>[Gradle Plugin] Add verifySqlDelightMigration Gradle task. (by Niklas Baudy)</li> </ul>"},{"location":"changelog/#fixed_17","title":"Fixed","text":"<ul> <li>[IDE Plugin] Use the gradle tooling API to facilitate data sharing between the IDE and gradle</li> <li>[IDE Plugin] Default to false for schema derivation</li> <li>[IDE Plugin] Properly retrieve the commonMain source set</li> <li>[MySQL Dialect] Added minute to mySqlFunctionType() (by MaaxGr)</li> </ul>"},{"location":"changelog/#141-2020-08-21","title":"[1.4.1] - 2020-08-21","text":""},{"location":"changelog/#added_19","title":"Added","text":"<ul> <li>[Runtime] Support Kotlin 1.4.0 (#1859)</li> </ul>"},{"location":"changelog/#changed_16","title":"Changed","text":"<ul> <li>[Gradle Plugin] Make AGP dependency compileOnly (#1362)</li> </ul>"},{"location":"changelog/#fixed_18","title":"Fixed","text":"<ul> <li>[Compiler] Add optional javadoc to column defintion rule and to table interface generator (#1224 by Daniel Eke)</li> <li>[SQLite Dialect] Add support for sqlite fts5 auxiliary functions highlight, snippet, and bm25 (by Daniel Rampelt)</li> <li>[MySQL Dialect] Support MySQL bit data type</li> <li>[MySQL Dialect] Support MySQL binary literals</li> <li>[PostgreSQL Dialect] Expose SERIAL from sql-psi (by Veyndan Stuart)</li> <li>[PostgreSQL Dialect] Add BOOLEAN data type (by Veyndan Stuart)</li> <li>[PostgreSQL Dialect] Add NULL column constraint (by Veyndan Stuart)</li> <li>[HSQL Dialect] Adds <code>AUTO_INCREMENT</code> support to HSQL (by Ryan Harter)</li> </ul>"},{"location":"changelog/#140-2020-06-22","title":"[1.4.0] - 2020-06-22","text":""},{"location":"changelog/#added_20","title":"Added","text":"<ul> <li>[MySQL Dialect] MySQL support (by Jeff Gulbronson &amp; Veyndan Stuart)</li> <li>[PostgreSQL Dialect] Experimental PostgreSQL support (by Veyndan Stuart)</li> <li>[HSQL Dialect] Experimental H2 support (by Marius Volkhart)</li> <li>[SQLite Dialect] SQLite FTS5 support (by Ben Asher &amp; James Palawaga)</li> <li>[SQLite Dialect] Support alter table rename column (#1505 by Angus Holder)</li> <li>[IDE] IDE support for migration (.sqm) files</li> <li>[IDE] Add SQLDelight Live Templates that mimic built-in SQL Live Templates (#1154 by Veyndan Stuart)</li> <li>[IDE] Add new SqlDelight file action (#42 by Roman Zavarnitsyn)</li> <li>[Runtime] transactionWithReturn API for transactions that return results</li> <li>[Compiler] Syntax for grouping multiple SQL statements together in a .sq file</li> <li>[Compiler] Support generating schemas from migration files</li> <li>[Gradle Plugin] Add a task for outputting migration files as valid sql</li> </ul>"},{"location":"changelog/#changed_17","title":"Changed","text":"<ul> <li>[Documentation] Overhaul of the documentation website (by Saket Narayan)</li> <li>[Gradle Plugin] Improve unsupported dialect error message (by Veyndan Stuart)</li> <li>[IDE] Dynamically change file icon based on dialect (by Veyndan Stuart)</li> <li>[JDBC Driver] Expose a JdbcDriver constructor off of javax.sql.DataSource (#1614)</li> </ul>"},{"location":"changelog/#fixed_19","title":"Fixed","text":"<ul> <li>[Compiler]Support Javadoc on tables and fix multiple javadoc in one file (#1224)</li> <li>[Compiler] Enable inserting a value for synthesized columns (#1351)</li> <li>[Compiler] Fix inconsistency in directory name sanitizing (by Zac Sweers)</li> <li>[Compiler] Synthesized columns should retain nullability across joins (#1656)</li> <li>[Compiler] Pin the delete statement on the delete keyword (#1643)</li> <li>[Compiler] Fix quoting (#1525 by Angus Holder)</li> <li>[Compiler] Fix the between operator to properly recurse into expressions (#1279)</li> <li>[Compiler] Give better error for missing table/column when creating an index (#1372)</li> <li>[Compiler] Enable using the outer querys projection in join constraints (#1346)</li> <li>[Native Driver] Make execute use transationPool (by Ben Asher)</li> <li>[JDBC Driver] Use the jdbc transaction APIs instead of sqlite (#1693)</li> <li>[IDE] Fix virtualFile references to always be the original file (#1782)</li> <li>[IDE] Use the correct throwable when reporting errors to bugsnag (#1262)</li> <li>[Paging Extension] Fix leaky DataSource (#1628)</li> <li>[Gradle Plugin] If the output db file already exists when generating a schema, delete it (#1645)</li> <li>[Gradle Plugin] Fail migration validation if there are gaps</li> <li>[Gradle Plugin] Explicitely use the file index we set (#1644)</li> </ul>"},{"location":"changelog/#130-2020-04-03","title":"[1.3.0] - 2020-04-03","text":"<ul> <li>New: [Gradle] Dialect property to specify with sql dialect to compile against.</li> <li>New: [Compiler] #1009 Experimental support of the mysql dialect.</li> <li>New: [Compiler] #1436 Support of sqlite:3.24 dialect and upsert.</li> <li>New: [JDBC Driver] Split out JDBC driver from sqlite jvm driver.</li> <li>Fix: [Compiler] #1199 Support lambdas of any length.</li> <li>Fix: [Compiler] #1610 Fix the return type of avg() to be nullable.</li> <li>Fix: [IntelliJ] #1594 Fix path separator handling which broke Goto and Find Usages on Windows.</li> </ul>"},{"location":"changelog/#122-2020-01-22","title":"[1.2.2] - 2020-01-22","text":"<ul> <li>New: [Runtime] Support for Windows (mingW), tvOS, watchOS, and macOS architectures.</li> <li>Fix: [Compiler] Return type of sum() should be nullable.</li> <li>Fix: [Paging] Pass Transacter into QueryDataSourceFactory to avoid race conditions.</li> <li>Fix: [IntelliJ Plugin] Don't search through dependencies when looking for a file's package name.</li> <li>Fix: [Gradle] #862 Change validator logs in Gradle to debug level.</li> <li>Enhancement: [Gradle] Convert GenerateSchemaTask to use Gradle worker.</li> <li>Note: sqldelight-runtime artifact renamed to runtime.</li> </ul>"},{"location":"changelog/#121-2019-12-11","title":"[1.2.1] - 2019-12-11","text":"<ul> <li>Fix: [Gradle] Kotlin Native 1.3.60 support.</li> <li>Fix: [Gradle] #1287 Warning when syncing.</li> <li>Fix: [Compiler] #1469 SynetheticAccessor creation for query.</li> <li>Fix: [JVM Driver] Fixed memory leak.</li> <li>NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript.</li> </ul>"},{"location":"changelog/#120-2019-08-30","title":"[1.2.0] - 2019-08-30","text":"<ul> <li>New: [Runtime] Stable Flow api.</li> <li>Fix: [Gradle] Kotlin Native 1.3.50 support.</li> <li>Fix: [Gradle] #1380 Clean build sometimes fails.</li> <li>Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\".</li> <li>Fix: [Compile] #1405 Can't build project if query contains FTS table joined.</li> <li>Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules.</li> </ul>"},{"location":"changelog/#114-2019-07-11","title":"[1.1.4] - 2019-07-11","text":"<ul> <li>New: [Runtime] Experimental kotlin Flow api.</li> <li>Fix: [Gradle] Kotlin/Native 1.3.40 compatibility.</li> <li>Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand.</li> <li>Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing.</li> <li>Fix: [Gradle] Allow gradle tasks to cache.</li> <li>Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl.</li> <li>Fix: [Compiler] Unique ids are generated for each query deterministically.</li> <li>Fix: [Compiler] Only notify listening queries when a transaction is complete.</li> <li>Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL.</li> </ul>"},{"location":"changelog/#113-2019-04-14","title":"[1.1.3] - 2019-04-14","text":"<ul> <li>Gradle Metadata 1.0 release.</li> </ul>"},{"location":"changelog/#112-2019-04-14","title":"[1.1.2] - 2019-04-14","text":"<ul> <li>New: [Runtime] #1267 Logging driver decorator.</li> <li>Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters.</li> <li>Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project.</li> <li>Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43.</li> <li>Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions.</li> </ul>"},{"location":"changelog/#111-2019-03-01","title":"[1.1.1] - 2019-03-01","text":"<ul> <li>Fix: [Gradle] Fix module dependency compilation for android projects.</li> <li>Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate.</li> <li>Fix: [Compiler] Array types are properly printed.</li> </ul>"},{"location":"changelog/#110-2019-02-27","title":"[1.1.0] - 2019-02-27","text":"<ul> <li>New: [Gradle] #502 Allow specifying schema module dependencies.</li> <li>Enhancement: [Compiler] #1111 Table errors are sorted before other errors.</li> <li>Fix: [Compiler] #1225 Return the correct type for REAL literals.</li> <li>Fix: [Compiler] #1218 docid propagates through triggers.</li> </ul>"},{"location":"changelog/#103-2019-01-30","title":"[1.0.3] - 2019-01-30","text":"<ul> <li>Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32.</li> <li>Enhancement: [Runtime] #1190 Expose the mapper from the Query type.</li> </ul>"},{"location":"changelog/#102-2019-01-26","title":"[1.0.2] - 2019-01-26","text":"<ul> <li>Fix: [Gradle Plugin] Update to kotlin 1.3.20.</li> <li>Fix: [Runtime] Transactions no longer swallow exceptions.</li> </ul>"},{"location":"changelog/#101-2019-01-21","title":"[1.0.1] - 2019-01-21","text":"<ul> <li>Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration.</li> <li>Enhancement: [Compiler] #1173 Files without a package fail compilation.</li> <li>Fix: [IDE] Properly report IDE errors to Square.</li> <li>Fix: [IDE] #1162 Types in the same package show as error but work fine.</li> <li>Fix: [IDE] #1166 Renaming a table fails with NPE.</li> <li>Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT.</li> </ul>"},{"location":"changelog/#100-2019-01-08","title":"[1.0.0] - 2019-01-08","text":"<ul> <li>New: Complete overhaul of generated code, now in kotlin.</li> <li>New: RxJava2 extensions artifact.</li> <li>New: Android Paging extensions artifact.</li> <li>New: Kotlin Multiplatform support.</li> <li>New: Android, iOS and JVM SQLite driver artifacts.</li> <li>New: Transaction API.</li> </ul>"},{"location":"changelog/#070-2018-02-12","title":"[0.7.0] - 2018-02-12","text":"<ul> <li>New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings.</li> <li>New: Statement folding in the IDE.</li> <li>New: Boolean types are now automatically handled.</li> <li>Fix: Remove deprecated marshals from code generation.</li> <li>Fix: Correct 'avg' SQL function type mapping to be REAL.</li> <li>Fix: Correctly detect 'julianday' SQL function.</li> </ul>"},{"location":"changelog/#061-2017-03-22","title":"[0.6.1] - 2017-03-22","text":"<ul> <li>New: Delete Update and Insert statements without arguments get compiled statements generated.</li> <li>Fix: Using clause within a view used in a subquery doesn't error.</li> <li>Fix: Duplicate types on generated Mapper removed.</li> <li>Fix: Subqueries can be used in expressions that check against arguments.</li> </ul>"},{"location":"changelog/#060-2017-03-06","title":"[0.6.0] - 2017-03-06","text":"<ul> <li>New: Select queries are now exposed as a <code>SqlDelightStatement</code> factory instead of string constants.</li> <li>New: Query JavaDoc is now copied to statement and mapper factories.</li> <li>New: Emit string constants for view names.</li> <li>Fix: Queries on views which require factories now correctly require those factories are arguments.</li> <li>Fix: Validate the number of arguments to an insert matches the number of columns specified.</li> <li>Fix: Properly encode blob literals used in where clauses.</li> <li>Gradle 3.3 or newer is required for this release.</li> </ul>"},{"location":"changelog/#051-2016-10-24","title":"[0.5.1] - 2016-10-24","text":"<ul> <li>New: Compiled statements extend an abstract type.</li> <li>Fix: Primitive types in parameters will be boxed if nullable.</li> <li>Fix: All required factories for bind args are present in factory method.</li> <li>Fix: Escaped column names are marshalled correctly.</li> </ul>"},{"location":"changelog/#050-2016-10-19","title":"[0.5.0] - 2016-10-19","text":"<ul> <li>New: SQLite arguments can be passed typesafely through the Factory</li> <li>New: IntelliJ plugin performs formatting on .sq files</li> <li>New: Support for SQLite timestamp literals</li> <li>Fix: Parameterized types can be clicked through in IntelliJ</li> <li>Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor.</li> <li>Fix: Gradle plugin doesn't crash trying to print exceptions.</li> </ul>"},{"location":"changelog/#044-2016-07-20","title":"[0.4.4] - 2016-07-20","text":"<ul> <li>New: Native support for shorts as column java type</li> <li>New: Javadoc on generated mappers and factory methods</li> <li>Fix: group_concat and nullif functions have proper nullability</li> <li>Fix: Compatibility with Android Studio 2.2-alpha</li> <li>Fix: WITH RECURSIVE no longer crashes plugin</li> </ul>"},{"location":"changelog/#043-2016-07-07","title":"[0.4.3] - 2016-07-07","text":"<ul> <li>New: Compilation errors link to source file.</li> <li>New: Right-click to copy SQLDelight code as valid SQLite.</li> <li>New: Javadoc on named statements will appear on generated Strings.</li> <li>Fix: Generated view models include nullability annotations.</li> <li>Fix: Generated code from unions has proper type and nullability to support all possible columns.</li> <li>Fix: sum and round SQLite functions have proper type in generated code.</li> <li>Fix: CAST's, inner selects bugfixes.</li> <li>Fix: Autocomplete in CREATE TABLE statements.</li> <li>Fix: SQLite keywords can be used in packages.</li> </ul>"},{"location":"changelog/#042-2016-06-16","title":"[0.4.2] - 2016-06-16","text":"<ul> <li>New: Marshal can be created from the factory.</li> <li>Fix: IntelliJ plugin generates factory methods with proper generic order.</li> <li>Fix: Function names can use any casing.</li> </ul>"},{"location":"changelog/#041-2016-06-14","title":"[0.4.1] - 2016-06-14","text":"<ul> <li>Fix: IntelliJ plugin generates classes with proper generic order.</li> <li>Fix: Column definitions can use any casing.</li> </ul>"},{"location":"changelog/#040-2016-06-14","title":"[0.4.0] - 2016-06-14","text":"<ul> <li>New: Mappers are generated per query instead of per table.</li> <li>New: Java types can be imported in .sq files.</li> <li>New: SQLite functions are validated.</li> <li>Fix: Remove duplicate errors.</li> <li>Fix: Uppercase column names and java keyword column names do not error.</li> </ul>"},{"location":"changelog/#032-2016-05-14","title":"[0.3.2] - 2016-05-14","text":"<ul> <li>New: Autocompletion and find usages now work for views and aliases.</li> <li>Fix: Compile-time validation now allows functions to be used in selects.</li> <li>Fix: Support insert statements which only declare default values.</li> <li>Fix: Plugin no longer crashes when a project not using SQLDelight is imported.</li> </ul>"},{"location":"changelog/#031-2016-04-27","title":"[0.3.1] - 2016-04-27","text":"<ul> <li>Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references.</li> <li>Fix: Subexpressions are evaluated properly.</li> </ul>"},{"location":"changelog/#030-2016-04-26","title":"[0.3.0] - 2016-04-26","text":"<ul> <li>New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type.</li> <li>New: Bug reports can be sent from the IDE.</li> <li>Fix: Autocomplete functions properly.</li> <li>Fix: SQLDelight model files update on .sq file edit.</li> <li>Removed: Attached databases no longer supported.</li> </ul>"},{"location":"changelog/#022-2016-03-07","title":"[0.2.2] - 2016-03-07","text":"<ul> <li>New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements.</li> <li>Fix: Don't crash IDE plugin on file move/create.</li> </ul>"},{"location":"changelog/#021-2016-03-07","title":"[0.2.1] - 2016-03-07","text":"<ul> <li>New: Ctrl+<code>/</code> (Cmd+<code>/</code> on OSX) toggles comment of the selected line(s).</li> <li>New: Compile-time validation of the columns used by SQL queries.</li> <li>Fix: Support Windows paths in both the IDE and Gradle plugin.</li> </ul>"},{"location":"changelog/#020-2016-02-29","title":"[0.2.0] - 2016-02-29","text":"<ul> <li>New: Added copy constructor to Marshal class.</li> <li>New: Update to Kotlin 1.0 final.</li> <li>Fix: Report 'sqldelight' folder structure problems in a non-failing way.</li> <li>Fix: Forbid columns named <code>table_name</code>. Their generated constant clashes with the table name constant.</li> <li>Fix: Ensure IDE plugin generates model classes immediately and regardless of whether <code>.sq</code> files were opened.</li> <li>Fix: Support Windows paths in both the IDE and Gradle plugin.</li> </ul>"},{"location":"changelog/#012-2016-02-13","title":"[0.1.2] - 2016-02-13","text":"<ul> <li>Fix: Remove code which prevented the Gradle plugin from being used in most projects.</li> <li>Fix: Add missing compiler dependency on the Antlr runtime.</li> </ul>"},{"location":"changelog/#011-2016-02-12","title":"[0.1.1] - 2016-02-12","text":"<ul> <li>Fix: Ensure the Gradle plugin points to the same version of the runtime as itself.</li> </ul>"},{"location":"changelog/#010-2016-02-12","title":"[0.1.0] - 2016-02-12","text":"<p>Initial release.</p>"},{"location":"code_of_conduct/","title":"Open Source Code of Conduct","text":"<p>At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone.</p> <p>This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored.</p> <p>Square\u2019s open source community strives to:</p> <ul> <li> <p>Be open: We invite anyone to participate in any aspect of our projects. Our community is    open, and any responsibility can be carried by a contributor who demonstrates the required    capacity and competence.</p> </li> <li> <p>Be considerate: People use our work, and we depend on the work of others. Consider users and    colleagues before taking action. For example, changes to code, infrastructure, policy, and    documentation may negatively impact others.</p> </li> <li> <p>Be respectful: We expect people to work together to resolve conflict, assume good intentions,    and act with empathy. Do not turn disagreements into personal attacks.</p> </li> <li> <p>Be collaborative: Collaboration reduces redundancy and improves the quality of our work. We    strive for transparency within our open source community, and we work closely with upstream    developers and others in the free software community to coordinate our efforts.</p> </li> <li> <p>Be pragmatic: Questions are encouraged and should be asked early in the process to avoid    problems later. Be thoughtful and considerate when seeking out the appropriate forum for your    questions. Those who are asked should be responsive and helpful.</p> </li> <li> <p>Step down considerately: Members of every project come and go. When somebody leaves or    disengages from the project, they should make it known and take the proper steps to ensure that    others can pick up where they left off.</p> </li> </ul> <p>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.</p>"},{"location":"code_of_conduct/#diversity-statement","title":"Diversity Statement","text":"<p>We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal.</p> <p>Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong.</p> <p>Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.</p>"},{"location":"code_of_conduct/#reporting-issues","title":"Reporting Issues","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. For more details, please see our Reporting Guidelines below.</p>"},{"location":"code_of_conduct/#thanks","title":"Thanks","text":"<p>Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter, Ubuntu, GDC, and Django communities. We are thankful for their work.</p>"},{"location":"code_of_conduct/#reporting-guide","title":"Reporting Guide","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. All reports will be handled with discretion.</p> <p>In your report please include:</p> <ul> <li>Your contact information.</li> <li>Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional    witnesses, please include them as well.</li> <li>Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly    available record (e.g. a mailing list archive or a public IRC logger), please include a link.</li> <li>Any additional information that may be helpful.</li> </ul> <p>After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond.</p> <p>Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request.</p> <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.</p> <p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>"},{"location":"contributing/#sqldelight","title":"SQLDelight","text":"<p>If you're looking to get started with contributing, look below for specific guides depending on which part of SQLDelight you'd like to contribute to. If you're still unsure, comment in the issue you're looking in to with where you're getting stuck and we'll respond there - or create an issue for the thing you're trying to do and start the discussion.</p>"},{"location":"contributing/#ide-plugin","title":"IDE Plugin","text":"<p>If you want to fix a bug or extend the IDE, code changes will likely happen in the <code>sqldelight-idea-plugin</code> module. You can test your changes using the <code>./gradlew runIde</code> task and you can live debug using <code>./gradlew runIde --debug-jvm</code>.</p> <p>If you're encountering a bug in the IDE but cannot reproduce it in a sample project, you can live debug your IDE. You'll need a second installation of IntelliJ to do this. You can use Toolbox to do this by scrolling to the bottom of the IDE list and selecting a different version of IntelliJ.</p> <p>In the IDE you'd like to use the debugger in, check out the SQLDelight repo and then create a new <code>Remote</code> Run Configuration. It will already populate \"Command line arguments for remote JVM\", something like <code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code>. Copy that value, then open the IDE you would like to debug. Select <code>Help -&gt; Edit Custom VM Options</code>, and paste the line you copied to the bottom of the file that is opened. Restart the IDE you want to debug, then once it's started up open the IDE you created the configuration in, and attach the debugger using the remote configuration you created.</p> <p>For more information on building IDE plugins and features for them see the Official Jetbrains Documentation or join the Jetbrains Platform Slack.</p>"},{"location":"contributing/#drivers","title":"Drivers","text":"<p>If you're interested in creating your own driver, you can do so outside of the SQLDelight repository using the <code>runtime</code> artifact. To test the driver you can depend on the <code>driver-test</code> and extend <code>DriverTest</code> and <code>TransactionTest</code> to ensure it works as SQLDelight would expect.</p>"},{"location":"contributing/#asynchronous-drivers","title":"Asynchronous Drivers","text":"<p>Drivers that make asynchronous calls can be implemented by using the <code>runtime-async</code> artifact. </p>"},{"location":"contributing/#gradle","title":"Gradle","text":"<p>If you're encountering a gradle issue, start by creating a test fixture in <code>sqldelight-gradle-plugin/src/test</code> similar to the other folders there which reproduces your issue. Feel free to just open a PR with this failing test if you don't know how to fix! Test cases are greatly appreciated. The integration tests show how to set up an entire gradle project which will run SQLite/MySQL/PostgreSQL/etc and execute SQL queries using their respective runtime environments and SQLDelight. Consider adding a test to these already existing integration tests if you're encountering runtime issues in SQLDelight.</p>"},{"location":"contributing/#compiler","title":"Compiler","text":"<p>There are many layers to SQLDelight's compiler - if you are strictly interested in the codegen (and not the parsing of SQL) then you will want to make your contributions in the <code>sqldelight-compiler</code> module. If you are interested in the parser you'll need to contribute to sql-psi. SQLDelight uses kotlinpoet for generating kotlin code, be sure to use it's APIs for referencing kotlin types so imports still work correctly. If you modify the codegen in any way, run a <code>./gradlew build</code> before opening a pull request, as it will update the integration test in <code>sqldelight-compiler:integration-tests</code>. If you'd like to write an integration test (meaning running SQL queries in a runtime environment), add a test to <code>sqldelight-compiler:integration-tests</code>.</p>"},{"location":"contributing/#sql-psi","title":"SQL PSI","text":"<p>In the next section we will go through how to contribute to the parser and PSI layer, but before doing that you should read a blog post on multiple dialects to understand the various moving pieces in sql-psi. As with SQLDelight, if you're encountering an issue but don't know how to contribute a fix or need assistance, comment in the GitHub issue or create a new one to start the discussion.</p> <p>For any changes in SQL-PSI, you will want to add a test fixture in the corresponding <code>core/src/test/fixtures_*</code> folder. The <code>fixtures</code> folder (no suffix) runs for all dialects. After your change has been merged to sql-psi, if there are changes you also need to make in SQLDelight, check out the  <code>sql-psi-dev</code> branch on SQLDelight and target it with your PR. It uses the snapshot releases of sql-psi so you can build your SQLDelight change roughly 10 minutes after the sql-psi change has been merged.</p>"},{"location":"contributing/#grammar","title":"Grammar","text":"<p>If you are adding to the grammar, first decide if this is a new rule you are adding to an existing grammar, or a rule you would like to override from ANSI SQL (which is found in sql.bnf). In both cases, you will want to define that rule in your new grammar, but in the case of overriding an ANSI SQL rule, add it to the overrides list and set the override attribute on the rule:</p> <pre><code>overrides ::= my_rule\n\nmy_rule ::= SOME_TOKEN {\n  override = true\n}\n</code></pre> <p>The definition of your rule should start by being an exact copy/paste of the rule from ANSI-SQL. To reference rules from ANSI-SQL, you need to surround it in {}, so you should surround all external rules in your overriding rule with {}:</p> <pre><code>my_rule ::= internal_rule {external_rule} {\n  override = true\n}\ninternal_rule ::= SOME_TOKEN\n</code></pre> <p>One caveat is that referencing the <code>expr</code> rule from ANSI-SQL should look like <code>&lt;&lt;expr '-1'&gt;&gt;</code> because it is special and cannot be overridden.</p> <p>Any tokens that you want to use from ANSI SQL should also be manually imported:</p> <pre><code>{\n  parserImports = [\n    \"static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE\"\n    \"static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM\"\n  ]\n}\noverrides ::= delete\n\ndelete ::= DELETE FROM {table_name} {\n  override = true\n}\n</code></pre> <p>Dialects cannot add their own tokens, but you can require exact text by surrounding it with \"\":</p> <pre><code>my_rule ::= \"SOME_TOKEN\"\n</code></pre> <p>Overriding rules must still generate code which confirms to the original rules types, so make sure to <code>implement</code> and <code>extend</code> the existing types for the original rule:</p> <pre><code>my_rule ::= internal_rule {external_rule} {\n  extends = \"com.alecstrong.sql.psi.core.psi.impl.SqlMyRuleImpl\"\n  implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\"\n  overrides = true\n}\n</code></pre> <p>To see an example of overriding rules in the grammar, check out this pr which adds <code>RETURNING</code> syntax to PostgreSQL.</p>"},{"location":"contributing/#rule-behavior","title":"Rule Behavior","text":"<p>Often times you want to modify the behavior of the PSI layer (for example throwing errors for situations you want to fail compilation for). To do this, have your rule use a <code>mixin</code> instead of an <code>extends</code> which is a class you write containing that new logic:</p> <pre><code>my_rule ::= interal_rule {external_rule} {\n  mixin = \"com.alecstrong.sql.psi.MyRuleMixin\"\n  implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\"\n  overrides = true\n}\n</code></pre> <p>And then in that class ensure that it implements the original ANSI SQL type and the SQL-PSI base class <code>SqlCompositeElementImpl</code>:</p> <pre><code>class MyRule(\n  node: ASTNode\n) : SqlCompositeElementImpl(node),\n    SqlMyRule {\n  fun annotate(annotationHolder: SqlAnnotationHolder) {\n    if (internal_rule.text == \"bad_text\") {\n      annotationHolder.createErrorAnnotation(\"Invalid text value\", internal_rule)\n    }\n  }\n}\n</code></pre> <p>For example, the DropIndexMixin verifies the index being dropped exists in the schema.</p> <p>If you have a question about contributing not covered in this doc please feel free to open an issue on SqlDelight or open a PR so we can work on improving it!</p>"},{"location":"upgrading-2.0/","title":"Upgrading to 2.0","text":"<p>SQLDelight 2.0 makes some breaking changes to the gradle plugin and runtime APIs.</p> <p>This page lists those breaking changes and their new 2.0 equivalents. For a full list of new features and other changes, see the changelog.</p>"},{"location":"upgrading-2.0/#new-package-name-and-artifact-group","title":"New Package Name and Artifact Group","text":"<p>All instances of <code>com.squareup.sqldelight</code> need to be replaced with <code>app.cash.sqldelight</code>.</p> Gradle Dependencies<pre><code>plugins {\n-  id(\"com.squareup.sqldelight\") version \"2.2.0-SNAPSHOT\"\n+  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\ndependencies {\n-  implementation(\"com.squareup.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\")\n+  implementation(\"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\")\n}\n\nFor pure-Android SqlDelight 1.x projects, use android-driver and coroutine-extensions-jvm:\ndependencies {\n-  implementation(\"com.squareup.sqldelight:android-driver:2.2.0-SNAPSHOT\")\n+  implementation(\"app.cash.sqldelight:android-driver:2.2.0-SNAPSHOT\")\n-  implementation(\"com.squareup.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n+  implementation(\"app.cash.sqldelight:coroutines-extensions-jvm:2.2.0-SNAPSHOT\")\n}\n</code></pre> In Code<pre><code>-import com.squareup.sqldelight.db.SqlDriver\n+import app.cash.sqldelight.db.SqlDriver\n</code></pre>"},{"location":"upgrading-2.0/#gradle-configuration-changes","title":"Gradle Configuration Changes","text":"<ul> <li>SQLDelight 2.0 requires Java 11 for building, and Java 8 for the runtime.</li> <li> <p>The SQLDelight configuration API now uses managed properties and a <code>DomainObjectCollection</code> for the databases.</p> KotlinGroovy <pre><code>sqldelight {\n  databases { // (1)!\n    create(\"Database\") {\n      packageName.set(\"com.example\") // (2)!\n    }\n  }\n}\n</code></pre> <ol> <li>New <code>DomainObjectCollection</code> wrapper.</li> <li>Now a <code>Property&lt;String&gt;</code>.</li> </ol> <pre><code>sqldelight {\n  databases { // (1)!\n    Database {\n      packageName = \"com.example\"\n    }\n  }\n}\n</code></pre> <ol> <li>New <code>DomainObjectCollection</code> wrapper.</li> </ol> </li> <li> <p>The sourceFolders setting has been renamed srcDirs</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example\")\n      srcDirs.setFrom(\"src/main/sqldelight\")\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example\"\n      srcDirs = ['src/main/sqldelight']\n    }\n  }\n}\n</code></pre> </li> <li> <p>The SQL dialect of your database is now specified using a Gradle dependency.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example\")\n      dialect(\"app.cash.sqldelight:mysql-dialect:2.2.0-SNAPSHOT\")\n\n      // Version catalogs also work!\n      dialect(libs.sqldelight.dialects.mysql)\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example\"\n      dialect \"app.cash.sqldelight:mysql-dialect:2.2.0-SNAPSHOT\"\n\n      // Version catalogs also work!\n      dialect libs.sqldelight.dialects.mysql\n    }\n  }\n}\n</code></pre> <p>The currently supported dialects are <code>mysql-dialect</code>, <code>postgresql-dialect</code>, <code>hsql-dialect</code>, <code>sqlite-3-18-dialect</code>, <code>sqlite-3-24-dialect</code>, <code>sqlite-3-25-dialect</code>, <code>sqlite-3-30-dialect</code>, <code>sqlite-3-35-dialect</code>, and <code>sqlite-3-38-dialect</code></p> </li> </ul>"},{"location":"upgrading-2.0/#runtime-changes","title":"Runtime Changes","text":"<ul> <li> <p>Primitive types must now be imported into <code>.sq</code> and <code>.sqm</code> files.</p> <pre><code>+import kotlin.Boolean;\n\nCREATE TABLE HockeyPlayer (\n  name TEXT NOT NULL,\n  good INTEGER AS Boolean\n);\n</code></pre> <p>Some previously supported types now require an adapter. Adapters for primitive types are available in the <code>app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT</code> artifact. e.g. The <code>IntColumnAdapter</code> for doing <code>INTEGER As kotlin.Int</code> conversions.</p> </li> <li> <p>The <code>AfterVersionWithDriver</code> type was removed in favour of <code>AfterVersion</code> which now always includes the driver, and the <code>migrateWithCallbacks</code> extension function was removed in favour of the main <code>migrate</code> method that now accepts callbacks.</p> <pre><code>Database.Schema.migrateWithCallbacks(\n  driver = driver,\n  oldVersion = 1,\n  newVersion = Database.Schema.version,\n-  AfterVersionWithDriver(3) { driver -&gt;\n-    driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0)\n-  }\n+  AfterVersion(3) { driver -&gt;\n+    driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0)\n+  }\n)\n</code></pre> </li> <li> <p>The <code>Schema</code> type is no longer a nested type of <code>SqlDriver</code>, and is now called <code>SqlSchema</code>.</p> <pre><code>-val schema: SqlDriver.Schema\n+val schema: SqlSchema\n</code></pre> </li> <li> <p>The paging3 extension API has changed to only allow int types for the count.</p> </li> <li>The coroutines extension API now requires a dispatcher to be explicitly passed in.     <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; =\n  playerQueries.selectAll()\n    .asFlow()\n+   .mapToList(Dispatchers.IO)\n</code></pre></li> <li>Some driver methods like <code>execute()</code>, <code>executeQuery()</code>, <code>newTransaction()</code>, and <code>endTransaction()</code> now return a <code>QueryResult</code> object. Use <code>QueryResult.value</code> to access the returned value.     <pre><code>-driver.executeQuery(null, \"PRAGMA user_version\", { /*...*/ })\n+driver.executeQuery(null, \"PRAGMA user_version\", { /*...*/ }).value\n</code></pre>     This change enables driver implementations to be based on non-blocking APIs where the returned value can be accessed using the suspending <code>QueryResult.await()</code> method.</li> <li>The <code>next()</code> method on the <code>SqlCursor</code> interface has also been changed to return a <code>QueryResult</code> to enable better cursor support for asynchronous drivers.</li> <li>The <code>SqlSchema</code> interface now has a generic <code>QueryResult</code> type parameter. This is used to distinguish schema runtimes that were generated for use with asynchronous drivers, which may not be directly compatible with synchronous drivers.   This is only relevant for projects that are simultaneously using synchronous and asynchronous drivers together, like in a multiplatform project that has a JS target. See \"Multiplatform setup with the Web Worker Driver\" for more details.</li> <li>The type of <code>SqlSchema.Version</code> changed from Int to Long to allow for server environments to leverage timestamps as version. Existing setups can safely cast between from Int and Long, and drivers that require an Int range for versions will crash before database creation for out of bounds versions.</li> </ul>"},{"location":"android_sqlite/","title":"Getting Started with SQLite on Android","text":"<p>First apply the gradle plugin in your project.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n    }\n  }\n}\n</code></pre> <p>Tip</p> <p>It's recommended to switch Android Studio to use the \"Project\" view instead of the \"Android\"  view of your files, to make it easier to find and edit SQLDelight files.</p>"},{"location":"android_sqlite/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p> <p>To use the generated database in your code, you must add the SQLDelight Android driver dependency to  your project.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:android-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:android-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>An instance of the driver can be constructed as shown below, and requires a reference to the generated <code>Schema</code> object. <pre><code>val driver: SqlDriver = AndroidSqliteDriver(Database.Schema, context, \"test.db\")\n</code></pre></p> <p>Info</p> <p>The <code>AndroidSqliteDriver</code> will automatically create or migrate your schema when the driver is constructed. Migrations can also be executed manually if needed. See Code Migrations for more</p>"},{"location":"android_sqlite/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"android_sqlite/#sqlite-versions","title":"SQLite Versions","text":"<p>For Android projects, the SQLDelight Gradle plugin will automatically select the SQLite dialect  version based on your project's <code>minSdkVersion</code> setting. See here for  the list of supported SQLite versions on each Android SDK level.</p>"},{"location":"android_sqlite/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"android_sqlite/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"android_sqlite/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"android_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"android_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, add the coroutines extensions artifact as a dependency and use the extension functions it provides:</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"android_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"android_sqlite/foreign_keys/","title":"Foreign Keys","text":"<p>You can enable foreign key constraints for the Android SQLite driver through the driver's <code>onOpen</code> callback.</p> <pre><code>AndroidSqliteDriver(\n  schema = Database.Schema,\n  callback = object : AndroidSqliteDriver.Callback(Database.Schema) {\n    override fun onOpen(db: SupportSQLiteDatabase) {\n      db.setForeignKeyConstraintsEnabled(true)\n    }\n  }\n)\n</code></pre>"},{"location":"android_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"android_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"android_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"android_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"android_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"android_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"android_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"android_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"android_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"android_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"android_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"android_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"android_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"android_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"android_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"android_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"android_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"android_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"android_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"android_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"android_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>A <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>check</code> task. For any <code>.db</code> file named <code>&lt;version number&gt;.db</code> in your SqlDelight source set (e.g. <code>src/main/sqldelight</code>) it will apply all migrations starting from <code>&lt;version number&gt;.sqm</code>, and confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generate&lt;source set name&gt;&lt;database name&gt;Schema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration. For example, if your project uses the <code>main</code> source set with a custom name of <code>\"MyDatabase\"</code>, you'll need to run the <code>generateMainMyDatabaseSchema</code> task.</p> <p>Most use cases would benefit from only having a <code>1.db</code> file representing the schema of the initial version of their database. Having multiple <code>.db</code> files is allowed, but that would result in each <code>.db</code> file having each of its migrations applied to it, which causes a lot of unnecessary work.</p>"},{"location":"android_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\n    driver = database,\n    oldVersion = 0,\n    newVersion = Database.Schema.version,\n    AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p> <p>If you are using an <code>AndroidSqliteDriver</code> you can pass these callbacks in during the driver's creation:</p> <pre><code>val driver: SqlDriver = AndroidSqliteDriver(\n    schema = Database.Schema,\n    context = context,\n    name = \"test.db\",\n    callback = AndroidSqliteDriver.Callback(\n        schema = Database.Schema,\n        AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n    )\n)\n</code></pre>"},{"location":"android_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"android_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"android_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"android_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"android_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"android_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"android_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"android_sqlite/resources/","title":"Other Resources","text":""},{"location":"android_sqlite/resources/#guides","title":"Guides","text":"<ul> <li>SQLDelight 1.x Quickstart Guide for Android</li> </ul>"},{"location":"android_sqlite/rxjava/","title":"RxJava","text":"<p>To observe a query, depend on the RxJava extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:rxjava3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:rxjava3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Observable&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asObservable()\n    .mapToList()\n</code></pre> <p>Note: For RxJava 2, use <code>rxjava2-extensions</code> as the artifact name.</p>"},{"location":"android_sqlite/testing/","title":"Testing","text":"<p>In some tests (like verification of migrations) you might wish to swap out the Android driver with the JVM driver, enabling you to test code involving the database without needing an Android emulator or physical device. To do that use the jvm SQLite driver:</p> KotlinGroovy <pre><code>dependencies {\n  testImplementation(\"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  testImplementation \"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>// When your test needs a driver\n@Before fun before() {\n  driver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)\n  Database.Schema.create(driver)\n}\n</code></pre> <p>If you are using the SQLite that comes bundled with Android (rather than shipping your own), you can override the version of sqlite-jdbc to one that matches your Android minSdkVersion, for example for API 23 use SQLite 3.8.10.2:</p> <pre><code>dependencies {\n  testImplementation('org.xerial:sqlite-jdbc') {\n    // Override the version of sqlite used by sqlite-driver to match Android API 23\n    version { strictly('3.8.10.2') }\n  }\n}\n</code></pre>"},{"location":"android_sqlite/transactions/","title":"Transactions","text":""},{"location":"android_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"android_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"android_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"android_sqlite/types/","title":"Types","text":""},{"location":"android_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\n  some_double REAL,            -- Stored as REAL in db, retrieved as Double\n  some_string TEXT,            -- Stored as TEXT in db, retrieved as String\n  some_blob BLOB               -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"android_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"android_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"android_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"android_sqlite/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"common/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"common/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"common/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"common/androidx_paging_multiplatform/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact. Multiplatform support for AndroidX Paging is provided via Multiplatform Paging.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"common/androidx_paging_multiplatform/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"common/androidx_paging_multiplatform/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"common/androidx_paging_usage/","title":"Androidx paging usage","text":"<p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"common/androidx_paging_usage/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"common/androidx_paging_usage/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"common/coroutines-multiplatform/","title":"Coroutines multiplatform","text":""},{"location":"common/coroutines-multiplatform/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"common/coroutines-usage/","title":"Coroutines usage","text":"<pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"common/coroutines/","title":"Coroutines","text":""},{"location":"common/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, add the coroutines extensions artifact as a dependency and use the extension functions it provides:</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"common/custom_column_types/","title":"Custom column types","text":""},{"location":"common/custom_column_types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"common/custom_column_types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"common/custom_column_types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"common/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"common/gradle-dependencies/","title":"Gradle dependencies","text":""},{"location":"common/gradle-dependencies/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"common/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"common/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"common/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"common/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"common/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"common/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"common/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"common/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"common/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"common/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"common/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"common/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"common/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"common/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"common/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"common/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"common/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"common/index_gradle_database/","title":"Index gradle database","text":"<p>First apply the gradle plugin in your project.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n    }\n  }\n}\n</code></pre>"},{"location":"common/index_queries/","title":"Index queries","text":""},{"location":"common/index_queries/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"common/index_schema/","title":"Index schema","text":""},{"location":"common/index_schema/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p>"},{"location":"common/index_schema_sq/","title":"Index schema sq","text":""},{"location":"common/index_schema_sq/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre>"},{"location":"common/index_server/","title":"Index server","text":"<p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"common/index_server/#fresh-schema","title":"Fresh Schema","text":""},{"location":"common/index_server/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"common/index_server/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"Database\") {\n      ...\n      srcDirs(\"sqldelight\")\n      deriveSchemaFromMigrations.set(true)\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    Database {\n      ...\n      srcDirs \"sqldelight\"\n      deriveSchemaFromMigrations = true\n    }\n  }\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"common/index_server/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p>"},{"location":"common/index_server/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"common/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"common/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"common/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"common/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>A <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>check</code> task. For any <code>.db</code> file named <code>&lt;version number&gt;.db</code> in your SqlDelight source set (e.g. <code>src/main/sqldelight</code>) it will apply all migrations starting from <code>&lt;version number&gt;.sqm</code>, and confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generate&lt;source set name&gt;&lt;database name&gt;Schema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration. For example, if your project uses the <code>main</code> source set with a custom name of <code>\"MyDatabase\"</code>, you'll need to run the <code>generateMainMyDatabaseSchema</code> task.</p> <p>Most use cases would benefit from only having a <code>1.db</code> file representing the schema of the initial version of their database. Having multiple <code>.db</code> files is allowed, but that would result in each <code>.db</code> file having each of its migrations applied to it, which causes a lot of unnecessary work.</p>"},{"location":"common/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\n    driver = database,\n    oldVersion = 0,\n    newVersion = Database.Schema.version,\n    AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"common/migrations_server/","title":"Migrations server","text":""},{"location":"common/migrations_server/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\n  databases {\n    Database {\n      migrationOutputDirectory = layout.buildDirectory.dir(\"resources/main/migrations\")\n      migrationOutputFileFormat = \".sql\" // Defaults to .sql\n  }\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\n  dependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"common/multiplatform/","title":"Multiplatform","text":"<p>To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into.</p> <pre><code>apply plugin: \"org.jetbrains.kotlin.multiplatform\"\napply plugin: \"app.cash.sqldelight\"\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.hockey\"\n    }\n  }\n}\n</code></pre> <p>Put <code>.sq</code> files in the <code>src/commonMain/sqldelight</code> directory, and then <code>expect</code> a <code>SqlDriver</code> to be provided by individual platforms when creating the <code>Database</code>. Migration files should also be in the same <code>src/commonMain/sqldelight</code> directory.</p>"},{"location":"common/query_arguments/","title":"Query arguments","text":""},{"location":"common/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"common/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"common/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"common/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"common/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"common/query_arguments_sqlite/","title":"Query arguments sqlite","text":""},{"location":"common/query_arguments_sqlite/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"common/query_arguments_sqlite/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"common/query_arguments_sqlite/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"common/query_arguments_sqlite/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"common/query_arguments_sqlite/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"common/query_arguments_sqlite/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"common/rxjava/","title":"RxJava","text":"<p>To observe a query, depend on the RxJava extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:rxjava3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:rxjava3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Observable&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asObservable()\n    .mapToList()\n</code></pre> <p>Note: For RxJava 2, use <code>rxjava2-extensions</code> as the artifact name.</p>"},{"location":"common/transactions/","title":"Transactions","text":""},{"location":"common/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"common/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"common/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"common/types_server_migrations/","title":"Types server migrations","text":""},{"location":"common/types_server_migrations/#optimistic-locking","title":"Optimistic Locking","text":"<p>If you specify a column as a <code>LOCK</code>, it would have a value type generated for it, and also require that <code>UPDATE</code> statements correctly use the lock to perform updates.</p> <pre><code>CREATE TABLE hockeyPlayer(\n  id INT AS VALUE,\n  version_number INT AS LOCK,\n  name VARCHAR(8)\n);\n\n-- This will fail (and the IDE plugin will suggest rewriting to the below)\nupdateName:\nUPDATE hockeyPlayer\nSET name = ?;\n\n-- This will pass compilation\nupdateNamePassing:\nUPDATE hockeyPlayer\nSET name = ?\n    version_number = :version_number + 1\nWHERE version_number = :version_number;\n</code></pre>"},{"location":"common/types_server_migrations/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\n  ADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"common/types_sqlite/","title":"Types sqlite","text":""},{"location":"common/types_sqlite/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\n  some_double REAL,            -- Stored as REAL in db, retrieved as Double\n  some_string TEXT,            -- Stored as TEXT in db, retrieved as String\n  some_blob BLOB               -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"common/types_sqlite/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"js_sqlite/","title":"Getting started with SQLDelight on Kotlin/JS","text":"<p>Info</p> <p>The synchronous <code>sqljs-driver</code> (pre-2.0) has been replaced with the asynchronous <code>web-worker-driver</code>. This requires configuring the <code>generateAsync</code> setting in your Gradle configuration.</p> <p>First apply the gradle plugin in your project. Make sure to set <code>generateAsync</code> to  <code>true</code> when creating your database. </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n      generateAsync.set(true)\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n      generateAsync = true\n    }\n  }\n}\n</code></pre>"},{"location":"js_sqlite/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.jsMain.dependencies {\n    implementation(\"app.cash.sqldelight:web-worker-driver:2.2.0-SNAPSHOT\")\n    implementation(devNpm(\"copy-webpack-plugin\", \"9.1.0\"))\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.jsMain.dependencies {\n    implementation \"app.cash.sqldelight:web-worker-driver:2.2.0-SNAPSHOT\"\n    implementation devNpm(\"copy-webpack-plugin\", \"9.1.0\")\n  }\n}\n</code></pre> <p>The web worker driver allows SQLDelight to communicate with a SQL implementation that is running in a Web Worker. This allows all database operations to happen in a background process.</p> <p>Info</p> <p>The web worker driver is only compatible with browser targets. </p>"},{"location":"js_sqlite/#configuring-a-web-worker","title":"Configuring a Web Worker","text":"<p>SQLDelight's web worker driver isn't tied to a specific implementation of a worker. Instead the driver communicates with the worker using a standardized set of messages. SQLDelight provides an implementation of a worker that uses SQL.js.</p> <p>See the SQL.js Worker page for details on setting it up for your project, or the Custom Workers  page for details on implementing your own.</p>"},{"location":"js_sqlite/#using-a-web-worker","title":"Using a Web Worker","text":"<p>When creating an instance of a web worker driver, you must pass a reference to the web worker that will be used to handle all SQL operations. The <code>Worker</code> constructor accepts <code>URL</code> object that references the worker script.</p> <p>Webpack has special support for referencing a worker script from an installed NPM package by passing <code>import.meta.url</code> as a second argument to the <code>URL</code> constructor. Webpack will automatically bundle the worker script from the referenced NPM package at build time. The example below shows a Worker being created from SQLDelight's SQL.js Worker.</p> <pre><code>val driver = WebWorkerDriver(\n  Worker(\n    js(\"\"\"new URL(\"@cashapp/sqldelight-sqljs-worker/sqljs.worker.js\", import.meta.url)\"\"\")\n  )\n)\n</code></pre> <p>Warning</p> <p>In order for Webpack to correctly resolve this URL while bundling, you must construct the <code>URL</code>  object entirely within a <code>js()</code> block as shown above with the <code>import.meta.url</code> argument.</p> <p>From here, you can use the driver like any other SQLDelight driver.</p>"},{"location":"js_sqlite/#using-queries","title":"Using Queries","text":""},{"location":"js_sqlite/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>suspend fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().awaitAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().awaitAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>Warning</p> <p>When using an asynchronous driver, use the suspending <code>awaitAs*()</code> extension functions when  running queries instead of the blocking <code>executeAs*()</code> functions.</p> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"js_sqlite/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact. Multiplatform support for AndroidX Paging is provided via Multiplatform Paging.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"js_sqlite/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"js_sqlite/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"js_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"js_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"js_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"js_sqlite/custom_worker/","title":"Implementing a Custom Worker","text":"<p>A SQLDelight web worker is script that can accept incoming messages from the web worker driver,  execute some SQL operations using the incoming message, and then respond accordingly with any query results.</p> <p>Web workers are most easily implemented in plain JavaScript as they are relatively short and simple scripts.</p>"},{"location":"js_sqlite/custom_worker/#incoming-messages","title":"Incoming Messages","text":"<p>The web worker driver message format allows SQLDelight to communicate with a worker implementation in a generic way that isn't tied to a specific SQL dialect or implementation. Every message contains an <code>action</code> property that specifies one of four actions.</p>"},{"location":"js_sqlite/custom_worker/#exec","title":"<code>exec</code>","text":"<p>This action indicates that the worker should execute some SQL statement attached to the message and respond with the result of the SQL query. The message will contain a <code>sql</code> property containing the SQL statement to execute, along with a <code>params</code> array that contains the parameters that are to be bound to the statement.</p> <p>Example message: <pre><code>{\n  \"id\": 5,\n  \"action\": \"exec\",\n  \"sql\": \"SELECT column_a, column_b FROM some_table WHERE column_a = ?;\",\n  \"params\": [\"value\"]\n}\n</code></pre></p>"},{"location":"js_sqlite/custom_worker/#begin_transaction","title":"<code>begin_transaction</code>","text":"<p>Tells the worker that it should begin a transaction.</p> <p>Example message: <pre><code>{\n  \"id\": 2,\n  \"action\": \"begin_transaction\"\n}\n</code></pre></p>"},{"location":"js_sqlite/custom_worker/#end_transaction","title":"<code>end_transaction</code>","text":"<p>Tells the worker that it should end the current transaction.</p> <p>Example message: <pre><code>{\n  \"id\": 3,\n  \"action\": \"end_transaction\"\n}\n</code></pre></p>"},{"location":"js_sqlite/custom_worker/#rollback_transaction","title":"<code>rollback_transaction</code>","text":"<p>Tells the worker to rollback the current transaction.</p> <p>Example message: <pre><code>{\n  \"id\": 8,\n  \"action\": \"rollback_transaction\"\n}\n</code></pre></p>"},{"location":"js_sqlite/custom_worker/#responding-to-messages","title":"Responding to Messages","text":"<p>Every incoming message contains an <code>id</code> property which is a unique integer for that message. When responding to a message, the worker implementation must include this <code>id</code> value in the response message. This is used by the web worker driver to correctly handle the response.</p>"},{"location":"js_sqlite/custom_worker/#the-results-property","title":"The <code>results</code> Property","text":"<p>A response message should also contain a <code>results</code> property. This is used to communicate the results of some SQL execution, particularly for the result set of a query. The <code>results</code> property should be an array representing the rows of results, where each entry is an array representing the columns in the result set.</p> <p>For example, a response to the <code>exec</code> message above could be:</p> <pre><code>{\n  \"id\": 5,\n  \"results\": [\n    [\"value\", \"this is the content of column_b\"],\n    [\"value\", \"this is a different row\"]\n  ]\n}\n</code></pre> <p>For a SQL statement that does not return a result set, the <code>results</code> value should contain a single row/column with a number representing the number of rows that were affected by the execution of the statement.</p> <pre><code>{\n  \"id\": 10,\n  \"results\": [ [1] ]\n}\n</code></pre>"},{"location":"js_sqlite/custom_worker/#examples","title":"Examples","text":"<ul> <li>SQLDelight's SQL.js Worker</li> </ul>"},{"location":"js_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"js_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"js_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"js_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"js_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"js_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"js_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"js_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"js_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"js_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"js_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"js_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"js_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"js_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"js_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"js_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"js_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"js_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"js_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"js_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"js_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>A <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>check</code> task. For any <code>.db</code> file named <code>&lt;version number&gt;.db</code> in your SqlDelight source set (e.g. <code>src/main/sqldelight</code>) it will apply all migrations starting from <code>&lt;version number&gt;.sqm</code>, and confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generate&lt;source set name&gt;&lt;database name&gt;Schema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration. For example, if your project uses the <code>main</code> source set with a custom name of <code>\"MyDatabase\"</code>, you'll need to run the <code>generateMainMyDatabaseSchema</code> task.</p> <p>Most use cases would benefit from only having a <code>1.db</code> file representing the schema of the initial version of their database. Having multiple <code>.db</code> files is allowed, but that would result in each <code>.db</code> file having each of its migrations applied to it, which causes a lot of unnecessary work.</p>"},{"location":"js_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\n    driver = database,\n    oldVersion = 0,\n    newVersion = Database.Schema.version,\n    AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"js_sqlite/multiplatform/","title":"Multiplatform setup with the Web Worker Driver","text":"<p>First apply the gradle plugin in your project. Make sure to set <code>generateAsync</code> to  <code>true</code> when creating your database. </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n      generateAsync.set(true)\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n      generateAsync = true\n    }\n  }\n}\n</code></pre>"},{"location":"js_sqlite/multiplatform/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p> <pre><code>kotlin {\n  // The drivers needed will change depending on what platforms you target:\n\n  sourceSets.androidMain.dependencies {\n    implementation \"app.cash.sqldelight:android-driver:2.2.0-SNAPSHOT\"\n  }\n\n  // or sourceSets.iosMain, sourceSets.windowsMain, etc.\n  sourceSets.nativeMain.dependencies {\n    implementation \"app.cash.sqldelight:native-driver:2.2.0-SNAPSHOT\"\n  }\n\n  sourceSets.jvmMain.dependencies {\n    implementation \"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\"\n  }\n\n  sourceSets.jsMain.dependencies {\n    implementation \"app.cash.sqldelight:sqljs-driver:2.2.0-SNAPSHOT\"\n    implementation npm(\"sql.js\", \"1.6.2\")\n    implementation devNpm(\"copy-webpack-plugin\", \"9.1.0\")\n  }\n}\n</code></pre>"},{"location":"js_sqlite/multiplatform/#creating-drivers","title":"Creating Drivers","text":"<p>First set up a way to create a driver in your common code. This can be done using <code>expect</code>/<code>actual</code>, or simply with a common interface a platform-specific implementations of the interface.</p> <p>src/commonMain/kotlin<pre><code>expect suspend fun provideDbDriver(\n  schema: SqlSchema&lt;QueryResult.AsyncValue&lt;Unit&gt;&gt;\n): SqlDriver\n</code></pre> The <code>SqlSchema</code> interface contains a generic <code>QueryResult</code> type argument which is used to differentiate schema code that is generated with the <code>generateAsync</code> configuration option set to <code>true</code>. Some drivers rely on synchronous behaviours when creating or migrating the schema, so to use an asynchronous schema you can use the <code>synchronous()</code> extension method to adapt it for use with synchronous drivers. </p> src/jsMain/kotlinsrc/jvmMain/kotlinsrc/androidMain/kotlinsrc/nativeMain/kotlin <pre><code>actual suspend fun provideDbDriver(\n  schema: SqlSchema&lt;QueryResult.AsyncValue&lt;Unit&gt;&gt;\n): SqlDriver {\n  return WebWorkerDriver(\n    Worker(\n      js(\"\"\"new URL(\"@cashapp/sqldelight-sqljs-worker/sqljs.worker.js\", import.meta.url)\"\"\")\n    )\n  ).also { schema.create(it).await() }\n}\n</code></pre> <pre><code>actual suspend fun provideDbDriver(\n  schema: SqlSchema&lt;QueryResult.AsyncValue&lt;Unit&gt;&gt;\n): SqlDriver {\n  return JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)\n    .also { schema.create(it).await() }\n}\n</code></pre> <pre><code>actual suspend fun provideDbDriver(\n  schema: SqlSchema&lt;QueryResult.AsyncValue&lt;Unit&gt;&gt;\n): SqlDriver {\n  return AndroidSqliteDriver(schema.synchronous(), context, \"test.db\")\n}\n</code></pre> <pre><code>actual suspend fun provideDbDriver(\n  schema: SqlSchema&lt;QueryResult.AsyncValue&lt;Unit&gt;&gt;\n): SqlDriver {\n  return NativeSqliteDriver(schema.synchronous(), \"test.db\")\n}\n</code></pre>"},{"location":"js_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"js_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"js_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"js_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"js_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"js_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"js_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"js_sqlite/sqljs_worker/","title":"SQL.js Web Worker","text":"<p>To include the SQL.js worker in your project, first add a dependency on the worker package along with a dependency on SQL.js.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.jsMain.dependencies {\n    implementation(npm(\"@cashapp/sqldelight-sqljs-worker\", \"2.2.0-SNAPSHOT\"))\n    implementation(npm(\"sql.js\", \"1.8.0\"))\n  }\n}\n</code></pre> <pre><code>kotlin { \n  sourceSets.jsMain.dependencies {\n    implementation npm(\"@cashapp/sqldelight-sqljs-worker\", \"2.2.0-SNAPSHOT\")\n    implementation npm(\"sql.js\", \"1.8.0\")\n  }\n}\n</code></pre> <p>The SQL.js package includes a WebAssembly binary that must be copied into your application's output. In your project, add an additional Webpack configuration file to configure the copying of the binary to your assembled project.</p> webpack.config.d/sqljs-config.js<pre><code>// {project}/webpack.config.d/sqljs.js\nconfig.resolve = {\n    fallback: {\n        fs: false,\n        path: false,\n        crypto: false,\n    }\n};\n\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconfig.plugins.push(\n    new CopyWebpackPlugin({\n        patterns: [\n            '../../node_modules/sql.js/dist/sql-wasm.wasm'\n        ]\n    })\n);\n</code></pre>"},{"location":"js_sqlite/sqljs_worker/#configuring-karma-for-tests","title":"Configuring Karma for Tests","text":"<p>For tests, there is also some additional Karma configuration required so that the WebAssembly binaries can be located at runtime. Copy the following into your project's <code>karma.config.d</code> directory.</p> karma.config.d/sqljs-config.js<pre><code>const path = require(\"path\");\nconst os = require(\"os\");\nconst dist = path.resolve(\"../../node_modules/sql.js/dist/\")\nconst wasm = path.join(dist, \"sql-wasm.wasm\")\n\nconfig.files.push({\n    pattern: wasm,\n    served: true,\n    watched: false,\n    included: false,\n    nocache: false,\n});\n\nconfig.proxies[\"/sql-wasm.wasm\"] = path.join(\"/absolute/\", wasm)\n\n// Adapted from: https://github.com/ryanclark/karma-webpack/issues/498#issuecomment-790040818\nconst output = {\n  path: path.join(os.tmpdir(), '_karma_webpack_') + Math.floor(Math.random() * 1000000),\n}\nconfig.set({\n  webpack: {...config.webpack, output}\n});\nconfig.files.push({\n  pattern: `${output.path}/**/*`,\n  watched: false,\n  included: false,\n});\n</code></pre>"},{"location":"js_sqlite/sqljs_worker/#using-the-worker","title":"Using the Worker","text":"<p>The worker script is called <code>sqljs.worker.js</code> and can be referenced in code like this:</p> <pre><code>val driver = WebWorkerDriver(\n  Worker(\n    js(\"\"\"new URL(\"@cashapp/sqldelight-sqljs-worker/sqljs.worker.js\", import.meta.url)\"\"\")\n  )\n)\n</code></pre> <p>See \"Using a Web Worker\" for more details.</p>"},{"location":"js_sqlite/transactions/","title":"Transactions","text":""},{"location":"js_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"js_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"js_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"js_sqlite/types/","title":"Types","text":""},{"location":"js_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\n  some_double REAL,            -- Stored as REAL in db, retrieved as Double\n  some_string TEXT,            -- Stored as TEXT in db, retrieved as String\n  some_blob BLOB               -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"js_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"js_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"js_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"js_sqlite/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"jvm_h2/","title":"Getting Started with HSQL on JVM","text":"<p>Experimental</p> <p>HSQL support is incubating, and pieces of the dialect are still missing. If you encounter parts  of the dialect which are unsupported, please report it at sql-psi.</p> <p>First apply the gradle plugin in your project and set your database's dialect accordingly.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n      dialect(\"app.cash.sqldelight:hsql-dialect:2.2.0-SNAPSHOT\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n      dialect \"app.cash.sqldelight:hsql-dialect:2.2.0-SNAPSHOT\"\n    }\n  }\n}\n</code></pre> <p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"jvm_h2/#fresh-schema","title":"Fresh Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"jvm_h2/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"Database\") {\n      ...\n      srcDirs(\"sqldelight\")\n      deriveSchemaFromMigrations.set(true)\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    Database {\n      ...\n      srcDirs \"sqldelight\"\n      deriveSchemaFromMigrations = true\n    }\n  }\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"jvm_h2/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p>"},{"location":"jvm_h2/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_h2/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"jvm_h2/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_h2/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_h2/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_h2/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_h2/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_h2/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"jvm_h2/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_h2/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_h2/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_h2/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_h2/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_h2/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_h2/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_h2/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_h2/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_h2/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_h2/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_h2/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_h2/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_h2/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_h2/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_h2/migrations/","title":"Migrations","text":""},{"location":"jvm_h2/migrations/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\n  databases {\n    Database {\n      migrationOutputDirectory = layout.buildDirectory.dir(\"resources/main/migrations\")\n      migrationOutputFileFormat = \".sql\" // Defaults to .sql\n  }\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\n  dependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"jvm_h2/query_arguments/","title":"Arguments","text":""},{"location":"jvm_h2/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as H2, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_h2/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_h2/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_h2/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_h2/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_h2/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_h2/transactions/","title":"Transactions","text":""},{"location":"jvm_h2/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_h2/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"jvm_h2/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"jvm_h2/types/","title":"Types","text":""},{"location":"jvm_h2/types/#mysql-types","title":"MySQL Types","text":"<p>SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_tiny_int TINYINT,                           -- Retrieved as Byte\n  some_small_int SMALLINT,                         -- Retrieved as Short\n  some_integer INTEGER,                            -- Retrieved as Int\n  some_int INT,                                    -- Retrieved as Int\n  some_big_int BIGINT,                             -- Retrieved as Long\n  some_decimal DECIMAL(6,5),                       -- Retrieved as Int\n  some_dec DEC(6,5),                               -- Retrieved as Int\n  some_numeric NUMERIC(6,5),                       -- Retrieved as Int\n  some_float FLOAT(6),                             -- Retrieved as Double\n  some_real REAL,                                  -- Retrieved as Double\n  some_double DOUBLE,                              -- Retrieved as Double\n  some_double_precision DOUBLE PRECISION,          -- Retrieved as Double\n  some_boolean BOOLEAN,                            -- Retrieved as Boolean\n  some_date DATE,                                  -- Retrieved as String\n  some_time TIME,                                  -- Retrieved as String\n  some_timestamp2 TIMESTAMP(6),                    -- Retrieved as String\n  some_char CHAR,                                  -- Retrieved as String\n  some_character CHARACTER(6),                     -- Retrieved as String\n  some_char_varying CHAR VARYING(6),               -- Retrieved as String\n  some_longvarchar LONGVARCHAR,                    -- Retrieved as String\n  some_character_varying CHARACTER VARYING(6),     -- Retrieved as String\n  some_varchar VARCHAR(16),                        -- Retrieved as String\n  some_clo CHARACTER LARGE OBJECT(16),             -- Retrieved as String\n  some_clob clob(16 M CHARACTERS),                 -- Retrieved as String\n  some_binary BINARY,                              -- Retrieved as ByteArray\n  some_binary2 BINARY(6),                          -- Retrieved as ByteArray\n  some_longvarbinary LONGVARBINARY,                -- Retrieved as ByteArray\n  some_longvarbinary2 LONGVARBINARY(6),            -- Retrieved as ByteArray\n  some_binary_varying BINARY VARYING(6),           -- Retrieved as ByteArray\n  some_varbinary VARBINARY(8),                     -- Retrieved as ByteArray\n  some_uuid UUID,                                  -- Retrieved as ByteArray\n  some_blob BLOB,                                  -- Retrieved as ByteArray\n  some_blo BINARY LARGE OBJECT(6),                 -- Retrieved as ByteArray\n  some_bit BIT,                                    -- Retrieved as ByteArray\n  some_bit2 BIT(6),                                -- Retrieved as ByteArray\n  some_bit_varying BIT VARYING(6),                 -- Retrieved as ByteArray\n  some_interval INTERVAL YEAR TO MONTH,            -- Retrieved as ByteArray\n  some_interval2 INTERVAL YEAR(3),                 -- Retrieved as ByteArray\n  some_interval3 INTERVAL DAY(4) TO HOUR,          -- Retrieved as ByteArray\n  some_interval4 INTERVAL MINUTE(4) TO SECOND(6),  -- Retrieved as ByteArray\n  some_interval5 INTERVAL SECOND(4,6)              -- Retrieved as ByteArray\n);\n</code></pre>"},{"location":"jvm_h2/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"jvm_h2/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"jvm_h2/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"jvm_h2/types/#optimistic-locking","title":"Optimistic Locking","text":"<p>If you specify a column as a <code>LOCK</code>, it would have a value type generated for it, and also require that <code>UPDATE</code> statements correctly use the lock to perform updates.</p> <pre><code>CREATE TABLE hockeyPlayer(\n  id INT AS VALUE,\n  version_number INT AS LOCK,\n  name VARCHAR(8)\n);\n\n-- This will fail (and the IDE plugin will suggest rewriting to the below)\nupdateName:\nUPDATE hockeyPlayer\nSET name = ?;\n\n-- This will pass compilation\nupdateNamePassing:\nUPDATE hockeyPlayer\nSET name = ?\n    version_number = :version_number + 1\nWHERE version_number = :version_number;\n</code></pre>"},{"location":"jvm_h2/types/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\n  ADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"jvm_mysql/","title":"Getting Started with MySQL on JVM","text":"<p>First apply the gradle plugin in your project and set your database's dialect accordingly.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n      dialect(\"app.cash.sqldelight:mysql-dialect:2.2.0-SNAPSHOT\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n      dialect \"app.cash.sqldelight:mysql-dialect:2.2.0-SNAPSHOT\"\n    }\n  }\n}\n</code></pre> <p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"jvm_mysql/#fresh-schema","title":"Fresh Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"jvm_mysql/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"Database\") {\n      ...\n      srcDirs(\"sqldelight\")\n      deriveSchemaFromMigrations.set(true)\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    Database {\n      ...\n      srcDirs \"sqldelight\"\n      deriveSchemaFromMigrations = true\n    }\n  }\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"jvm_mysql/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p>"},{"location":"jvm_mysql/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_mysql/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"jvm_mysql/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_mysql/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_mysql/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_mysql/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_mysql/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_mysql/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"jvm_mysql/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_mysql/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_mysql/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_mysql/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_mysql/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_mysql/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_mysql/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_mysql/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_mysql/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_mysql/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_mysql/migrations/","title":"Migrations","text":""},{"location":"jvm_mysql/migrations/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\n  databases {\n    Database {\n      migrationOutputDirectory = layout.buildDirectory.dir(\"resources/main/migrations\")\n      migrationOutputFileFormat = \".sql\" // Defaults to .sql\n  }\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\n  dependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"jvm_mysql/query_arguments/","title":"Arguments","text":""},{"location":"jvm_mysql/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_mysql/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_mysql/transactions/","title":"Transactions","text":""},{"location":"jvm_mysql/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_mysql/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"jvm_mysql/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"jvm_mysql/types/","title":"Types","text":""},{"location":"jvm_mysql/types/#mysql-types","title":"MySQL Types","text":"<p>SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_bit BIT,                      -- Retrieved as Boolean\n  some_tiny_int TINYINT,             -- Retrieved as Byte \n  some_small_int SMALLINT,           -- Retrieved as Short\n  some_medium_int MEDIUMINT,         -- Retrieved as Int\n  some_integer INTEGER,              -- Retrieved as Int\n  some_int INT,                      -- Retrieved as Int\n  some_big_int BIGINT,               -- Retrieved as Long\n  some_decimal DECIMAL,              -- Retrieved as Double\n  some_dec DEC,                      -- Retrieved as Double\n  some_fixed FIXED,                  -- Retrieved as Double\n  some_numeric NUMERIC,              -- Retrieved as BigDecimal\n  some_float FLOAT,                  -- Retrieved as Double\n  some_real REAL,                    -- Retrieved as Double\n  some_double_prec DOUBLE PRECISION, -- Retrieved as Double\n  some_double DOUBLE,                -- Retrieved as Double\n  some_date DATE,                    -- Retrieved as LocalDate\n  some_time TIME,                    -- Retrieved as LocalTime\n  some_datetime DATETIME,            -- Retrieved as LocalDateTime\n  some_timestamp TIMESTAMP,          -- Retrieved as OffsetDateTime\n  some_year YEAR,                    -- Retrieved as String\n  some_char CHAR,                    -- Retrieved as String\n  some_varchar VARCHAR(16),          -- Retrieved as String\n  some_tiny_text TINYTEXT,           -- Retrieved as String\n  some_text TEXT,                    -- Retrieved as String\n  some_medium_text MEDIUMTEXT,       -- Retrieved as String\n  some_long_text LONGTEXT,           -- Retrieved as String\n  some_enum ENUM,                    -- Retrieved as String\n  some_set SET,                      -- Retrieved as String\n  some_varbinary VARBINARY(8),       -- Retrieved as ByteArray\n  some_blob BLOB(8, 8),              -- Retrieved as ByteArray\n  some_binary BINARY,                -- Retrieved as ByteArray\n  some_json JSON,                    -- Retrieved as String\n  some_boolean BOOLEAN,              -- Retrieved as Boolean\n);\n</code></pre>"},{"location":"jvm_mysql/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"jvm_mysql/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"jvm_mysql/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"jvm_mysql/types/#optimistic-locking","title":"Optimistic Locking","text":"<p>If you specify a column as a <code>LOCK</code>, it would have a value type generated for it, and also require that <code>UPDATE</code> statements correctly use the lock to perform updates.</p> <pre><code>CREATE TABLE hockeyPlayer(\n  id INT AS VALUE,\n  version_number INT AS LOCK,\n  name VARCHAR(8)\n);\n\n-- This will fail (and the IDE plugin will suggest rewriting to the below)\nupdateName:\nUPDATE hockeyPlayer\nSET name = ?;\n\n-- This will pass compilation\nupdateNamePassing:\nUPDATE hockeyPlayer\nSET name = ?\n    version_number = :version_number + 1\nWHERE version_number = :version_number;\n</code></pre>"},{"location":"jvm_mysql/types/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\n  ADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"jvm_postgresql/","title":"Getting Started with PostgreSQL on JVM","text":"<p>First apply the gradle plugin in your project and set your database's dialect accordingly.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n      dialect(\"app.cash.sqldelight:postgresql-dialect:2.2.0-SNAPSHOT\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n      dialect \"app.cash.sqldelight:postgresql-dialect:2.2.0-SNAPSHOT\"\n    }\n  }\n}\n</code></pre> <p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"jvm_postgresql/#fresh-schema","title":"Fresh Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"jvm_postgresql/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"Database\") {\n      ...\n      srcDirs(\"sqldelight\")\n      deriveSchemaFromMigrations.set(true)\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    Database {\n      ...\n      srcDirs \"sqldelight\"\n      deriveSchemaFromMigrations = true\n    }\n  }\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"jvm_postgresql/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:jdbc-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p>"},{"location":"jvm_postgresql/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_postgresql/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"jvm_postgresql/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_postgresql/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_postgresql/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_postgresql/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_postgresql/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_postgresql/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"jvm_postgresql/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_postgresql/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_postgresql/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_postgresql/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_postgresql/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_postgresql/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_postgresql/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_postgresql/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_postgresql/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_postgresql/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_postgresql/migrations/","title":"Migrations","text":""},{"location":"jvm_postgresql/migrations/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\n  databases {\n    Database {\n      migrationOutputDirectory = layout.buildDirectory.dir(\"resources/main/migrations\")\n      migrationOutputFileFormat = \".sql\" // Defaults to .sql\n  }\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\n  dependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/","title":"Arguments","text":""},{"location":"jvm_postgresql/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_postgresql/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_postgresql/transactions/","title":"Transactions","text":""},{"location":"jvm_postgresql/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_postgresql/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"jvm_postgresql/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"jvm_postgresql/types/","title":"Types","text":""},{"location":"jvm_postgresql/types/#postgresql-types","title":"PostgreSQL Types","text":"<p>SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_smallint SMALLINT,               -- Retrieved as Short\n  some_int2 INT2,                       -- Retrieved as Short\n  some_integer INTEGER,                 -- Retrieved as Int\n  some_int INT,                         -- Retrieved as Int\n  some_int4 INT4,                       -- Retrieved as Int\n  some_bigint BIGINT,                   -- Retrieved as Long\n  some_int8 INT8,                       -- Retrieved as Long\n  some_numeric NUMERIC,                 -- Retrieved as BigDecimal\n  some_decimal DECIMAL,                 -- Retrieved as Double\n  some_real REAL,                       -- Retrieved as Double\n  some_float4 FLOAT4,                   -- Retrieved as Double\n  some_double_prec DOUBLE PRECISION,    -- Retrieved as Double\n  some_float8 FLOAT8,                   -- Retrieved as Double\n  some_smallserial SMALLSERIAL,         -- Retrieved as Short\n  some_serial2 SERIAL2,                 -- Retrieved as Short\n  some_serial SERIAL,                   -- Retrieved as Int\n  some_serial4 SERIAL4,                 -- Retrieved as Int\n  some_bigserial BIGSERIAL,             -- Retrieved as Long\n  some_serial8 SERIAL8,                 -- Retrieved as Long\n  some_character CHARACTER,             -- Retrieved as String\n  some_char CHAR,                       -- Retrieved as String\n  some_char_var CHARACTER VARYING(16),  -- Retrieved as String\n  some_varchar VARCHAR(16),             -- Retrieved as String\n  some_text TEXT,                       -- Retrieved as String\n  some_date DATE,                       -- Retrieved as LocalDate\n  some_time TIME,                       -- Retrieved as LocalTime\n  some_timestamp TIMESTAMP,             -- Retrieved as LocalDateTime\n  some_timestamp TIMESTAMPTZ,           -- Retrieved as OffsetDateTime\n  some_json JSON,                       -- Retrieved as String\n  some_jsonb JSONB,                     -- Retrieved as String\n  some_interval INTERVAL,               -- Retrieved as String\n  some_uuid UUID                        -- Retrieved as UUID\n  some_bool BOOL,                       -- Retrieved as Boolean\n  some_boolean BOOLEAN,                 -- Retrieved as Boolean\n  some_bytea BYTEA                      -- Retrieved as ByteArray\n);\n</code></pre>"},{"location":"jvm_postgresql/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"jvm_postgresql/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"jvm_postgresql/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"jvm_postgresql/types/#optimistic-locking","title":"Optimistic Locking","text":"<p>If you specify a column as a <code>LOCK</code>, it would have a value type generated for it, and also require that <code>UPDATE</code> statements correctly use the lock to perform updates.</p> <pre><code>CREATE TABLE hockeyPlayer(\n  id INT AS VALUE,\n  version_number INT AS LOCK,\n  name VARCHAR(8)\n);\n\n-- This will fail (and the IDE plugin will suggest rewriting to the below)\nupdateName:\nUPDATE hockeyPlayer\nSET name = ?;\n\n-- This will pass compilation\nupdateNamePassing:\nUPDATE hockeyPlayer\nSET name = ?\n    version_number = :version_number + 1\nWHERE version_number = :version_number;\n</code></pre>"},{"location":"jvm_postgresql/types/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\n  ADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"jvm_sqlite/","title":"Getting Started on JVM with SQLite","text":"<p>First apply the gradle plugin in your project.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n    }\n  }\n}\n</code></pre>"},{"location":"jvm_sqlite/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p> <p>To use the generated database in your code, you must add the SQLDelight SQLite driver dependency to your project.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>An instance of the driver can be constructed as shown below. The constructor accepts a JDBC connection string that specifies the location of the database file. The <code>IN_MEMORY</code> constant can also be passed to the constructor to create an in-memory database.</p> On-DiskIn-Memory <pre><code>val driver: SqlDriver = JdbcSqliteDriver(\"jdbc:sqlite:test.db\", Properties(), Database.Schema)\n</code></pre> <pre><code>val driver: SqlDriver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY, Properties(), Database.Schema)\n</code></pre>"},{"location":"jvm_sqlite/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_sqlite/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"jvm_sqlite/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_sqlite/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"jvm_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"jvm_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, add the coroutines extensions artifact as a dependency and use the extension functions it provides:</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"jvm_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_sqlite/foreign_keys/","title":"Foreign Keys","text":"<p>You can enable foreign key constraints for the JVM SQLite driver by passing the setting to the driver's properties.</p> <pre><code>JdbcSqliteDriver(\n  url = \"...\", \n  properties = Properties().apply { put(\"foreign_keys\", \"true\") }\n)\n</code></pre>"},{"location":"jvm_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"jvm_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"jvm_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"jvm_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>A <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>check</code> task. For any <code>.db</code> file named <code>&lt;version number&gt;.db</code> in your SqlDelight source set (e.g. <code>src/main/sqldelight</code>) it will apply all migrations starting from <code>&lt;version number&gt;.sqm</code>, and confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generate&lt;source set name&gt;&lt;database name&gt;Schema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration. For example, if your project uses the <code>main</code> source set with a custom name of <code>\"MyDatabase\"</code>, you'll need to run the <code>generateMainMyDatabaseSchema</code> task.</p> <p>Most use cases would benefit from only having a <code>1.db</code> file representing the schema of the initial version of their database. Having multiple <code>.db</code> files is allowed, but that would result in each <code>.db</code> file having each of its migrations applied to it, which causes a lot of unnecessary work.</p>"},{"location":"jvm_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\n    driver = database,\n    oldVersion = 0,\n    newVersion = Database.Schema.version,\n    AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p> <p>If you are using an <code>JdbcSqliteDriver</code> you can pass the schema and callbacks in during the driver's creation. It uses <code>PRAGMA user_version</code> to store current version of schema in database.</p> <pre><code>val driver: SqlDriver = JdbcSqliteDriver(\n    url = \"jdbc:sqlite:test.db\",\n    properties = Properties(),\n    schema = Database.Schema,\n    callbacks = arrayOf(\n        AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) }\n    )\n)\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"jvm_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_sqlite/rxjava/","title":"RxJava","text":"<p>To observe a query, depend on the RxJava extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:rxjava3-extensions:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:rxjava3-extensions:2.2.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Observable&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asObservable()\n    .mapToList()\n</code></pre> <p>Note: For RxJava 2, use <code>rxjava2-extensions</code> as the artifact name.</p>"},{"location":"jvm_sqlite/transactions/","title":"Transactions","text":""},{"location":"jvm_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"jvm_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"jvm_sqlite/types/","title":"Types","text":""},{"location":"jvm_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\n  some_double REAL,            -- Stored as REAL in db, retrieved as Double\n  some_string TEXT,            -- Stored as TEXT in db, retrieved as String\n  some_blob BLOB               -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"jvm_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"jvm_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"jvm_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"jvm_sqlite/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"multiplatform_sqlite/","title":"Getting Started with SQLite on Multiplatform","text":"<p>First apply the gradle plugin in your project.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n    }\n  }\n}\n</code></pre>"},{"location":"multiplatform_sqlite/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p> <p>To use the generated database in your code, you must add a SQLDelight driver dependency to your project. Each target platform has its own driver implementation.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.androidMain.dependencies {\n    implementation(\"app.cash.sqldelight:android-driver:2.2.0-SNAPSHOT\")\n  }\n\n  // or iosMain, windowsMain, etc.\n  sourceSets.nativeMain.dependencies {\n    implementation(\"app.cash.sqldelight:native-driver:2.2.0-SNAPSHOT\")\n  }\n\n  sourceSets.jvmMain.dependencies {\n    implementation(\"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.androidMain.dependencies {\n    implementation \"app.cash.sqldelight:android-driver:2.2.0-SNAPSHOT\"\n  }\n\n  // or iosMain, windowsMain, etc.\n  sourceSets.nativeMain.dependencies {\n    implementation \"app.cash.sqldelight:native-driver:2.2.0-SNAPSHOT\"\n  }\n\n  sourceSets.jvmMain.dependencies {\n    implementation \"app.cash.sqldelight:sqlite-driver:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre>"},{"location":"multiplatform_sqlite/#constructing-driver-instances","title":"Constructing Driver Instances","text":"<p>Create a common factory class or method to obtain a <code>SqlDriver</code> instance.</p> src/commonMain/kotlin<pre><code>import com.example.Database\n\nexpect class DriverFactory {\n  fun createDriver(): SqlDriver\n}\n\nfun createDatabase(driverFactory: DriverFactory): Database {\n  val driver = driverFactory.createDriver()\n  val database = Database(driver)\n\n  // Do more work with the database (see below).\n}\n</code></pre> <p>Then implement this for each target platform:</p> src/androidMain/kotlinsrc/nativeMain/kotlinsrc/jvmMain/kotlin <pre><code>actual class DriverFactory(private val context: Context) {\n  actual fun createDriver(): SqlDriver {\n    return AndroidSqliteDriver(Database.Schema, context, \"test.db\")\n  }\n}\n</code></pre> <pre><code>actual class DriverFactory {\n  actual fun createDriver(): SqlDriver {\n    return NativeSqliteDriver(Database.Schema, \"test.db\")\n  }\n}\n</code></pre> <pre><code>actual class DriverFactory {\n  actual fun createDriver(): SqlDriver {\n    val driver: SqlDriver = JdbcSqliteDriver(\"jdbc:sqlite:test.db\", Properties(), Database.Schema)\n    return driver\n  }\n}\n</code></pre> <p>For use with Kotlin/JS, see here.</p>"},{"location":"multiplatform_sqlite/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"multiplatform_sqlite/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact. Multiplatform support for AndroidX Paging is provided via Multiplatform Paging.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"multiplatform_sqlite/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"multiplatform_sqlite/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"multiplatform_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"multiplatform_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"multiplatform_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"multiplatform_sqlite/foreign_keys/","title":"Foreign Keys","text":""},{"location":"multiplatform_sqlite/foreign_keys/#android-sqlite","title":"Android SQLite","text":"<p>You can enable foreign key constraints for the Android SQLite driver through the driver's <code>onOpen</code> callback.</p> <pre><code>AndroidSqliteDriver(\n  schema = Database.Schema,\n  callback = object : AndroidSqliteDriver.Callback(Database.Schema) {\n    override fun onOpen(db: SupportSQLiteDatabase) {\n      db.setForeignKeyConstraintsEnabled(true)\n    }\n  }\n)\n</code></pre>"},{"location":"multiplatform_sqlite/foreign_keys/#jvm-sqlite","title":"JVM SQLite","text":"<p>You can enable foreign key constraints for the JVM SQLite driver by passing the setting to the driver's properties.</p> <pre><code>JdbcSqliteDriver(\n  url = \"...\", \n  properties = Properties().apply { put(\"foreign_keys\", \"true\") }\n)\n</code></pre>"},{"location":"multiplatform_sqlite/foreign_keys/#native-sqlite","title":"Native SQLite","text":"<p>You can enable foreign key constraints for the Native SQLite driver by enabling them in the database configuration.</p> <pre><code>NativeSqliteDriver(\n  schema = Database.Schema,\n  onConfiguration = { config: DatabaseConfiguration -&gt;\n    config.copy(\n      extendedConfig = DatabaseConfiguration.Extended(foreignKeyConstraints = true)\n    )\n  }\n)\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"multiplatform_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"multiplatform_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"multiplatform_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"multiplatform_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"multiplatform_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"multiplatform_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"multiplatform_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"multiplatform_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>A <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>check</code> task. For any <code>.db</code> file named <code>&lt;version number&gt;.db</code> in your SqlDelight source set (e.g. <code>src/main/sqldelight</code>) it will apply all migrations starting from <code>&lt;version number&gt;.sqm</code>, and confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generate&lt;source set name&gt;&lt;database name&gt;Schema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration. For example, if your project uses the <code>main</code> source set with a custom name of <code>\"MyDatabase\"</code>, you'll need to run the <code>generateMainMyDatabaseSchema</code> task.</p> <p>Most use cases would benefit from only having a <code>1.db</code> file representing the schema of the initial version of their database. Having multiple <code>.db</code> files is allowed, but that would result in each <code>.db</code> file having each of its migrations applied to it, which causes a lot of unnecessary work.</p>"},{"location":"multiplatform_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\n    driver = database,\n    oldVersion = 0,\n    newVersion = Database.Schema.version,\n    AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"multiplatform_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"multiplatform_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"multiplatform_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"multiplatform_sqlite/resources/","title":"Other Resources","text":""},{"location":"multiplatform_sqlite/resources/#guides","title":"Guides","text":"<ul> <li>Introduction to Multiplatform Persistence with SQLDelight</li> <li>Multiplatform Persistence with SQLDelight</li> </ul>"},{"location":"multiplatform_sqlite/resources/#samples","title":"Samples","text":"<ul> <li>https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web)</li> <li>https://github.com/JakeWharton/SdkSearch (Android/Web)</li> <li>https://github.com/saket/press (Android/macOS)</li> <li>https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web)</li> <li>https://github.com/russhwolf/To-Do (Android/iOS using Compose/SwiftUI)</li> </ul>"},{"location":"multiplatform_sqlite/transactions/","title":"Transactions","text":""},{"location":"multiplatform_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"multiplatform_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"multiplatform_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"multiplatform_sqlite/types/","title":"Types","text":""},{"location":"multiplatform_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\n  some_double REAL,            -- Stored as REAL in db, retrieved as Double\n  some_string TEXT,            -- Stored as TEXT in db, retrieved as String\n  some_blob BLOB               -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"multiplatform_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"multiplatform_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"multiplatform_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"multiplatform_sqlite/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"},{"location":"native_sqlite/","title":"Getting started with SQLDelight on Kotlin/Native","text":"<p>Kotlin/Native Memory Manager</p> <p>Since SQLDelight 2.0, the SQLDelight Native driver only supports Kotlin/Native's new memory manager.</p> <p>First apply the gradle plugin in your project.  </p> KotlinGroovy <pre><code>plugins {\n  id(\"app.cash.sqldelight\") version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    create(\"Database\") {\n      packageName.set(\"com.example\")\n    }\n  }\n}\n</code></pre> <pre><code>plugins {\n  id \"app.cash.sqldelight\" version \"2.2.0-SNAPSHOT\"\n}\n\nrepositories {\n  google()\n  mavenCentral()\n}\n\nsqldelight {\n  databases {\n    Database { // This will be the name of the generated database class.\n      packageName = \"com.example\"\n    }\n  }\n}\n</code></pre>"},{"location":"native_sqlite/#defining-the-schema","title":"Defining the Schema","text":"<p>Write your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>.  Typically the first statement in the <code>.sq</code> file creates a table, but you can also create indexes or set up default content.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>CREATE TABLE hockeyPlayer (\n  player_number INTEGER PRIMARY KEY NOT NULL,\n  full_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From these statements, SQLDelight will generate a <code>Database</code> class with an associated <code>Schema</code> object that can be used to create your database and execute statements on it. The <code>Database</code> class is generated by the <code>generateSqlDelightInterface</code> Gradle task which is run automatically by the SQLDelight IDE plugin when you edit a <code>.sq</code> file, and also as part of a normal Gradle build.</p> <p>To use the generated database in your code, you must add the SQLDelight Native driver dependency to your project.</p> KotlinGroovy <pre><code>kotlin {\n  // or iosMain, windowsMain, etc.\n  sourceSets.nativeMain.dependencies {\n    implementation(\"app.cash.sqldelight:native-driver:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  // or iosMain, windowsMain, etc.\n  sourceSets.nativeMain.dependencies {\n    implementation \"app.cash.sqldelight:native-driver:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <p>An instance of the driver can be constructed as shown below, and requires a reference to the generated <code>Schema</code> object.</p> <pre><code>val driver: SqlDriver = NativeSqliteDriver(Database.Schema, \"test.db\")\n</code></pre>"},{"location":"native_sqlite/#defining-typesafe-queries","title":"Defining Typesafe Queries","text":"<p>SQLDelight will generate a typesafe function for any labeled SQL statement in a <code>.sq</code> file.</p> src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq<pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>A \"Queries\" object will be generated for each <code>.sq</code> file containing labeled statements. For example, a <code>PlayerQueries</code> object will be generated for the <code>Player.sq</code> file shown above. This object can be used to call the generated typesafe functions which will execute the actual SQL statements.</p> <pre><code>fun doDatabaseThings(driver: SqlDriver) {\n  val database = Database(driver)\n  val playerQueries: PlayerQueries = database.playerQueries\n\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\n  playerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\n  println(playerQueries.selectAll().executeAsList()) \n  // [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\n  val player = HockeyPlayer(10, \"Ronald McDonald\")\n  playerQueries.insertFullPlayerObject(player)\n}\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"native_sqlite/#reader-connection-pools","title":"Reader Connection Pools","text":"<p>Disk databases can (optionally) have multiple reader connections. To configure the reader pool, pass  the <code>maxReaderConnections</code> parameter to the various constructors of <code>NativeSqliteDriver</code>:</p> <pre><code>val driver: SqlDriver = NativeSqliteDriver(\n    Database.Schema, \n    \"test.db\", \n    maxReaderConnections = 4\n)\n</code></pre> <p>Reader connections are only used to run queries outside of a transaction. Any write calls, and  anything in a transaction, uses a single connection dedicated to transactions.</p>"},{"location":"native_sqlite/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact. Multiplatform support for AndroidX Paging is provided via Multiplatform Paging.</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:androidx-paging3-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <p>SQLDelight offers two methods for paging data \u2014 offset based paging and keyset paging.</p>"},{"location":"native_sqlite/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\n  countQuery = playerQueries.countPlayers(),\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  queryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"native_sqlite/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters \u2014 a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id \nFROM (\n  SELECT\n    id,\n    CASE\n      WHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\n      WHEN id = :anchor THEN 1\n      ELSE 0\n    END page_boundary;\n  FROM hockeyPlayer\n  ORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\n  transacter = playerQueries,\n  context = Dispatchers.IO,\n  pageBoundariesProvider = playerQueries::pageBoundaries,\n  queryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"native_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"native_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation(\"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\")\n  }\n}\n</code></pre> <pre><code>kotlin {\n  sourceSets.commonMain.dependencies {\n    implementation \"app.cash.sqldelight:coroutines-extensions:2.2.0-SNAPSHOT\"\n  }\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = \n  playerQueries.selectAll()\n    .asFlow()\n    .mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"native_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\n  mapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"native_sqlite/foreign_keys/","title":"Foreign Keys","text":"<p>You can enable foreign key constraints for the Native SQLite driver by enabling them in the database configuration.</p> <pre><code>NativeSqliteDriver(\n  schema = Database.Schema,\n  onConfiguration = { config: DatabaseConfiguration -&gt;\n    config.copy(\n      extendedConfig = DatabaseConfiguration.Extended(foreignKeyConstraints = true)\n    )\n  }\n)\n</code></pre>"},{"location":"native_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"native_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"native_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre> <pre><code>sqldelight {\n  databases {\n    MyDatabase {\n      // Database configuration here.\n    }\n  }\n}\n</code></pre>"},{"location":"native_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked. This adds the necessary metadata for linking sqlite when the project is compiled to a dynamic framework (which is the default in recent versions of KMP).</p> <p>Note that for a static framework, this flag has no effect. The XCode build that imports the project should add <code>-lsqlite3</code> to the linker flags. Alternatively add a project dependency on the sqlite3 pod via the cocoapods plugin. Another option that may work is adding <code>sqlite3</code> to the cocoapods <code>spec.libraries</code> setting e.g. in Gradle Kotlin DSL: <code>extraSpecAttributes[\"libraries\"] = \"'c++', 'sqlite3'\".</code></p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"native_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"native_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"native_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> KotlinGroovy <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"native_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> KotlinGroovy <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"native_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"native_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"native_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.2.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.2.0-SNAPSHOT'\n</code></pre>"},{"location":"native_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"native_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"native_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for use with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"native_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"native_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\n  databases {\n    create(\"MyDatabase\") {\n      packageName.set(\"com.example.projecta\")\n      dependency(project(\":ProjectB\"))\n    }\n  }\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\n  databases {\n    MyDatabase {\n      packageName = \"com.example.projecta\"\n      dependency project(\":ProjectB\")\n    }\n  }\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\n  databases {\n    // Same database name\n    create(\"MyDatabase\") {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\n  databases {\n    // Same database name\n    MyDatabase {\n      package = \"com.example.projectb\"\n    }\n  }\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"native_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\n  UPDATE myTable\n  SET column1 = :column1,\n      column2 = :column2\n  WHERE id = :id;\n\n  INSERT OR IGNORE INTO myTable (id, column1, column2)\n  VALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"native_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"native_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"native_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"native_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>A <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>check</code> task. For any <code>.db</code> file named <code>&lt;version number&gt;.db</code> in your SqlDelight source set (e.g. <code>src/main/sqldelight</code>) it will apply all migrations starting from <code>&lt;version number&gt;.sqm</code>, and confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generate&lt;source set name&gt;&lt;database name&gt;Schema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration. For example, if your project uses the <code>main</code> source set with a custom name of <code>\"MyDatabase\"</code>, you'll need to run the <code>generateMainMyDatabaseSchema</code> task.</p> <p>Most use cases would benefit from only having a <code>1.db</code> file representing the schema of the initial version of their database. Having multiple <code>.db</code> files is allowed, but that would result in each <code>.db</code> file having each of its migrations applied to it, which causes a lot of unnecessary work.</p>"},{"location":"native_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\n    driver = database,\n    oldVersion = 0,\n    newVersion = Database.Schema.version,\n    AfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"native_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"native_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"native_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"native_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"native_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"native_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\n  full_name = \"Rickard Rakell\",\n  number = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"native_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"native_sqlite/transactions/","title":"Transactions","text":""},{"location":"native_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\n  database.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"native_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback()\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\n  players.forEach { player -&gt;\n    if (player.number == 0) rollback(0)\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n  players.size\n}\n</code></pre>"},{"location":"native_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\n  afterRollback { log(\"No players were inserted.\") }\n  afterCommit { log(\"${players.size} players were inserted.\") }\n\n  players.forEach { player -&gt;\n    database.playerQueries.insert(\n      player_number = player.number,\n      full_name = player.fullName\n    )\n  }\n}\n</code></pre>"},{"location":"native_sqlite/types/","title":"Types","text":""},{"location":"native_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\n  some_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\n  some_double REAL,            -- Stored as REAL in db, retrieved as Double\n  some_string TEXT,            -- Stored as TEXT in db, retrieved as String\n  some_blob BLOB               -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"native_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\n  implementation(\"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\n  implementation \"app.cash.sqldelight:primitive-adapters:2.2.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"native_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\n  cup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\n  override fun decode(databaseValue: String) =\n    if (databaseValue.isEmpty()) {\n      listOf()\n    } else {\n      databaseValue.split(\",\")\n    }\n  override fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = hockeyPlayer.Adapter(\n    cup_winsAdapter = listOfStringsAdapter\n  )\n)\n</code></pre>"},{"location":"native_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\n  position TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\n  driver = driver,\n  hockeyPlayerAdapter = HockeyPlayer.Adapter(\n    positionAdapter = EnumColumnAdapter()\n  )\n)\n</code></pre>"},{"location":"native_sqlite/types/#value-types","title":"Value types","text":"<p>SQLDelight can generate a value type for a column which wraps the underlying database type if requested:</p> <pre><code>CREATE TABLE hockeyPlayer (\n  id INT AS VALUE\n);\n</code></pre>"}]}