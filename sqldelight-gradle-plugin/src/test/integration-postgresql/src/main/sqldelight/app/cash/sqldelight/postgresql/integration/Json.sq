CREATE TABLE TestJsonFunc(
    id INTEGER NOT NULL,
    t TEXT NOT NULL
);

CREATE TABLE TestJson(
  data JSON NOT NULL,
  datab JSONB NOT NULL,
  datac JSONB,
  datad TEXT[]
);

CREATE TABLE TestJsonCheck(
    data TEXT NOT NULL,
    js_1 JSON CHECK (js_1 -> 'scores' IS NOT NULL AND js_1 -> 'scores' IS JSON ARRAY),
    js_2 JSON CHECK ((js_2 -> 'scores'::TEXT) IS NOT NULL AND (js_2 -> 'scores'::TEXT) IS JSON ARRAY),
    js_3 JSON CHECK ((js_3 -> 'scores' IS JSON ARRAY) IS TRUE),
    js_4 JSON CHECK (pg_input_is_valid(js_4 ->> 'factor', 'double precision'))
);

insert:
INSERT INTO TestJson(data, datab) VALUES(
  json_build_object(:key, :value),
  jsonb_build_object('key', 'value')
);

setJsonb:
UPDATE TestJson
SET datab = jsonb_set(datab, :path, :newValue) RETURNING datab;

insertLiteral:
INSERT INTO TestJson(data, datab, datac, datad) VALUES (?, ?, ?, ?);

select:
SELECT *
FROM TestJson;

selectJsonObjectOperators:
SELECT data ->> 'a', datab -> 'b', data #> '{aa}', datab #>> '{bb}', datab - 'b'
FROM TestJson;

selectJsonArrayIndexOperators:
SELECT data -> 0, data ->> 1, data ->> 2, datab - 1
FROM TestJson;

selectJsonBooleanOperators:
SELECT datab @> datac, datac <@ datab, datab ?? 'b', datab ??| datad, datab ??& datad, datab @@ '$.b[*] > 0'
FROM TestJson;

selectJsonConcatOperators:
SELECT datab || datac
FROM TestJson;

selectJsonPretty:
SELECT jsonb_pretty(datab)
FROM TestJson;

selectJsonbPath:
SELECT *
FROM TestJson
WHERE datab @> ?;

selectJsonPathEquals:
SELECT *
FROM TestJson
WHERE data ->> 'a' = ? AND datab ->> 'b' = ?;

selectJsonbContains:
SELECT *
FROM TestJson
WHERE datab ?? ?;

insertJsonFunc:
INSERT INTO TestJsonFunc (id, t) VALUES (?, ?);

selectJsonFunc:
SELECT to_json(tjf), to_json(tjf.t), to_jsonb(tjf), row_to_json(tjf)
FROM TestJsonFunc tjf
WHERE tjf.id = ?;

selectJsonAgg:
SELECT json_agg(TestJsonFunc) FROM TestJsonFunc;

insertTestJsonCheck:
INSERT INTO TestJsonCheck (data, js_1, js_2, js_3, js_4)
VALUES ('{"scores": [1,2,3]}', '{"scores": [1,2,3]}', '{"scores": [1,2,3]}', '{"scores": [1,2,3]}', '{"scores": [1,2,3]}');

selectJsonChecks:
SELECT
  data IS NULL "null?",
  data IS NOT NULL "not null?",
  data IS JSON "json?",
  data IS JSON VALUE "value?",
  data IS NOT JSON "not json?",
  data IS JSON SCALAR "scalar?",
  data IS JSON OBJECT "object?",
  data IS NOT JSON OBJECT "not object?",
  data IS JSON ARRAY "array?",
  data IS JSON ARRAY WITH UNIQUE KEYS "array with unq key?",
  data IS JSON ARRAY WITHOUT UNIQUE KEYS "array without unq key?"
FROM TestJsonCheck
WHERE data IS NOT NULL;

selectJsonExtractionBinds:
SELECT 'abc', datab -> 'a' -> 'b' AS ab, datab -> 'a' || :json::JSONB AS abb
FROM TestJson;

selectJsonExtractionExistsBinds:
SELECT 'abc', datab -> 'a' -> ? AS b, data -> ? AS a
FROM TestJson
WHERE datab -> 'a' -> 'b' ?? :text::TEXT;

selectJsonExtractionContainsBinds:
SELECT datab
FROM TestJson
WHERE datab -> 'a' -> :key @> :contains::JSONB;

selectJsonAggFilterWhere:
SELECT json_agg(data) FILTER (WHERE (data->>'in_stock')::BOOLEAN) AS in_stock_rows
FROM TestJson;

selectJsonbAggFilter:
SELECT jsonb_agg(datab->'color') AS colors
FROM TestJson
WHERE datab ?? 'color';

selectJsonObjectAggFilterWhere:
SELECT json_object_agg(data->>'color', data) FILTER (WHERE (data->'size') IS NOT NULL)
FROM TestJson;

selectJsonbObjectAgg:
SELECT jsonb_object_agg(datab->>'color', datab)
FROM TestJson;
