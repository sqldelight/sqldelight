{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p>SQLDelight 2.0</p> <p>If you are currently using SQLDelight 1.x, check out the docs on upgrading to SQLDelight 2.0!</p> <p>SQLDelight generates typesafe Kotlin APIs from your SQL statements. It verifies your schema, statements, and migrations at compile-time and provides IDE features like autocomplete and refactoring which make writing and maintaining SQL simple.</p> <p>SQLDelight understands your existing SQL schema.</p> <pre><code>CREATE TABLE hockey_player (\nid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,\nname TEXT NOT NULL,\nnumber INTEGER NOT NULL\n);\n</code></pre> <p>It generates typesafe code for any labeled SQL statements.</p> <p></p>"},{"location":"#supported-dialects-and-platforms","title":"Supported Dialects and Platforms","text":"<p>SQLDelight supports a variety of SQL dialects and platforms.</p> <p> SQLite</p> <p> Android Native (iOS, macOS, Linux, Windows) JVM JavaScript (Browser) Multiplatform </p> <p> MySQL</p> <p> JVM (JDBC) JVM (R2DBC)  </p> <p> PostgresSQL</p> <p> JVM (JDBC) JVM (R2DBC) Native (macOS, Linux)</p> <p>HSQL / H2(Experimental)</p> <p> JVM (JDBC) JVM (R2DBC)  </p>"},{"location":"#snapshots","title":"Snapshots","text":"<p>Snapshots of the development version (including the IDE plugin zip) are available in Sonatype's <code>snapshots</code> repository. Note that all coordinates are app.cash.sqldelight instead of com.squareup.sqldelight for 2.0.0+ SNAPSHOTs.</p> <p>Documentation pages for the latest snapshot version can be found here.</p> KotlinGroovy <pre><code>// settings.gradle.kts\npluginManagement {\nrepositories {\ngradlePluginPortal()\nmaven(url = \"https://oss.sonatype.org/content/repositories/snapshots\")\n}\n}\n\n// build.gradle.kts\nplugins {\nid(\"app.cash.sqldelight\") version \"SNAPSHOT-VERSION\"\n}\n\nrepositories {\nmaven(url = \"https://oss.sonatype.org/content/repositories/snapshots\")\n}\n</code></pre> <pre><code>// settings.gradle\npluginManagement {\nrepositories {\ngradlePluginPortal()\nmaven { url \"https://oss.sonatype.org/content/repositories/snapshots\" }\n}\n}\n\n// build.gradle\nplugins {\nid \"app.cash.sqldelight\" version \"SNAPSHOT-VERSION\"\n}\n\nrepositories {\nmaven { url \"https://oss.sonatype.org/content/repositories/snapshots\" }\n}\n</code></pre> <p>Alpha IDE plugins are also available by using the alpha channel in IntelliJ: <code>https://plugins.jetbrains.com/plugins/alpha/com.squareup.sqldelight</code>. Snapshots are also available in the EAP channel: <code>https://plugins.jetbrains.com/plugins/eap/com.squareup.sqldelight</code> </p> <p></p>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"changelog/#200-alpha05-2023-01-20","title":"[2.0.0-alpha05] - 2023-01-20","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>[Paging] Multiplatform paging extension (by Jeff Lockhart)</li> <li>[Runtime] Add fun modifier to Listener interface.</li> <li>[SQLite Dialect] Add SQLite 3.33 support (UPDATE FROM) (by Eliezer Graber))</li> <li>[PostgreSQL Dialect] Support UPDATE FROM in postgresql (by Eliezer Graber))</li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>[RDBC Driver] Expose the connection (by Philip Wedemann)</li> <li>[Runtime] Move migration callbacks into main <code>migrate</code> fun</li> <li>[Gradle Plugin] Hide Configurations from downstream projects</li> <li>[Gradle Plugin] Only shade Intellij (by Philip Wedemann)</li> <li>[Gradle Plugin] Support Kotlin 1.8.0-Beta and add multi version Kotlin test (by Philip Wedemann)</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>[RDBC Driver] Use javaObjectType instead (by Philip Wedemann)</li> <li>[RDBC Driver] Fix primitive null values in bindStatement (by Philip Wedemann)</li> <li>[RDBC Driver] Support R2DBC 1.0 (by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Postgres: Fix Array without type parameter (by Philip Wedemann)</li> <li>[IDE Plugin] Bump intellij to 221.6008.13 (by Philip Wedemann)</li> <li>[Compiler] Resolve recursive origin table from pure views (by Philip Wedemann)</li> <li>[Compiler] Use value classes from table foreign key clause (by Philip Wedemann)</li> <li>[Compiler] Fix SelectQueryGenerator to support bind expression without parenthesis (by Doogie Min)</li> <li>[Compiler] Fix duplicate generation of ${name}Indexes variables when using transactions (by Andreas Sacher)</li> </ul>"},{"location":"changelog/#155-2023-01-20","title":"[1.5.5] - 2023-01-20","text":"<p>This is a compatibility release for Kotlin 1.8 and IntelliJ 2021+, supporting JDK 17.</p>"},{"location":"changelog/#154-2022-10-06","title":"[1.5.4] - 2022-10-06","text":"<p>This is a compatibility update for Kotlin 1.7.20 and AGP 7.3.0.</p>"},{"location":"changelog/#200-alpha04-2022-10-03","title":"[2.0.0-alpha04] - 2022-10-03","text":""},{"location":"changelog/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>The Paging 3 extension API has changed to only allow int types for the count.</li> <li>The coroutines extension now requires a dispatcher to be passed in instead of defaulting.</li> <li>Dialect and Driver classes are final, use delegation instead.</li> </ul>"},{"location":"changelog/#added_1","title":"Added","text":"<ul> <li>[HSQL Dialect] Hsql: Support using DEFAULT for generated columns in Insert (#3372 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] PostgreSQL: Support using DEFAULT for generated columns in INSERT  (#3373 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Add NOW() to PostgreSQL (#3403 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] PostgreSQL Add NOT operator (#3504 by Philip Wedemann)</li> <li>[Paging] Allow passing in CoroutineContext to *QueryPagingSource (#3384)</li> <li>[Gradle Plugin] Add better version catalog support for dialects (#3435)</li> <li>[Native Driver] Add callback to hook into DatabaseConfiguration creation of NativeSqliteDriver (#3512 by Sven Jacobs)</li> </ul>"},{"location":"changelog/#changed_1","title":"Changed","text":"<ul> <li>[Paging] Add a default dispatcher to the KeyedQueryPagingSource backed QueryPagingSource function (#3385)</li> <li>[Paging] Make OffsetQueryPagingSource only work with Int (#3386)</li> <li>[Async Runtime] Move await* to upper class ExecutableQuery (#3524 by Philip Wedemann)</li> <li>[Coroutines Extensions] Remove default params to flow extensions (#3489)</li> </ul>"},{"location":"changelog/#fixed_1","title":"Fixed","text":"<ul> <li>[Gradle Plugin] Update to Kotlin 1.7.20 (#3542 by Zac Sweers)</li> <li>[R2DBC Driver] Adopt R2DBC changes which do not always send a value (#3525 by Philip Wedemann)</li> <li>[HSQL Dialect] Fix failing sqlite VerifyMigrationTask with Hsql (#3380 by Philip Wedemann)</li> <li>[Gradle Plugin] Convert tasks to use lazy configuration API (by Matthew Haughton)</li> <li>[Gradle Plugin] Avoid NPEs in Kotlin 1.7.20 (#3398 by Zac Sweers)</li> <li>[Gradle Plugin] Fix description of squash migrations task (#3449)</li> <li>[IDE Plugin] Fix NoSuchFieldError in newer Kotlin plugins (#3422 by Madis Pink)</li> <li>[IDE Plugin] IDEA: UnusedQueryInspection - fix ArrayIndexOutOfBoundsException. (#3427 by Niklas Baudy)</li> <li>[IDE Plugin] Use reflection for old kotlin plugin references</li> <li>[Compiler] Custom dialect with extension function don't create imports (#3338 by Philip Wedemann)</li> <li>[Compiler] Fix escaping CodeBlock.of(\"${CodeBlock.toString()}\") (#3340 by Philip Wedemann)</li> <li>[Compiler] Await async execute statements in migrations (#3352)</li> <li>[Compiler] Fix AS (#3370 by Philip Wedemann)</li> <li>[Compiler] <code>getObject</code>  method supports automatic filling of the actual type. (#3401 by Rob X)</li> <li>[Compiler] Fix codegen for async grouped returning statements (#3411)</li> <li>[Compiler] Infer the Kotlin type of bind parameter, if possible, or fail with a better error message (#3413 by Philip Wedemann)</li> <li>[Compiler] Don't allow ABS(\"foo\") (#3430 by Philip Wedemann)</li> <li>[Compiler] Support inferring kotlin type from other parameters (#3431 by Philip Wedemann)</li> <li>[Compiler] Always create the database implementation (#3540 by Philip Wedemann)</li> <li>[Compiler] Relax javaDoc and add it to custom mapper function too (#3554 Philip Wedemann)</li> <li>[Compiler] Fix DEFAULT in binding (by Philip Wedemann)</li> <li>[Paging] Fix Paging 3 (#3396)</li> <li>[Paging] Allow construction of OffsetQueryPagingSource with Long (#3409)</li> <li>[Paging] Don't statically swap Dispatchers.Main (#3428)</li> </ul>"},{"location":"changelog/#200-alpha03-2022-06-17","title":"[2.0.0-alpha03] - 2022-06-17","text":""},{"location":"changelog/#breaking-changes_1","title":"Breaking Changes","text":"<ul> <li>Dialects are now references like actual gradle dependencies. <pre><code>sqldelight {\nMyDatabase {\ndialect(\"app.cash.sqldelight:postgres-dialect:2.0.0-alpha03\")\n}\n}\n</code></pre></li> <li>The <code>AfterVersionWithDriver</code> type was removed in favour of <code>AfterVersion</code> which now always has the driver.</li> <li>The <code>Schema</code> type is no longer a subtype of <code>SqlDriver</code></li> <li><code>PreparedStatement</code> APIs are now called with zero-based indexes.</li> </ul>"},{"location":"changelog/#added_2","title":"Added","text":"<ul> <li>[IDE Plugin] Added support for running SQLite, MySQL, and PostgreSQL commands against a running database (#2718 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add support for the android studio DB inspector (#3107 by Alexander Perfilyev)</li> <li>[Runtime] Add support for async drivers (#3168 by Derek Ellis)</li> <li>[Native Driver] Support new kotlin native memory model (#3177 by Kevin Galligan)</li> <li>[JS Driver] Add a driver for SqlJs workers (#3203 by Derek Ellis)</li> <li>[Gradle Plugin] Expose the classpath for SQLDelight tasks</li> <li>[Gradle Plugin] Add a gradle task for squashing migrations</li> <li>[Gradle Plugin] Add a flag to ignore schema definitions during migration checks</li> <li>[MySQL Dialect] Support FOR SHARE and FOR UPDATE in MySQL (#3098)</li> <li>[MySQL Dialect] Support MySQL index hints (#3099)</li> <li>[PostgreSQL Dialect] Add date_trunc (#3295 by Philip Wedemann)</li> <li>[JSON Extensions] Support JSON table functions (#3090)</li> </ul>"},{"location":"changelog/#changed_2","title":"Changed","text":"<ul> <li>[Runtime] Remove the AfterVersion type without the driver (#3091)</li> <li>[Runtime] Move Schema type to top-level</li> <li>[Runtime] Open dialect and resolver to support 3rd party implementations (#3232 by Philip Wedemann)</li> <li>[Compiler] Include the dialect used to compile in failure reports (#3086)</li> <li>[Compiler] Skip unused adapters (#3162 by Eliezer Graber)</li> <li>[Compiler] Use zero based index in PrepareStatement (#3269 by Philip Wedemann)</li> <li>[Gradle Plugin] Also make the dialect a proper gradle dependency instead of a string (#3085)</li> <li>[Gradle Plugin] Gradle Verify Task: Throw when missing database file. (#3126 by Niklas Baudy)</li> </ul>"},{"location":"changelog/#fixed_2","title":"Fixed","text":"<ul> <li>[Gradle Plugin] Minor cleanups and tweaks to the Gradle plugin (#3171 by Matthew Haughton)</li> <li>[Gradle Plugin] Dont use an AGP string for the generated directory</li> <li>[Gradle Plugin] Use AGP namespace attribute (#3220)</li> <li>[Gradle Plugin] Do not add kotlin-stdlib as a runtime dependency of the Gradle plugin (#3245 by [Martin Bonnin][mbonnin])</li> <li>[Gradle Plugin] Simplify the multiplatform configuration (#3246 by [Martin Bonnin][mbonnin])</li> <li>[Gradle Plugin] Support js only projects (#3310 by Philip Wedemann)</li> <li>[IDE Plugin] Use java home for gradle tooling API (#3078)</li> <li>[IDE Plugin] Load the JDBC driver on the correct classLoader inside the IDE plugin (#3080)</li> <li>[IDE Plugin] Mark the file element as null before invalidating to avoid errors during already existing PSI changes (#3082)</li> <li>[IDE Plugin] Dont crash finding usages of the new table name in an ALTER TABLE statement (#3106)</li> <li>[IDE Plugin] Optimize the inspectors and enable them to fail silently for expected exception types (#3121)</li> <li>[IDE Plugin] Delete files that should be generated directories (#3198)</li> <li>[IDE Plugin] Fix a not-safe operator call</li> <li>[Compiler] Ensure updates and deletes with RETURNING statements execute queries. (#3084)</li> <li>[Compiler] Correctly infer argument types in compound selects (#3096)</li> <li>[Compiler] Common tables do not generate data classes so dont return them (#3097)</li> <li>[Compiler] Find the top migration file faster (#3108)</li> <li>[Compiler] Properly inherit nullability on the pipe operator</li> <li>[Compiler] Support the iif ANSI SQL function</li> <li>[Compiler] Don't generate empty query files (#3300 by Philip Wedemann)</li> <li>[Compiler] Fix adapter with question mark only (#3314 by Philip Wedemann)</li> <li>[PostgreSQL Dialect] Postgres primary key columns are always non-null (#3092)</li> <li>[PostgreSQL Dialect] Fix copy with same name in multiple tables (#3297 by Philip Wedemann)</li> <li>[SQLite 3.35 Dialect] Only show an error when dropping an indexed column from the altered table (#3158 by Eliezer Graber)</li> </ul>"},{"location":"changelog/#200-alpha02-2022-04-13","title":"[2.0.0-alpha02] - 2022-04-13","text":""},{"location":"changelog/#breaking-changes_2","title":"Breaking Changes","text":"<ul> <li>You'll need to replace all occurrences of <code>app.cash.sqldelight.runtime.rx</code> with <code>app.cash.sqldelight.rx2</code></li> </ul>"},{"location":"changelog/#added_3","title":"Added","text":"<ul> <li>[Compiler] Support returning at the end of a grouped statement</li> <li>[Compiler] Support compiler extensions via dialect modules and add a SQLite JSON extension (#1379, #2087)</li> <li>[Compiler] Support PRAGMA statements which return a value (#1106)</li> <li>[Compiler] Support generating value types for marked columns</li> <li>[Compiler] Add support for optimistic locks and validation (#1952)</li> <li>[Compiler] Support multi-update statements</li> <li>[PostgreSQL] Support postgres returning statements</li> <li>[PostgreSQL] Support postgres date types</li> <li>[PostgreSQL] Support pg intervals</li> <li>[PostgreSQL] Support PG Booleans and fix inserts on alter tables</li> <li>[PostgreSQL] Support optional limits in Postgres</li> <li>[PostgreSQL] Support PG BYTEA type</li> <li>[PostgreSQL] Add a test for postgres serials</li> <li>[PostgreSQL] Support for update postgres syntax</li> <li>[PostgreSQL] Support PostgreSQL array types</li> <li>[PostgreSQL] Properly store/retrieve UUID types in PG</li> <li>[PostgreSQL] Support PostgreSQL NUMERIC type (#1882)</li> <li>[PostgreSQL] Support returning queries inside of common table expressions (#2471)</li> <li>[PostgreSQL] Support json specific operators</li> <li>[PostgreSQL] Add Postgres Copy (by Philip Wedemann)</li> <li>[MySQL] Support MySQL Replace</li> <li>[MySQL] Support NUMERIC/BigDecimal MySQL types (#2051)</li> <li>[MySQL] Support MySQL truncate statement</li> <li>[MySQL] Support json specific operators in Mysql (by Eliezer Graber)</li> <li>[MySQL] Support MySql INTERVAL (#2969 by Eliezer Graber)</li> <li>[HSQL] Add HSQL Window functionality</li> <li>[SQLite] Don't replace equality checks for nullable parameters in a WHERE (#1490 by Eliezer Graber)</li> <li>[SQLite] Support Sqlite 3.35 returning statements (#1490 by Eliezer Graber)</li> <li>[SQLite] Support GENERATED clause</li> <li>[SQLite] Add support for Sqlite 3.38 dialect (by Eliezer Graber)</li> </ul>"},{"location":"changelog/#changed_3","title":"Changed","text":"<ul> <li>[Compiler] Clean up generated code a bit</li> <li>[Compiler] Forbid usage of table parameters in grouped statements (#1822)</li> <li>[Compiler] Put grouped queries inside a transaction (#2785)</li> <li>[Runtime] Return the updated row count from the drivers execute method</li> <li>[Runtime] Confine SqlCursor to the critical section accessing the connection. (#2123 by Anders Ha)</li> <li>[Gradle Plugin] Compare schema definitions for migrations (#841)</li> <li>[PostgreSQL] Disallow double quotes for PG</li> <li>[MySQL] Error on usage of == in MySQL (#2673)</li> </ul>"},{"location":"changelog/#fixed_3","title":"Fixed","text":"<ul> <li>[Compiler] Same adapter type from different tables causing a compilation error in 2.0 alpha</li> <li>[Compiler] Problem compiling upsert statement (#2791)</li> <li>[Compiler] Query result should use tables in the select if there are multiple matches (#1874, #2313)</li> <li>[Compiler] Support updating a view which has a INSTEAD OF trigger (#1018)</li> <li>[Compiler] Support from and for in function names</li> <li>[Compiler] Allow SEPARATOR keyword in function expressions</li> <li>[Compiler] Cannot access ROWID of aliased table in ORDER BY</li> <li>[Compiler] Aliased column name is not recognized in HAVING clause in MySQL</li> <li>[Compiler] Erroneous 'Multiple columns found' error</li> <li>[Compiler] Unable to set PRAGMA locking_mode = EXCLUSIVE;</li> <li>[PostgreSQL] Postgresql rename column</li> <li>[MySQL] UNIX_TIMESTAMP, TO_SECONDS, JSON_ARRAYAGG MySQL functions not recognized</li> <li>[SQLite] fix SQLite window functionality</li> <li>[IDE Plugin] Run the goto handler in an empty progress indicator (#2990)</li> <li>[IDE Plugin] Ensure the highlight visitor doesnt run if the project isnt configured (#2981, #2976)</li> <li>[IDE Plugin] Ensure transitive generated code is also updated in the IDE (#1837)</li> <li>[IDE Plugin] Invalidate indexes when updating the dialect</li> </ul>"},{"location":"changelog/#200-alpha01-2022-03-31","title":"[2.0.0-alpha01] - 2022-03-31","text":"<p>This is the first alpha release for 2.0 and has some breaking changes. We expect more ABI breaking changes to come so don't publish any libraries with dependencies on this release (applications should be fine).</p>"},{"location":"changelog/#breaking-changes_3","title":"Breaking Changes","text":"<ul> <li>First, you'll need to replace all occurrences of <code>com.squareup.sqldelight</code> with <code>app.cash.sqldelight</code></li> <li>Second, you'll need to replace all occurrences of <code>app.cash.sqldelight.android</code> with <code>app.cash.sqldelight.driver.android</code></li> <li>Third, you'll need to replace all occurrences of <code>app.cash.sqldelight.sqlite.driver</code> with <code>app.cash.sqldelight.driver.jdbc.sqlite</code></li> <li>Fourth, you'll need to replace all occurrences of <code>app.cash.sqldelight.drivers.native</code> with <code>app.cash.sqldelight.driver.native</code></li> <li>The IDE plugin must be updated to a 2.X version, which can be found in the alpha or eap channel</li> <li>Dialects are now dependencies which you can specify within gradle:</li> </ul> <pre><code>sqldelight {\n  MyDatabase {\n    packageName = \"com.example\"\n    dialect = \"app.cash.sqldelight:mysql-dialect:2.0.0-alpha01\"\n  }\n}\n</code></pre> <p>The currently supported dialects are <code>mysql-dialect</code>, <code>postgresql-dialect</code>, <code>hsql-dialect</code>, <code>sqlite-3-18-dialect</code>, <code>sqlite-3-24-dialect</code>, <code>sqlite-3-25-dialect</code>, <code>sqlite-3-30-dialect</code>, and <code>sqlite-3-35-dialect</code></p> <ul> <li>Primitive types must now be imported (for example <code>INTEGER AS Boolean</code> you have to <code>import kotlin.Boolean</code>), some previously supported types now need an adapter. Primitive adapters are available in <code>app.cash.sqldelight:primitive-adapters:2.0.0-alpha01</code> for most conversions (like <code>IntColumnAdapter</code> for doing <code>Integer AS kotlin.Int</code>).</li> </ul>"},{"location":"changelog/#added_4","title":"Added","text":"<ul> <li>[IDE Plugin] Basic suggested migration (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add import hint action (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add kotlin class completion (by Alexander Perfilyev)</li> <li>[Gradle Plugin] Add shortcut for Gradle type safe project accessors (by Philip Wedemann)</li> <li>[Compiler] Customize codegen based on dialect (by Marius Volkhart)</li> <li>[JDBC Driver] Add common types to JdbcDriver (by Marius Volkhart)</li> <li>[SQLite] Add support for the sqlite 3.35 (by Eliezer Graber)</li> <li>[SQLite] Add support for ALTER TABLE DROP COLUMN (by Eliezer Graber)</li> <li>[SQLite] Add support for Sqlite 3.30 dialect (by Eliezer Graber)</li> <li>[SQLite] Support NULLS FIRST/LAST in sqlite (by Eliezer Graber)</li> <li>[HSQL] Add HSQL support for generated clause (by Marius Volkhart)</li> <li>[HSQL] Add support for named parameters in HSQL (by Marius Volkhart)</li> <li>[HSQL] Customize the HSQL insert query (by Marius Volkhart)</li> </ul>"},{"location":"changelog/#changed_4","title":"Changed","text":"<ul> <li>[Everything] Package name has changed from com.squareup.sqldelight to app.cash.sqldelight.</li> <li>[Runtime] Move dialects into their own isolated gradle modules</li> <li>[Runtime] Switch to driver-implemented query notifications.</li> <li>[Runtime] Extract default column adapters to separate module (#2056, #2060)</li> <li>[Compiler] Let modules generate the queries implementations instead of redoing it in each module</li> <li>[Compiler] Remove the custom toString generation of generated data classes. (by Paul Woitaschek)</li> <li>[JS Driver] Remove sql.js dependency from sqljs-driver (by Derek Ellis)</li> <li>[Paging] Remove the android paging 2 extension</li> <li>[IDE Plugin] Add an editor banner while SQLDelight is syncing (#2511)</li> <li>[IDE Plugin] Minimum supported IntelliJ version is 2021.1</li> </ul>"},{"location":"changelog/#fixed_4","title":"Fixed","text":"<ul> <li>[Runtime] Flatten listener list to reduce allocations and pointer chasing. (by Anders Ha)</li> <li>[IDE Plugin] Fix error message to allow jumping to error (by Philip Wedemann)</li> <li>[IDE Plugin] Add missing inspection descriptions (#2768 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix exception in GotoDeclarationHandler (#2531, #2688, #2804 by Alexander Perfilyev)</li> <li>[IDE Plugin] Highlight import keyword (by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix unresolved kotlin types (#1678 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix highlighting for unresolved package (#2543 by Alexander Perfilyev)</li> <li>[IDE Plugin] Dont attempt to inspect mismatched columns if the project index is not yet initialized</li> <li>[IDE Plugin] Dont initialize the file index until a gradle sync has occurred</li> <li>[IDE Plugin] Cancel the SQLDelight import if a gradle sync begins</li> <li>[IDE Plugin] Regenerate the database outside of the thread an undo action is performed on</li> <li>[IDE Plugin] If a reference cannot be resolves use a blank java type</li> <li>[IDE Plugin] Correctly move off the main thread during file parsing and only move back on to write</li> <li>[IDE Plugin] Improve compatibility with older IntelliJ versions (by Matthew Haughton)</li> <li>[IDE Plugin] Use faster annotation API</li> <li>[Gradle Plugin] Explicitly support js/android plugins when adding runtime (by Zac Sweers)</li> <li>[Gradle Plugin] Register migration output task without derviving schemas from migrations (#2744 by Kevin Cianfarini)</li> <li>[Gradle Plugin] If the migration task crashes, print the file it crashed running</li> <li>[Gradle Plugin] Sort files when generating code to ensure idempotent outputs (by Zac Sweers)</li> <li>[Compiler] Use faster APIs for iterating files and dont explore the entire PSI graph</li> <li>[Compiler] Add keyword mangling to select function parameters (#2759 by Alexander Perfilyev)</li> <li>[Compiler] Fix packageName for migration adapter (by Philip Wedemann)</li> <li>[Compiler] Emit annotations on properties instead of types (#2798 by Alexander Perfilyev)</li> <li>[Compiler] Sort arguments before passing to a Query subtype (#2379 by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#153-2021-11-23","title":"[1.5.3] - 2021-11-23","text":""},{"location":"changelog/#added_5","title":"Added","text":"<ul> <li>[JDBC Driver] Open JdbcDriver for 3rd party driver implementations (#2672 by Philip Wedemann)</li> <li>[MySQL Dialect] Add missing functions for time increments (#2671 by Sam Doward)</li> <li>[Coroutines Extension] Add M1 targets for coroutines-extensions (by Philip Dukhov)</li> </ul>"},{"location":"changelog/#changed_5","title":"Changed","text":"<ul> <li>[Paging3 Extension] Distribute sqldelight-android-paging3 as JAR instead of AAR (#2634 by Marco Romano)</li> <li>Property names which are also soft keywords will now be suffixed with underscores. For instance <code>value</code> will be exposed as <code>value_</code></li> </ul>"},{"location":"changelog/#fixed_5","title":"Fixed","text":"<ul> <li>[Compiler] Don't extract variables for duplicate array parameters (by Alexander Perfilyev)</li> <li>[Gradle Plugin] add kotlin.mpp.enableCompatibilityMetadataVariant. (#2628 by Martin Bonnin)</li> <li>[IDE Plugin] Find usages processing requires a read action</li> </ul>"},{"location":"changelog/#152-2021-10-12","title":"[1.5.2] - 2021-10-12","text":""},{"location":"changelog/#added_6","title":"Added","text":"<ul> <li>[Gradle Plugin] HMPP support (#2548 by Martin Bonnin)</li> <li>[IDE Plugin] Add NULL comparison inspection (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add inspection suppressor (#2519 by Alexander Perfilyev)</li> <li>[IDE Plugin] Mixed named and positional parameters inspection (by Alexander Perfilyev)</li> <li>[SQLite Driver] Add mingwX86 target. (#2558 by Nikita Kozhemyakin)</li> <li>[SQLite Driver] Add M1 targets</li> <li>[SQLite Driver] Add linuxX64 support (#2456 by Cedric Hippmann)</li> <li>[MySQL Dialect] Add ROW_COUNT function to mysql (#2523)</li> <li>[PostgreSQL Dialect] postgres rename, drop column (by Juan Liska)</li> <li>[PostgreSQL Dialect] PostgreSQL grammar doesn't recognize CITEXT</li> <li>[PostgreSQL Dialect] Include TIMESTAMP WITH TIME ZONE and TIMESTAMPTZ</li> <li>[PostgreSQL Dialect] Add grammar for PostgreSQL GENERATED columns</li> <li>[Runtime] Provide SqlDriver as a parameter to AfterVersion (#2534, 2614 by Ahmed El-Helw)</li> </ul>"},{"location":"changelog/#changed_6","title":"Changed","text":"<ul> <li>[Gradle Plugin] explicitely require Gradle 7.0 (#2572 by Martin Bonnin)</li> <li>[Gradle Plugin] Make VerifyMigrationTask support Gradle's up-to-date checks (#2533 by Matthew Haughton)</li> <li>[IDE Plugin] Don't warn with \"Join compares two columns of different types\" when joining nullable with non-nullable type (#2550 by Piotr Chmielowski)</li> <li>[IDE Plugin] Clarify the error for the lowercase 'as' in column type (by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#fixed_6","title":"Fixed","text":"<ul> <li>[IDE Plugin] Do not reparse under a new dialect if the project is already disposed (#2609)</li> <li>[IDE Plugin] If the associated virtual file is null, the module is null (#2607)</li> <li>[IDE Plugin] Avoid crashing during the unused query inspection (#2610)</li> <li>[IDE Plugin] Run the database sync write inside of a write action (#2605)</li> <li>[IDE Plugin] Let the IDE schedule SQLDelight syncronization</li> <li>[IDE Plugin] Fix npe in JavaTypeMixin (#2603 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix IndexOutOfBoundsException in MismatchJoinColumnInspection (#2602 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add description for UnusedColumnInspection (#2600 by Alexander Perfilyev)</li> <li>[IDE Plugin] Wrap PsiElement.generatedVirtualFiles into read action (#2599 by Alexander Perfilyev)</li> <li>[IDE Plugin] Remove unnecessary nonnull cast (#2596)</li> <li>[IDE Plugin] Properly handle nulls for find usages (#2595)</li> <li>[IDE Plugin] Fix IDE autocomplete for generated files for Android (#2573 by Martin Bonnin)</li> <li>[IDE Plugin] Fix npe in SqlDelightGotoDeclarationHandler (by Alexander Perfilyev)</li> <li>[IDE Plugin] Mangle kotlin keywords in arguments inside insert stmt (#2433 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix npe in SqlDelightFoldingBuilder (#2382 by Alexander Perfilyev)</li> <li>[IDE Plugin] Catch ClassCastException in CopyPasteProcessor (#2369 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix update live template (by Ilias Redissi)</li> <li>[IDE Plugin] Adds descriptions to intention actions (#2489 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix exception in CreateTriggerMixin if table is not found (by Alexander Perfilyev)</li> <li>[Compiler] Topologically sort table creation statemenets</li> <li>[Compiler] Stop invoking <code>forDatabaseFiles</code> callback on directories (#2532)</li> <li>[Gradle Plugin] Propagate generateDatabaseInterface task dependency to potential consumers (#2518 by Martin Bonnin)</li> </ul>"},{"location":"changelog/#151-2021-07-16","title":"[1.5.1] - 2021-07-16","text":""},{"location":"changelog/#added_7","title":"Added","text":"<ul> <li>[PostgreSQL Dialect] PostgreSQL JSONB and ON Conflict Do Nothing (by Andrew Stewart)</li> <li>[PostgreSQL Dialect] Adds support for PostgreSQL ON CONFLICT (column, ...) DO UPDATE (by Andrew Stewart)</li> <li>[MySQL Dialect] Support MySQL generated columns (by Jeff Gulbronson)</li> <li>[Native Driver] Add watchosX64 support</li> <li>[IDE Plugin] Add parameter types and annotations (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add action to generate 'select all' query (by Alexander Perfilyev)</li> <li>[IDE Plugin] Show column types in autocomplete (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add icons to autocomplete (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add action to generate 'select by primary key' query (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add action to generate 'insert into' query (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add highlighting for column names, stmt identifiers, function names (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add remaining query generation actions (#489 by Alexander Perfilyev)</li> <li>[IDE Plugin] Show parameter hints from insert-stmt (by Alexander Perfilyev)</li> <li>[IDE Plugin] Table alias intention action (by Alexander Perfilyev)</li> <li>[IDE Plugin] Qualify column name intention (by Alexander Perfilyev)</li> <li>[IDE Plugin] Go to declaration for kotlin property (by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#changed_7","title":"Changed","text":"<ul> <li>[Native Driver] Improve native transaction performance by avoiding freezing and shareable data structures when possible (by Anders Ha)</li> <li>[Paging 3] Bump Paging3 version to 3.0.0 stable</li> <li>[JS Driver] Upgrade sql.js to 1.5.0</li> </ul>"},{"location":"changelog/#fixed_7","title":"Fixed","text":"<ul> <li>[JDBC SQLite Driver] Call close() on connection before clearing the ThreadLocal (#2444 by Hannes Stru\u00df)</li> <li>[RX extensions] Fix subscription / disposal race leak (#2403 by Pierre Yves Ricau)</li> <li>[Coroutines extension] Ensure we register query listener before notifying</li> <li>[Compiler] Sort notifyQueries to have consistent kotlin output file (by Jiayu Chen)</li> <li>[Compiler] Don't annotate select query class properties with @JvmField (by Eliezer Graber)</li> <li>[IDE Plugin] Fix import optimizer (#2350 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix unused column inspection (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add nested classes support to import inspection and class annotator (by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix npe in CopyPasteProcessor (#2363 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix crash in InlayParameterHintsProvider (#2359 by Alexander Perfilyev)</li> <li>[IDE Plugin] Fix insertion of blank lines when copy-pasting any text into create table stmt (#2431 by Alexander Perfilyev)</li> </ul>"},{"location":"changelog/#150-2021-04-23","title":"[1.5.0] - 2021-04-23","text":""},{"location":"changelog/#added_8","title":"Added","text":"<ul> <li>[SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis)</li> <li>[Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini)</li> </ul>"},{"location":"changelog/#150-2021-04-23_1","title":"[1.5.0] - 2021-04-23","text":""},{"location":"changelog/#added_9","title":"Added","text":"<ul> <li>[SQLite Javascript Driver] Enable sqljs-driver publication (#1667 by Derek Ellis)</li> <li>[Paging3 Extension] Extension for Android Paging 3 Library (#1786 by Kevin Cianfarini)</li> <li>[MySQL Dialect] Adds support for mysql's ON DUPLICATE KEY UPDATE conflict resolution. (by Ryan Harter)</li> <li>[SQLite Dialect] Add compiler support for SQLite offsets() (by Quinton Roberts)</li> <li>[IDE Plugin] Add import quick fix for unknown type (#683 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add unused import inspection (#1161 by Alexander Perfilyev)</li> <li>[IDE Plugin] Add unused query inspection (by Alexander Perfilyev)</li> <li>[IDE Plugin] Add unused column inspection (#569 by Alexander Perfilyev)</li> <li>[IDE Plugin] Automatically bring imports on copy/paste (#684 by Alexander Perfilyev)</li> <li>[IDE Plugin] Pop a balloon when there are incompatibilities between gradle/intellij plugin versions</li> <li>[IDE Plugin] Insert Into ... VALUES(?) parameter hints (#506 by Alexander Perfilyev)</li> <li>[IDE Plugin] Inline parameter hints (by Alexander Perfilyev)</li> <li>[Runtime] Include an API in the runtime for running migrations with callbacks (#1844)</li> </ul>"},{"location":"changelog/#changed_8","title":"Changed","text":"<ul> <li>[Compiler] Smart cast \"IS NOT NULL\" queries (#867)</li> <li>[Compiler] Protect against keywords that will fail at runtime (#1471, #1629)</li> <li>[Gradle Plugin] Reduce size of gradle plugin from 60mb -&gt; 13mb.</li> <li>[Gradle Plugin] Properly support android variants, and remove support for KMM target-specific sql (#1039)</li> <li>[Gradle Plugin] Pick a minimum sqlite version based on minsdk (#1684)</li> <li>[Native Driver] Native driver connection pool and performance updates</li> </ul>"},{"location":"changelog/#fixed_8","title":"Fixed","text":"<ul> <li>[Compiler] NBSP before lambdas (by Beno\u00eet Quenaudon)</li> <li>[Compiler] Fix incompatible types in generated bind and cursor.get statements</li> <li>[Compiler] SQL clause should persist adapted type (#2067)</li> <li>[Compiler] Column with only NULL keyword should be nullable</li> <li>[Compiler] Dont generate mapper lambda with type annotations (#1957)</li> <li>[Compiler] If custom queries would clash, use the file name as an additional package suffix (#1057, #1278)</li> <li>[Compiler] Ensure foreign key cascades cause query listeners to be notified (#1325, #1485)</li> <li>[Compiler] If unioning two of the same type, return the table type (#1342)</li> <li>[Compiler] Ensure params to ifnull and coalesce can be nullable (#1263)</li> <li>[Compiler] Correctly use query-imposed nullability for expressions</li> <li>[MySQL Dialect] Support MySQL if statements</li> <li>[PostgreSQL Dialect] Retrieve NUMERIC and DECIMAL as Double in PostgreSQL (#2118)</li> <li>[SQLite Dialect] UPSERT notifications should account for BEFORE/AFTER UPDATE triggers. (#2198 by Anders Ha)</li> <li>[SQLite Driver] Use multiple connections for threads in the SqliteDriver unless we are in memory (#1832)</li> <li>[JDBC Driver] JDBC Driver assumes autoCommit is true (#2041)</li> <li>[JDBC Driver] Ensure that we close connections on exception (#2306)</li> <li>[IDE Plugin] Fix GoToDeclaration/FindUsages being broken on Windows due to path separator bug (#2054 by Angus Holder)</li> <li>[IDE Plugin] Ignore gradle errors instead of crashing in the IDE.</li> <li>[IDE Plugin] If a sqldelight file is moved to a non-sqldelight module, do not attempt codegen</li> <li>[IDE Plugin] Ignore codegen errors in IDE</li> <li>[IDE Plugin] Ensure that we dont try to negatively substring (#2068)</li> <li>[IDE Plugin] Also ensure project is not disposed before running gradle action (#2155)</li> <li>[IDE Plugin] Arithmetic on nullable types should also be nullable (#1853)</li> <li>[IDE Plugin] Make 'expand * intention' work with additional projections (#2173 by Alexander Perfilyev)</li> <li>[IDE Plugin] If kotlin resolution fails during GoTo, dont attempt to go to sqldelight files</li> <li>[IDE Plugin] If IntelliJ encounters an exception while sqldelight is indexing, dont crash</li> <li>[IDE Plugin] Handle exceptions that happen while detecting errors before codegen in the IDE</li> <li>[IDE Plugin] Make the IDE plugin compatible with Dynamic Plugins (#1536)</li> <li>[Gradle Plugin] Race condition generating a database using WorkerApi (#2062 by St\u00e9phane Nicolas)</li> <li>[Gradle Plugin] classLoaderIsolation prevents custom jdbc usage (#2048 by Ben Asher)</li> <li>[Gradle Plugin] Improve missing packageName error message (by Niklas Baudy)</li> <li>[Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998)</li> <li>[Gradle Plugin] Fix gradle build caching (#2075)</li> <li>[Gradle Plugin] Do not depend on kotlin-native-utils in Gradle plugin (by Ilya Matveev)</li> <li>[Gradle Plugin] Also write the database if there are only migration files (#2094)</li> <li>[Gradle Plugin] Ensure diamond dependencies only get picked up once in the final compilation unit (#1455)</li> </ul> <p>Also just a general shoutout to Matthew Haughton who did a lot of work to improve the SQLDelight infrastructure this release.</p>"},{"location":"changelog/#144-2020-10-08","title":"[1.4.4] - 2020-10-08","text":""},{"location":"changelog/#added_10","title":"Added","text":"<ul> <li>[PostgreSQL Dialect] Support data-modifying statements in WITH</li> <li>[PostgreSQL Dialect] Support substring function</li> <li>[Gradle Plugin] Added verifyMigrations flag for validating migrations during SQLDelight compilation (#1872)</li> </ul>"},{"location":"changelog/#changed_9","title":"Changed","text":"<ul> <li>[Compiler] Flag SQLite specific functions as unknown in non-SQLite dialects</li> <li>[Gradle Plugin] Provide a warning when the sqldelight plugin is applied but no databases are configured (#1421)</li> </ul>"},{"location":"changelog/#fixed_9","title":"Fixed","text":"<ul> <li>[Compiler] Report an error when binding a column name in an ORDER BY clause (#1187 by Eliezer Graber)</li> <li>[Compiler] Registry warnings appear when generating the db interface (#1792)</li> <li>[Compiler] Incorrect type inference for case statement (#1811)</li> <li>[Compiler] Provide better errors for migration files with no version (#2006)</li> <li>[Compiler] Required database type to marshal is incorrect for some database type ColumnAdapter's (#2012)</li> <li>[Compiler] Nullability of CAST (#1261)</li> <li>[Compiler] Lots of name shadowed warnings in query wrappers (#1946 by Eliezer Graber)</li> <li>[Compiler] Generated code is using full qualifier names (#1939)</li> <li>[IDE Plugin] Trigger sqldelight code gen from gradle syncs</li> <li>[IDE Plugin] Plugin not regenerating database interface when changing .sq files (#1945)</li> <li>[IDE Plugin] Issue when moving files to new packages (#444)</li> <li>[IDE Plugin] If theres nowhere to move the cursor, do nothing instead of crashing (#1994)</li> <li>[IDE Plugin] Use empty package name for files outside of a gradle project (#1973)</li> <li>[IDE Plugin] Fail gracefully for invalid types (#1943)</li> <li>[IDE Plugin] Throw a better error message when encountering an unknown expression (#1958)</li> <li>[Gradle Plugin] SQLDelight bleeds IntelliJ dependencies onto buildscript class path (#1998)</li> <li>[Gradle Plugin] \"JavadocIntegrationKt not found\" compilation error when adding method doc in *.sq file (#1982)</li> <li>[Gradle Plugin] SqlDeslight gradle plugin doesn't support Configuration Caching (CoCa). (#1947 by St\u00e9phane Nicolas)</li> <li>[SQLite JDBC Driver] SQLException: database in auto-commit mode (#1832)</li> <li>[Coroutines Extension] Fix IR backend for coroutines-extensions (#1918 by Derek Ellis)</li> </ul>"},{"location":"changelog/#143-2020-09-04","title":"[1.4.3] - 2020-09-04","text":""},{"location":"changelog/#added_11","title":"Added","text":"<ul> <li>[MySQL Dialect] Add support for MySQL last_insert_id function (by Kelvin Law)</li> <li>[PostgreSQL Dialect] Support SERIAL data type (by Veyndan Stuart &amp; Felipe Lima)</li> <li>[PostgreSQL Dialect] Support PostgreSQL RETURNING (by Veyndan Stuart)</li> </ul>"},{"location":"changelog/#fixed_10","title":"Fixed","text":"<ul> <li>[MySQL Dialect] Treat MySQL AUTO_INCREMENT as having a default value (#1823)</li> <li>[Compiler] Fix Upsert statement compiler error (#1809 by Eliezer Graber)</li> <li>[Compiler] Fix issue with invalid Kotlin being generated (#1925 by Eliezer Graber)</li> <li>[Compiler] Have a better error message for unknown functions (#1843)</li> <li>[Compiler] Expose string as the type for the second parameter of instr</li> <li>[IDE Plugin] Fix daemon bloat and UI thread stalling for IDE plugin (#1916)</li> <li>[IDE Plugin] Handle null module scenario (#1902)</li> <li>[IDE Plugin] In unconfigured sq files return empty string for the package name (#1920)</li> <li>[IDE Plugin] Fix grouped statements and add an integration test for them (#1820)</li> <li>[IDE Plugin] Use built in ModuleUtil to find the module for an element (#1854)</li> <li>[IDE Plugin] Only add valid elements to lookups (#1909)</li> <li>[IDE Plugin] Parent can be null (#1857)</li> </ul>"},{"location":"changelog/#142-2020-08-27","title":"[1.4.2] - 2020-08-27","text":""},{"location":"changelog/#added_12","title":"Added","text":"<ul> <li>[Runtime] Support new JS IR backend</li> <li>[Gradle Plugin] Add generateSqlDelightInterface Gradle task. (by Niklas Baudy)</li> <li>[Gradle Plugin] Add verifySqlDelightMigration Gradle task. (by Niklas Baudy)</li> </ul>"},{"location":"changelog/#fixed_11","title":"Fixed","text":"<ul> <li>[IDE Plugin] Use the gradle tooling API to facilitate data sharing between the IDE and gradle</li> <li>[IDE Plugin] Default to false for schema derivation</li> <li>[IDE Plugin] Properly retrieve the commonMain source set</li> <li>[MySQL Dialect] Added minute to mySqlFunctionType() (by MaaxGr)</li> </ul>"},{"location":"changelog/#141-2020-08-21","title":"[1.4.1] - 2020-08-21","text":""},{"location":"changelog/#added_13","title":"Added","text":"<ul> <li>[Runtime] Support Kotlin 1.4.0 (#1859)</li> </ul>"},{"location":"changelog/#changed_10","title":"Changed","text":"<ul> <li>[Gradle Plugin] Make AGP dependency compileOnly (#1362)</li> </ul>"},{"location":"changelog/#fixed_12","title":"Fixed","text":"<ul> <li>[Compiler] Add optional javadoc to column defintion rule and to table interface generator (#1224 by Daniel Eke)</li> <li>[SQLite Dialect] Add support for sqlite fts5 auxiliary functions highlight, snippet, and bm25 (by Daniel Rampelt)</li> <li>[MySQL Dialect] Support MySQL bit data type</li> <li>[MySQL Dialect] Support MySQL binary literals</li> <li>[PostgreSQL Dialect] Expose SERIAL from sql-psi (by Veyndan Stuart)</li> <li>[PostgreSQL Dialect] Add BOOLEAN data type (by Veyndan Stuart)</li> <li>[PostgreSQL Dialect] Add NULL column constraint (by Veyndan Stuart)</li> <li>[HSQL Dialect] Adds <code>AUTO_INCREMENT</code> support to HSQL (by Ryan Harter)</li> </ul>"},{"location":"changelog/#140-2020-06-22","title":"[1.4.0] - 2020-06-22","text":""},{"location":"changelog/#added_14","title":"Added","text":"<ul> <li>[MySQL Dialect] MySQL support (by Jeff Gulbronson &amp; Veyndan Stuart)</li> <li>[PostgreSQL Dialect] Experimental PostgreSQL support (by Veyndan Stuart)</li> <li>[HSQL Dialect] Experimental H2 support (by Marius Volkhart)</li> <li>[SQLite Dialect] SQLite FTS5 support (by Ben Asher &amp; James Palawaga)</li> <li>[SQLite Dialect] Support alter table rename column (#1505 by Angus Holder)</li> <li>[IDE] IDE support for migration (.sqm) files</li> <li>[IDE] Add SQLDelight Live Templates that mimic built-in SQL Live Templates (#1154 by Veyndan Stuart)</li> <li>[IDE] Add new SqlDelight file action (#42 by Roman Zavarnitsyn)</li> <li>[Runtime] transactionWithReturn API for transactions that return results</li> <li>[Compiler] Syntax for grouping multiple SQL statements together in a .sq file</li> <li>[Compiler] Support generating schemas from migration files</li> <li>[Gradle Plugin] Add a task for outputting migration files as valid sql</li> </ul>"},{"location":"changelog/#changed_11","title":"Changed","text":"<ul> <li>[Documentation] Overhaul of the documentation website (by Saket Narayan)</li> <li>[Gradle Plugin] Improve unsupported dialect error message (by Veyndan Stuart)</li> <li>[IDE] Dynamically change file icon based on dialect (by Veyndan Stuart)</li> <li>[JDBC Driver] Expose a JdbcDriver constructor off of javax.sql.DataSource (#1614)</li> </ul>"},{"location":"changelog/#fixed_13","title":"Fixed","text":"<ul> <li>[Compiler]Support Javadoc on tables and fix multiple javadoc in one file (#1224)</li> <li>[Compiler] Enable inserting a value for synthesized columns (#1351)</li> <li>[Compiler] Fix inconsistency in directory name sanitizing (by Zac Sweers)</li> <li>[Compiler] Synthesized columns should retain nullability across joins (#1656)</li> <li>[Compiler] Pin the delete statement on the delete keyword (#1643)</li> <li>[Compiler] Fix quoting (#1525 by Angus Holder)</li> <li>[Compiler] Fix the between operator to properly recurse into expressions (#1279)</li> <li>[Compiler] Give better error for missing table/column when creating an index (#1372)</li> <li>[Compiler] Enable using the outer querys projection in join constraints (#1346)</li> <li>[Native Driver] Make execute use transationPool (by Ben Asher)</li> <li>[JDBC Driver] Use the jdbc transaction APIs instead of sqlite (#1693)</li> <li>[IDE] Fix virtualFile references to always be the original file (#1782)</li> <li>[IDE] Use the correct throwable when reporting errors to bugsnag (#1262)</li> <li>[Paging Extension] Fix leaky DataSource (#1628)</li> <li>[Gradle Plugin] If the output db file already exists when generating a schema, delete it (#1645)</li> <li>[Gradle Plugin] Fail migration validation if there are gaps</li> <li>[Gradle Plugin] Explicitely use the file index we set (#1644)</li> </ul>"},{"location":"changelog/#130-2020-04-03","title":"[1.3.0] - 2020-04-03","text":"<ul> <li>New: [Gradle] Dialect property to specify with sql dialect to compile against.</li> <li>New: [Compiler] #1009 Experimental support of the mysql dialect.</li> <li>New: [Compiler] #1436 Support of sqlite:3.24 dialect and upsert.</li> <li>New: [JDBC Driver] Split out JDBC driver from sqlite jvm driver.</li> <li>Fix: [Compiler] #1199 Support lambdas of any length.</li> <li>Fix: [Compiler] #1610 Fix the return type of avg() to be nullable.</li> <li>Fix: [IntelliJ] #1594 Fix path separator handling which broke Goto and Find Usages on Windows.</li> </ul>"},{"location":"changelog/#122-2020-01-22","title":"[1.2.2] - 2020-01-22","text":"<ul> <li>New: [Runtime] Support for Windows (mingW), tvOS, watchOS, and macOS architectures.</li> <li>Fix: [Compiler] Return type of sum() should be nullable.</li> <li>Fix: [Paging] Pass Transacter into QueryDataSourceFactory to avoid race conditions.</li> <li>Fix: [IntelliJ Plugin] Don't search through dependencies when looking for a file's package name.</li> <li>Fix: [Gradle] #862 Change validator logs in Gradle to debug level.</li> <li>Enhancement: [Gradle] Convert GenerateSchemaTask to use Gradle worker.</li> <li>Note: sqldelight-runtime artifact renamed to runtime.</li> </ul>"},{"location":"changelog/#121-2019-12-11","title":"[1.2.1] - 2019-12-11","text":"<ul> <li>Fix: [Gradle] Kotlin Native 1.3.60 support.</li> <li>Fix: [Gradle] #1287 Warning when syncing.</li> <li>Fix: [Compiler] #1469 SynetheticAccessor creation for query.</li> <li>Fix: [JVM Driver] Fixed memory leak.</li> <li>NOTE: The coroutine extension artifact requires kotlinx bintray maven repository be added to your buildscript.</li> </ul>"},{"location":"changelog/#120-2019-08-30","title":"[1.2.0] - 2019-08-30","text":"<ul> <li>New: [Runtime] Stable Flow api.</li> <li>Fix: [Gradle] Kotlin Native 1.3.50 support.</li> <li>Fix: [Gradle] #1380 Clean build sometimes fails.</li> <li>Fix: [Gradle] #1348 Running verify tasks prints \"Could not retrieve functions\".</li> <li>Fix: [Compile] #1405 Can't build project if query contains FTS table joined.</li> <li>Fix: [Gradle] #1266 Sporadic gradle build failure while having multiple database modules.</li> </ul>"},{"location":"changelog/#114-2019-07-11","title":"[1.1.4] - 2019-07-11","text":"<ul> <li>New: [Runtime] Experimental kotlin Flow api.</li> <li>Fix: [Gradle] Kotlin/Native 1.3.40 compatibility.</li> <li>Fix: [Gradle] #1243 Fix for usage of SQLDelight with Gradle configure on demand.</li> <li>Fix: [Gradle] #1385 Fix for usage of SQLDelight with incremental annotation processing.</li> <li>Fix: [Gradle] Allow gradle tasks to cache.</li> <li>Fix: [Gradle] #1274 Enable usage of sqldelight extension with kotlin dsl.</li> <li>Fix: [Compiler] Unique ids are generated for each query deterministically.</li> <li>Fix: [Compiler] Only notify listening queries when a transaction is complete.</li> <li>Fix: [JVM Driver] #1370 Force JdbcSqliteDriver users to supply a DB URL.</li> </ul>"},{"location":"changelog/#113-2019-04-14","title":"[1.1.3] - 2019-04-14","text":"<ul> <li>Gradle Metadata 1.0 release.</li> </ul>"},{"location":"changelog/#112-2019-04-14","title":"[1.1.2] - 2019-04-14","text":"<ul> <li>New: [Runtime] #1267 Logging driver decorator.</li> <li>Fix: [Compiler] #1254 Split string literals which are longer than 2^16 characters.</li> <li>Fix: [Gradle] #1260 generated sources are recognized as iOS source in Multiplatform Project.</li> <li>Fix: [IDE] #1290 kotlin.KotlinNullPointerException in CopyAsSqliteAction.kt:43.</li> <li>Fix: [Gradle] #1268 Running linkDebugFrameworkIos* tasks fail in recent versions.</li> </ul>"},{"location":"changelog/#111-2019-03-01","title":"[1.1.1] - 2019-03-01","text":"<ul> <li>Fix: [Gradle] Fix module dependency compilation for android projects.</li> <li>Fix: [Gradle] #1246 Set up api dependencies in afterEvaluate.</li> <li>Fix: [Compiler] Array types are properly printed.</li> </ul>"},{"location":"changelog/#110-2019-02-27","title":"[1.1.0] - 2019-02-27","text":"<ul> <li>New: [Gradle] #502 Allow specifying schema module dependencies.</li> <li>Enhancement: [Compiler] #1111 Table errors are sorted before other errors.</li> <li>Fix: [Compiler] #1225 Return the correct type for REAL literals.</li> <li>Fix: [Compiler] #1218 docid propagates through triggers.</li> </ul>"},{"location":"changelog/#103-2019-01-30","title":"[1.0.3] - 2019-01-30","text":"<ul> <li>Enhancement: [Runtime] #1195 Native Driver/Runtime Arm32.</li> <li>Enhancement: [Runtime] #1190 Expose the mapper from the Query type.</li> </ul>"},{"location":"changelog/#102-2019-01-26","title":"[1.0.2] - 2019-01-26","text":"<ul> <li>Fix: [Gradle Plugin] Update to kotlin 1.3.20.</li> <li>Fix: [Runtime] Transactions no longer swallow exceptions.</li> </ul>"},{"location":"changelog/#101-2019-01-21","title":"[1.0.1] - 2019-01-21","text":"<ul> <li>Enhancement: [Native Driver] Allow passing directory name to DatabaseConfiguration.</li> <li>Enhancement: [Compiler] #1173 Files without a package fail compilation.</li> <li>Fix: [IDE] Properly report IDE errors to Square.</li> <li>Fix: [IDE] #1162 Types in the same package show as error but work fine.</li> <li>Fix: [IDE] #1166 Renaming a table fails with NPE.</li> <li>Fix: [Compiler] #1167 Throws an exception when trying to parse complex SQL statements with UNION and SELECT.</li> </ul>"},{"location":"changelog/#100-2019-01-08","title":"[1.0.0] - 2019-01-08","text":"<ul> <li>New: Complete overhaul of generated code, now in kotlin.</li> <li>New: RxJava2 extensions artifact.</li> <li>New: Android Paging extensions artifact.</li> <li>New: Kotlin Multiplatform support.</li> <li>New: Android, iOS and JVM SQLite driver artifacts.</li> <li>New: Transaction API.</li> </ul>"},{"location":"changelog/#070-2018-02-12","title":"[0.7.0] - 2018-02-12","text":"<ul> <li>New: Generated code has been updated to use the Support SQLite library only. All queries now generate statement objects instead of a raw strings.</li> <li>New: Statement folding in the IDE.</li> <li>New: Boolean types are now automatically handled.</li> <li>Fix: Remove deprecated marshals from code generation.</li> <li>Fix: Correct 'avg' SQL function type mapping to be REAL.</li> <li>Fix: Correctly detect 'julianday' SQL function.</li> </ul>"},{"location":"changelog/#061-2017-03-22","title":"[0.6.1] - 2017-03-22","text":"<ul> <li>New: Delete Update and Insert statements without arguments get compiled statements generated.</li> <li>Fix: Using clause within a view used in a subquery doesn't error.</li> <li>Fix: Duplicate types on generated Mapper removed.</li> <li>Fix: Subqueries can be used in expressions that check against arguments.</li> </ul>"},{"location":"changelog/#060-2017-03-06","title":"[0.6.0] - 2017-03-06","text":"<ul> <li>New: Select queries are now exposed as a <code>SqlDelightStatement</code> factory instead of string constants.</li> <li>New: Query JavaDoc is now copied to statement and mapper factories.</li> <li>New: Emit string constants for view names.</li> <li>Fix: Queries on views which require factories now correctly require those factories are arguments.</li> <li>Fix: Validate the number of arguments to an insert matches the number of columns specified.</li> <li>Fix: Properly encode blob literals used in where clauses.</li> <li>Gradle 3.3 or newer is required for this release.</li> </ul>"},{"location":"changelog/#051-2016-10-24","title":"[0.5.1] - 2016-10-24","text":"<ul> <li>New: Compiled statements extend an abstract type.</li> <li>Fix: Primitive types in parameters will be boxed if nullable.</li> <li>Fix: All required factories for bind args are present in factory method.</li> <li>Fix: Escaped column names are marshalled correctly.</li> </ul>"},{"location":"changelog/#050-2016-10-19","title":"[0.5.0] - 2016-10-19","text":"<ul> <li>New: SQLite arguments can be passed typesafely through the Factory</li> <li>New: IntelliJ plugin performs formatting on .sq files</li> <li>New: Support for SQLite timestamp literals</li> <li>Fix: Parameterized types can be clicked through in IntelliJ</li> <li>Fix: Escaped column names no longer throw RuntimeExceptions if grabbed from Cursor.</li> <li>Fix: Gradle plugin doesn't crash trying to print exceptions.</li> </ul>"},{"location":"changelog/#044-2016-07-20","title":"[0.4.4] - 2016-07-20","text":"<ul> <li>New: Native support for shorts as column java type</li> <li>New: Javadoc on generated mappers and factory methods</li> <li>Fix: group_concat and nullif functions have proper nullability</li> <li>Fix: Compatibility with Android Studio 2.2-alpha</li> <li>Fix: WITH RECURSIVE no longer crashes plugin</li> </ul>"},{"location":"changelog/#043-2016-07-07","title":"[0.4.3] - 2016-07-07","text":"<ul> <li>New: Compilation errors link to source file.</li> <li>New: Right-click to copy SQLDelight code as valid SQLite.</li> <li>New: Javadoc on named statements will appear on generated Strings.</li> <li>Fix: Generated view models include nullability annotations.</li> <li>Fix: Generated code from unions has proper type and nullability to support all possible columns.</li> <li>Fix: sum and round SQLite functions have proper type in generated code.</li> <li>Fix: CAST's, inner selects bugfixes.</li> <li>Fix: Autocomplete in CREATE TABLE statements.</li> <li>Fix: SQLite keywords can be used in packages.</li> </ul>"},{"location":"changelog/#042-2016-06-16","title":"[0.4.2] - 2016-06-16","text":"<ul> <li>New: Marshal can be created from the factory.</li> <li>Fix: IntelliJ plugin generates factory methods with proper generic order.</li> <li>Fix: Function names can use any casing.</li> </ul>"},{"location":"changelog/#041-2016-06-14","title":"[0.4.1] - 2016-06-14","text":"<ul> <li>Fix: IntelliJ plugin generates classes with proper generic order.</li> <li>Fix: Column definitions can use any casing.</li> </ul>"},{"location":"changelog/#040-2016-06-14","title":"[0.4.0] - 2016-06-14","text":"<ul> <li>New: Mappers are generated per query instead of per table.</li> <li>New: Java types can be imported in .sq files.</li> <li>New: SQLite functions are validated.</li> <li>Fix: Remove duplicate errors.</li> <li>Fix: Uppercase column names and java keyword column names do not error.</li> </ul>"},{"location":"changelog/#032-2016-05-14","title":"[0.3.2] - 2016-05-14","text":"<ul> <li>New: Autocompletion and find usages now work for views and aliases.</li> <li>Fix: Compile-time validation now allows functions to be used in selects.</li> <li>Fix: Support insert statements which only declare default values.</li> <li>Fix: Plugin no longer crashes when a project not using SQLDelight is imported.</li> </ul>"},{"location":"changelog/#031-2016-04-27","title":"[0.3.1] - 2016-04-27","text":"<ul> <li>Fix: Interface visibility changed back to public to avoid Illegal Access runtime exceptions from method references.</li> <li>Fix: Subexpressions are evaluated properly.</li> </ul>"},{"location":"changelog/#030-2016-04-26","title":"[0.3.0] - 2016-04-26","text":"<ul> <li>New: Column definitions use SQLite types and can have additional 'AS' constraint to specify java type.</li> <li>New: Bug reports can be sent from the IDE.</li> <li>Fix: Autocomplete functions properly.</li> <li>Fix: SQLDelight model files update on .sq file edit.</li> <li>Removed: Attached databases no longer supported.</li> </ul>"},{"location":"changelog/#022-2016-03-07","title":"[0.2.2] - 2016-03-07","text":"<ul> <li>New: Compile-time validation of the columns used by insert, update, delete, index, and trigger statements.</li> <li>Fix: Don't crash IDE plugin on file move/create.</li> </ul>"},{"location":"changelog/#021-2016-03-07","title":"[0.2.1] - 2016-03-07","text":"<ul> <li>New: Ctrl+<code>/</code> (Cmd+<code>/</code> on OSX) toggles comment of the selected line(s).</li> <li>New: Compile-time validation of the columns used by SQL queries.</li> <li>Fix: Support Windows paths in both the IDE and Gradle plugin.</li> </ul>"},{"location":"changelog/#020-2016-02-29","title":"[0.2.0] - 2016-02-29","text":"<ul> <li>New: Added copy constructor to Marshal class.</li> <li>New: Update to Kotlin 1.0 final.</li> <li>Fix: Report 'sqldelight' folder structure problems in a non-failing way.</li> <li>Fix: Forbid columns named <code>table_name</code>. Their generated constant clashes with the table name constant.</li> <li>Fix: Ensure IDE plugin generates model classes immediately and regardless of whether <code>.sq</code> files were opened.</li> <li>Fix: Support Windows paths in both the IDE and Gradle plugin.</li> </ul>"},{"location":"changelog/#012-2016-02-13","title":"[0.1.2] - 2016-02-13","text":"<ul> <li>Fix: Remove code which prevented the Gradle plugin from being used in most projects.</li> <li>Fix: Add missing compiler dependency on the Antlr runtime.</li> </ul>"},{"location":"changelog/#011-2016-02-12","title":"[0.1.1] - 2016-02-12","text":"<ul> <li>Fix: Ensure the Gradle plugin points to the same version of the runtime as itself.</li> </ul>"},{"location":"changelog/#010-2016-02-12","title":"[0.1.0] - 2016-02-12","text":"<p>Initial release.</p>"},{"location":"code_of_conduct/","title":"Open Source Code of Conduct","text":"<p>At Square, we are committed to contributing to the open source community and simplifying the process of releasing and managing open source software. We\u2019ve seen incredible support and enthusiasm from thousands of people who have already contributed to our projects\u200a\u2014\u200aand we want to ensure our community continues to be truly open for everyone.</p> <p>This code of conduct outlines our expectations for participants, as well as steps to reporting unacceptable behavior. We are committed to providing a welcoming and inspiring community for all and expect our code of conduct to be honored.</p> <p>Square\u2019s open source community strives to:</p> <ul> <li> <p>Be open: We invite anyone to participate in any aspect of our projects. Our community is    open, and any responsibility can be carried by a contributor who demonstrates the required    capacity and competence.</p> </li> <li> <p>Be considerate: People use our work, and we depend on the work of others. Consider users and    colleagues before taking action. For example, changes to code, infrastructure, policy, and    documentation may negatively impact others.</p> </li> <li> <p>Be respectful: We expect people to work together to resolve conflict, assume good intentions,    and act with empathy. Do not turn disagreements into personal attacks.</p> </li> <li> <p>Be collaborative: Collaboration reduces redundancy and improves the quality of our work. We    strive for transparency within our open source community, and we work closely with upstream    developers and others in the free software community to coordinate our efforts.</p> </li> <li> <p>Be pragmatic: Questions are encouraged and should be asked early in the process to avoid    problems later. Be thoughtful and considerate when seeking out the appropriate forum for your    questions. Those who are asked should be responsive and helpful.</p> </li> <li> <p>Step down considerately: Members of every project come and go. When somebody leaves or    disengages from the project, they should make it known and take the proper steps to ensure that    others can pick up where they left off.</p> </li> </ul> <p>This code is not exhaustive or complete. It serves to distill our common understanding of a collaborative, shared environment, and goals. We expect it to be followed in spirit as much as in the letter.</p>"},{"location":"code_of_conduct/#diversity-statement","title":"Diversity Statement","text":"<p>We encourage everyone to participate and are committed to building a community for all. Although we may not be able to satisfy everyone, we all agree that everyone is equal.</p> <p>Whenever a participant has made a mistake, we expect them to take responsibility for it. If someone has been harmed or offended, it is our responsibility to listen carefully and respectfully, and do our best to right the wrong.</p> <p>Although this list cannot be exhaustive, we explicitly honor diversity in age, culture, ethnicity, gender identity or expression, language, national origin, political beliefs, profession, race, religion, sexual orientation, socioeconomic status, and technical ability. We will not tolerate discrimination based on any of the protected characteristics above, including participants with disabilities.</p>"},{"location":"code_of_conduct/#reporting-issues","title":"Reporting Issues","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. For more details, please see our Reporting Guidelines below.</p>"},{"location":"code_of_conduct/#thanks","title":"Thanks","text":"<p>Some of the ideas and wording for the statements and guidelines above were based on work by the Twitter, Ubuntu, GDC, and Django communities. We are thankful for their work.</p>"},{"location":"code_of_conduct/#reporting-guide","title":"Reporting Guide","text":"<p>If you experience or witness unacceptable behavior\u200a\u2014\u200aor have any other concerns\u200a\u2014\u200aplease report it by emailing codeofconduct@squareup.com. All reports will be handled with discretion.</p> <p>In your report please include:</p> <ul> <li>Your contact information.</li> <li>Names (real, nicknames, or pseudonyms) of any individuals involved. If there are additional    witnesses, please include them as well.</li> <li>Your account of what occurred, and if you believe the incident is ongoing. If there is a publicly    available record (e.g. a mailing list archive or a public IRC logger), please include a link.</li> <li>Any additional information that may be helpful.</li> </ul> <p>After filing a report, a representative from the Square Code of Conduct committee will contact you personally. The committee will then review the incident, follow up with any additional questions, and make a decision as to how to respond.</p> <p>Anyone asked to stop unacceptable behavior is expected to comply immediately. If an individual engages in unacceptable behavior, the Square Code of Conduct committee may take any action they deem appropriate, up to and including a permanent ban from all of Square spaces without warning.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>If you would like to contribute code to this project you can do so through GitHub by forking the repository and sending a pull request.</p> <p>When submitting code, please make every effort to follow existing conventions and style in order to keep the code as readable as possible.</p> <p>Before your code can be accepted into the project you must also sign the Individual Contributor License Agreement (CLA).</p>"},{"location":"contributing/#sqldelight","title":"SQLDelight","text":"<p>If you're looking to get started with contributing, look below for specific guides depending on which part of SQLDelight you'd like to contribute to. If you're still unsure, comment in the issue you're looking in to with where you're getting stuck and we'll respond there - or create an issue for the thing you're trying to do and start the discussion.</p>"},{"location":"contributing/#ide-plugin","title":"IDE Plugin","text":"<p>If you want to fix a bug or extend the IDE, code changes will likely happen in the <code>sqldelight-idea-plugin</code> module. You can test your changes using the <code>./gradlew runIde</code> task and you can live debug using <code>./gradlew runIde --debug-jvm</code>.</p> <p>If you're encountering a bug in the IDE but cannot reproduce it in a sample project, you can live debug your IDE. You'll need a second installation of IntelliJ to do this. You can use Toolbox to do this by scrolling to the bottom of the IDE list and selecting a different version of IntelliJ.</p> <p>In the IDE you'd like to use the debugger in, check out the SQLDelight repo and then create a new <code>Remote</code> Run Configuration. It will already populate \"Command line arguments for remote JVM\", something like <code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=5005</code>. Copy that value, then open the IDE you would like to debug. Select <code>Help -&gt; Edit Custom VM Options</code>, and paste the line you copied to the bottom of the file that is opened. Restart the IDE you want to debug, then once it's started up open the IDE you created the configuration in, and attach the debugger using the remote configuration you created.</p> <p>For more information on building IDE plugins and features for them see the Official Jetbrains Documentation or join the Jetbrains Platform Slack.</p>"},{"location":"contributing/#drivers","title":"Drivers","text":"<p>If you're interested in creating your own driver, you can do so outside of the SQLDelight repository using the <code>runtime</code> artifact. To test the driver you can depend on the <code>driver-test</code> and extend <code>DriverTest</code> and <code>TransactionTest</code> to ensure it works as SQLDelight would expect.</p>"},{"location":"contributing/#asynchronous-drivers","title":"Asynchronous Drivers","text":"<p>Drivers that make asynchronous calls can be implemented by using the <code>runtime-async</code> artifact. </p>"},{"location":"contributing/#gradle","title":"Gradle","text":"<p>If you're encountering a gradle issue, start by creating a test fixture in <code>sqldelight-gradle-plugin/src/test</code> similar to the other folders there which reproduces your issue. Feel free to just open a PR with this failing test if you don't know how to fix! Test cases are greatly appreciated. The integration tests show how to set up an entire gradle project which will run SQLite/MySQL/PostgreSQL/etc and execute SQL queries using their respective runtime environments and SQLDelight. Consider adding a test to these already existing integration tests if you're encountering runtime issues in SQLDelight.</p>"},{"location":"contributing/#compiler","title":"Compiler","text":"<p>There are many layers to SQLDelight's compiler - if you are strictly interested in the codegen (and not the parsing of SQL) then you will want to make your contributions in the <code>sqldelight-compiler</code> module. If you are interested in the parser you'll need to contribute to sql-psi. SQLDelight uses kotlinpoet for generating kotlin code, be sure to use it's APIs for referencing kotlin types so imports still work correctly. If you modify the codegen in any way, run a <code>./gradlew build</code> before opening a pull request, as it will update the integration test in <code>sqldelight-compiler:integration-tests</code>. If you'd like to write an integration test (meaning running SQL queries in a runtime environment), add a test to <code>sqldelight-compiler:integration-tests</code>.</p>"},{"location":"contributing/#sql-psi","title":"SQL PSI","text":"<p>In the next section we will go through how to contribute to the parser and PSI layer, but before doing that you should read a blog post on multiple dialects to understand the various moving pieces in sql-psi. As with SQLDelight, if you're encountering an issue but don't know how to contribute a fix or need assistance, comment in the GitHub issue or create a new one to start the discussion.</p> <p>For any changes in SQL-PSI, you will want to add a test fixture in the corresponding <code>core/src/test/fixtures_*</code> folder. The <code>fixtures</code> folder (no suffix) runs for all dialects. After your change has been merged to sql-psi, if there are changes you also need to make in SQLDelight, check out the  <code>sql-psi-dev</code> branch on SQLDelight and target it with your PR. It uses the snapshot releases of sql-psi so you can build your SQLDelight change roughly 10 minutes after the sql-psi change has been merged.</p>"},{"location":"contributing/#grammar","title":"Grammar","text":"<p>If you are adding to the grammar, first decide if this is a new rule you are adding to an existing grammar, or a rule you would like to override from ANSI SQL (which is found in sql.bnf). In both cases, you will want to define that rule in your new grammar, but in the case of overriding an ANSI SQL rule, add it to the overrides list and set the override attribute on the rule:</p> <pre><code>overrides ::= my_rule\n\nmy_rule ::= SOME_TOKEN {\n  override = true\n}\n</code></pre> <p>The definition of your rule should start by being an exact copy/paste of the rule from ANSI-SQL. To reference rules from ANSI-SQL, you need to surround it in {}, so you should surround all external rules in your overriding rule with {}:</p> <pre><code>my_rule ::= internal_rule {external_rule} {\n  override = true\n}\ninternal_rule ::= SOME_TOKEN\n</code></pre> <p>One caveat is that referencing the <code>expr</code> rule from ANSI-SQL should look like <code>&lt;&lt;expr '-1'&gt;&gt;</code> because it is special and cannot be overridden.</p> <p>Any tokens that you want to use from ANSI SQL should also be manually imported:</p> <pre><code>{\n  parserImports = [\n    \"static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE\"\n    \"static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM\"\n  ]\n}\noverrides ::= delete\n\ndelete ::= DELETE FROM {table_name} {\n  override = true\n}\n</code></pre> <p>Dialects cannot add their own tokens, but you can require exact text by surrounding it with \"\":</p> <pre><code>my_rule ::= \"SOME_TOKEN\"\n</code></pre> <p>Overriding rules must still generate code which confirms to the original rules types, so make sure to <code>implement</code> and <code>extend</code> the existing types for the original rule:</p> <pre><code>my_rule ::= internal_rule {external_rule} {\n  extends = \"com.alecstrong.sql.psi.core.psi.impl.SqlMyRuleImpl\"\n  implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\"\n  overrides = true\n}\n</code></pre> <p>To see an example of overriding rules in the grammar, check out this pr which adds <code>RETURNING</code> syntax to PostgreSQL.</p>"},{"location":"contributing/#rule-behavior","title":"Rule Behavior","text":"<p>Often times you want to modify the behavior of the PSI layer (for example throwing errors for situations you want to fail compilation for). To do this, have your rule use a <code>mixin</code> instead of an <code>extends</code> which is a class you write containing that new logic:</p> <pre><code>my_rule ::= interal_rule {external_rule} {\n  mixin = \"com.alecstrong.sql.psi.MyRuleMixin\"\n  implements = \"com.alecstrong.sql.psi.core.psi.SqlMyRule\"\n  overrides = true\n}\n</code></pre> <p>And then in that class ensure that it implements the original ANSI SQL type and the SQL-PSI base class <code>SqlCompositeElementImpl</code>:</p> <pre><code>class MyRule(\n  node: ASTNode\n) : SqlCompositeElementImpl(node),\n    SqlMyRule {\n  fun annotate(annotationHolder: SqlAnnotationHolder) {\n    if (internal_rule.text == \"bad_text\") {\n      annotationHolder.createErrorAnnotation(\"Invalid text value\", internal_rule)\n    }\n  }\n}\n</code></pre> <p>For example, the DropIndexMixin verifies the index being dropped exists in the schema.</p> <p>If you have a question about contributing not covered in this doc please feel free to open an issue on SqlDelight or open a PR so we can work on improving it!</p>"},{"location":"upgrading-2.0/","title":"Upgrading to 2.0","text":"<p>SQLDelight 2.0 makes some breaking changes to the gradle plugin and runtime APIs.</p> <p>This page lists those breaking changes and their new 2.0 equivalents.  For a full list of new features and other changes, see the changelog.</p>"},{"location":"upgrading-2.0/#new-package-name-and-artifact-group","title":"New Package Name and Artifact Group","text":"<p>All instances of <code>com.squareup.sqldelight</code> need to be replaced with <code>app.cash.sqldelight</code>.</p> Gradle Dependencies<pre><code>plugins {\n-  id(\"com.squareup.sqldelight\") version \"2.0.0-SNAPSHOT\"\n+  id(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\ndependencies {\n-  implementation(\"com.squareup.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\")\n+  implementation(\"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> In Code<pre><code>-import com.squareup.sqldelight.db.SqlDriver\n+import app.cash.sqldelight.db.SqlDriver\n</code></pre>"},{"location":"upgrading-2.0/#gradle-configuration-changes","title":"Gradle Configuration Changes","text":"<ul> <li>SQLDelight 2.0 requires Java 11 for building, and Java 8 for the runtime.</li> <li> <p>The SQLDelight configuration API now uses managed properties and a <code>DomainObjectCollection</code> for the databases.</p> KotlinGroovy <pre><code>sqldelight {\ndatabase { // (1)!\ncreate(\"Database\") {\npackageName.set(\"com.example\") // (2)!\n}\n}\n}\n</code></pre> <ol> <li>New <code>DomainObjectCollection</code> wrapper.</li> <li>Now a <code>Property&lt;String&gt;</code>.</li> </ol> <pre><code>sqldelight {\ndatabase { // (1)!\nDatabase {\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <ol> <li>New <code>DomainObjectCollection</code> wrapper.</li> </ol> </li> <li> <p>The SQL dialect of your database is now specified using a Gradle dependency.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example\")\ndialect(\"app.cash.sqldelight:mysql-dialect:2.0.0-SNAPSHOT\")\n\n// Version catalogs also work!\ndialect(libs.sqldelight.dialects.mysql)\n}  }  }\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example\"\ndialect \"app.cash.sqldelight:mysql-dialect:2.0.0-SNAPSHOT\"\n\n// Version catalogs also work!\ndialect libs.sqldelight.dialects.mysql\n}  }  }\n</code></pre> <p>The currently supported dialects are <code>mysql-dialect</code>, <code>postgresql-dialect</code>, <code>hsql-dialect</code>, <code>sqlite-3-18-dialect</code>, <code>sqlite-3-24-dialect</code>, <code>sqlite-3-25-dialect</code>, <code>sqlite-3-30-dialect</code>, <code>sqlite-3-35-dialect</code>, and <code>sqlite-3-38-dialect</code></p> </li> </ul>"},{"location":"upgrading-2.0/#runtime-changes","title":"Runtime Changes","text":"<ul> <li> <p>Primitive types must now be imported into <code>.sq</code> and <code>.sqm</code> files.</p> <pre><code>+import kotlin.Boolean\n\nCREATE TABLE HockeyPlayer (\n  name TEXT NOT NULL,\n  good INTEGER As Boolean\n);\n</code></pre> <p>Some previously supported types now require an adapter. Adapters for primitive types are available in the <code>app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT</code> artifact. e.g. The <code>IntColumnAdapter</code> for doing <code>INTEGER As kotlin.Int</code> conversions.</p> </li> <li> <p>The <code>AfterVersionWithDriver</code> type was removed in favour of <code>AfterVersion</code> which now always includes the driver, and the <code>migrateWithCallbacks</code> extension function was removed in favour of the main <code>migrate</code> method that now accepts callbacks.</p> <pre><code>Database.Schema.migrateWithCallbacks(\n  driver = driver,\n  oldVersion = 1,\n  newVersion = Database.Schema.version,\n-  AfterVersionWithDriver(3) { driver -&gt;\n-    driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0)\n-  }\n+  AfterVersion(3) { driver -&gt;\n+    driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0)\n+  }\n)\n</code></pre> </li> <li> <p>The <code>Schema</code> type is no longer a nested type of <code>SqlDriver</code>, and is now called <code>SqlSchema</code>.</p> <pre><code>-val schema: SqlDriver.Schema\n+val schema: SqlSchema\n</code></pre> </li> <li> <p>The paging3 extension API has changed to only allow int types for the count.</p> </li> <li>The coroutines extension API now requires a dispatcher to be explicitly passed in.     <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; =\n  playerQueries.selectAll()\n    .asFlow()\n+   .mapToList(Dispatchers.IO)\n</code></pre></li> <li>Some driver methods like <code>execute()</code>, <code>executeQuery()</code>, <code>newTransaction()</code>, and <code>endTransaction()</code> now return a <code>QueryResult</code> object. Use <code>QueryResult.value</code> to access the returned value.     <pre><code>-driver.executeQuery(null, \"PRAGMA user_version\", { /*...*/ })\n+driver.executeQuery(null, \"PRAGMA user_version\", { /*...*/ }).value\n</code></pre>     This change enables driver implementations to be based on non-blocking APIs where the returned value can be accessed using the suspending <code>QueryResult.await()</code> method.</li> </ul>"},{"location":"android_sqlite/","title":"Getting Started on Android","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:android-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:android-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = AndroidSqliteDriver(Database.Schema, context, \"test.db\")\n</code></pre> <p>It's recommended to switch Android Studio to use the \"Project\" view instead of the \"Android\" view of your files, in order to find and edit SQLDelight files.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"android_sqlite/#sqlite-version-support","title":"SQLite Version Support","text":"<p>The SQLDelight Gradle plugin will automatically select the SQLite dialect version based on your project's  <code>minSdkVersion</code> setting. See here for  the list of supported SQLite versions on each Android SDK level.</p>"},{"location":"android_sqlite/androidx_paging/","title":"AndroidX Paging","text":"<p>To use SQLDelight with Android's Paging 3 Library add a dependency on the paging extension artifact.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:androidx-paging3-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:androidx-paging3-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>SQLDelight offers two methods for paging data -- offset based paging and keyset paging.</p>"},{"location":"android_sqlite/androidx_paging/#offset-based-paging","title":"Offset Based Paging","text":"<p>Offset paging achieves paged results using <code>OFFSET</code> and <code>LIMIT</code> clauses. Creating a <code>PagingSource</code> that performs offset based paging requires a count query as well as the paged query.</p> <pre><code>countPlayers:\nSELECT count(*) FROM hockeyPlayer;\n\nplayers:\nSELECT *\nFROM hockeyPlayer\nLIMIT :limit OFFSET :offset;\n</code></pre> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval pagingSource: PagingSource = QueryPagingSource(\ncountQuery = playerQueries.countPlayers(),\ntransacter = playerQueries,\ncontext = Dispatchers.IO,\nqueryProvider = playerQueries::players,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"android_sqlite/androidx_paging/#keyset-paging","title":"Keyset Paging","text":"<p>Offset paging is simple and easy to maintain. Unfortunately it performs poorly on large datasets. The <code>OFFSET</code> clause of a SQL statement really just drops already executed rows in a SQL query. Therefore, as the number to <code>OFFSET</code> grows, so does the amount of time it takes to execute your query. To overcome this, SQLDelight offers a \"keyset paging\" implementation of <code>PagingSource</code>. Rather than querying an entire dataset and inefficiently dropping the first <code>OFFSET</code> elements, keyset paging operates using a unique column to restrict the bounds of your queries. This performs better at the expense of higher developer maintenance. </p> <p>The <code>queryProvider</code> callback that this paging source accepts has two parameters -- a <code>beginInclusive</code> non-null unique <code>Key</code> as well as an <code>endExclusive</code> nullable unique <code>Key?</code>. An example of the core paging query is shown below. </p> <pre><code>keyedQuery:\nSELECT * FROM hockeyPlayer\nWHERE id &gt;= :beginInclusive AND (id &lt; :endExclusive OR :endExclusive IS NULL)\nORDER BY id ASC;\n</code></pre> <p>Queries used in keyset paging must have a unique ordering like shown above. </p> <p>Both <code>beginInclusive</code> and <code>endExclusive</code> are pre-calculated keys that act as page boundaries. Page sizes are established when pre-calculating page boundaries. The <code>pageBoundariesProvider</code> callback takes an <code>anchor: Key?</code> parameter as well as a <code>limit: Int?</code> parameter. An example query that pre-calculates page boundaries is shown below. </p> <pre><code>pageBoundaries:\nSELECT id FROM (\nSELECT\nid,\nCASE\nWHEN ((row_number() OVER(ORDER BY id ASC) - 0) % :limit) = 0 THEN 1\nWHEN id = :anchor THEN 1\nELSE 0\nEND page_boundary;\nFROM hockeyPlayer\nORDER BY id ASC\n)\nWHERE page_boundary = 1;\n</code></pre> <p>Pre-calculating page boundaries of a SQL query will likely require SQLite Window Functions. Window functions were introduced in SQLite version 3.25.0, and therefore are not available by default until Android API 30. To use keyset paging SQLDelight recommends either setting <code>minApi 30</code> or bundling your own SQLite version. The Requery organization offers an up-to-date distribution of SQLite as a standalone library. </p> <p>The AndroidX paging library allows for the first page fetch to differ in size from the subsequent page fetches with <code>PagingConfig.initialLoadSize</code>. This functionality should be avoided, as the <code>pageBoundariesProvider</code> callback is invoked a single time on the first page fetch. Failing to have matching <code>PagingConifg.initialLoadSize</code> and <code>PagingConfig.pageSize</code> will result in unexpected page boundary generation. </p> <p>This paging source does not support jumping. </p> <p>To create this paging source, use the <code>QueryPagingSource</code> factory function. </p> <pre><code>import app.cash.sqldelight.android.paging3.QueryPagingSource\n\nval keyedSource = QueryPagingSource(\ntransacter = playerQueries,\ncontext = Dispatchers.IO,\npageBoundariesProvider = playerQueries::pageBoundaries,\nqueryProvider = playerQueries::keyedQuery,\n)\n</code></pre> <p>By default, queries are performed on <code>Dispatchers.IO</code> if no context is specified. Consumers expecting to use RxJava's <code>Scheduler</code> to perform queries should use the <code>Scheduler.asCoroutineDispatcher</code> extension function.</p>"},{"location":"android_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"android_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, add the coroutines extensions artifact as a dependency and use the extension functions it provides:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"android_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"android_sqlite/foreign_keys/","title":"Foreign Keys","text":"<p>You can enable foreign key constraints for the Android SQLite driver through the driver's <code>onOpen</code> callback.</p> <pre><code>AndroidSqliteDriver(\nschema = Database.Schema,\ncallback = object : AndroidSqliteDriver.Callback(Database.Schema) {\noverride fun onOpen(db: SupportSQLiteDatabase) {\ndb.setForeignKeyConstraintsEnabled(true)\n}\n}\n)\n</code></pre>"},{"location":"android_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"android_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"android_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"android_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"android_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"android_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"android_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"android_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"android_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"android_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"android_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"android_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"android_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"android_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"android_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"android_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"android_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"android_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"android_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"android_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"android_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>You can also place a <code>.db</code> file in the <code>src/main/sqldelight</code> folder of the same <code>&lt;version number&gt;.db</code> format. If there is a <code>.db</code> file present, a new <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>test</code> task, meaning your migrations will be verified against that <code>.db</code> file. It confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generateSqlDelightSchema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration.</p>"},{"location":"android_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\ndriver = database,\noldVersion = 0,\nnewVersion = Database.Schema.version,\nAfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p> <p>If you are using an <code>AndroidSqliteDriver</code> you can pass these callbacks in during the driver's creation:</p> <pre><code>val driver: SqlDriver = AndroidSqliteDriver(\nschema = Database.Schema,\ncontext = context,\nname = \"test.db\",\ncallback = AndroidSqliteDriver.Callback(\nschema = Database.Schema,\nAfterVersion(3) { database.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n)\n</code></pre>"},{"location":"android_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"android_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"android_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"android_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"android_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"android_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"android_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"android_sqlite/resources/","title":"Other Resources","text":""},{"location":"android_sqlite/resources/#guides","title":"Guides","text":"<ul> <li>SQLDelight 1.x Quickstart Guide for Android</li> </ul>"},{"location":"android_sqlite/rxjava/","title":"RxJava","text":"<p>To observe a query, depend on the RxJava extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:rxjava3-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Observable&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asObservable()\n.mapToList()\n</code></pre> <p>Note: For RxJava 2, use <code>rxjava2-extensions</code> as the artifact name.</p>"},{"location":"android_sqlite/testing/","title":"Testing","text":"<p>In some tests (like verification of migrations) you might wish to swap out the Android driver with the JVM driver, enabling you to test code involving the database without needing an Android emulator or physical device. To do that use the jvm SQLite driver:</p> KotlinGroovy <pre><code>dependencies {\ntestImplementation(\"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\ntestImplementation \"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>// When your test needs a driver\n@Before fun before() {\ndriver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)\nDatabase.Schema.create(driver)\n}\n</code></pre> <p>If you are using the SQLite that comes bundled with Android (rather than shipping your own), you can override the version of sqlite-jdbc to one that matches your Android minSdkVersion, for example for API 23 use SQLite 3.8.10.2:</p> <pre><code>dependencies {\ntestImplementation('org.xerial:sqlite-jdbc:3.8.10.2') {\n// Override the version of sqlite used by sqlite-driver to match Android API 23\nforce = true\n}\n}\n</code></pre>"},{"location":"android_sqlite/transactions/","title":"Transactions","text":""},{"location":"android_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"android_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"android_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"android_sqlite/types/","title":"Types","text":""},{"location":"android_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\nsome_double REAL,            -- Stored as REAL in db, retrieved as Double\nsome_string TEXT,            -- Stored as TEXT in db, retrieved as String\nsome_blob BLOB,              -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"android_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"android_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"android_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"android_sqlite/upgrading/","title":"Upgrading from Versions before 1.0","text":"<p>If you're still on SQLDelight 0.6 doing the upgrade to 0.7 first so you stay on the SupportSQLite artifact will likely be easiest</p> <p>Upgrade the gradle plugin from 0.7 to 0.7.1. This will upgrade the arch.persistence.db dependency to 1.1.1, but should have no effect on your usage of sqldelight.</p> <p>Upgrade the gradle plugin from 0.7.1 to 0.7.2. This changes the runtime package from <code>com.squareup.sqldelight</code> to <code>com.squareup.sqldelight.prerelease</code>, so you will need to change references in your own code.</p> <p>Upgrade the gradle plugin from 0.7.2 to 0.9.0. This upgrades the transitive dependencies and generated code to instead use AndroidX, which is a requirement of SQLDelight. This should be done at the same time as you upgrading your own project to AndroidX, and cannot be done separately since SQLDelight generates code which references android support/AndroidX.</p> <p>ALTERNATIVELY Upgrade the gradle plugin from 0.7 to 0.8.0 before then upgrading to 0.9.0. This upgrades to AndroidX without changing the sqldelight package name to <code>com.squareup.sqldelight.prerelease</code></p> <p>Suppose on SQLDelight 0.9 you have this <code>User.sq</code> file:</p> <pre><code>CREATE TABLE user (\nid INTEGER NOT NULL PRIMARY KEY,\nname TEXT NOT NULL\n);\n\ninsertDefaultData:\nINSERT INTO user\nVALUES (1, 'Alec');\n\nusers:\nSELECT *\nFROM user;\n\nnames:\nSELECT name\nFROM user;\n\ninsertUser:\nINSERT INTO user\nVALUES (?, ?);\n</code></pre> <p>This will generate the <code>UserModel</code> class with methods for your queries. </p> <p>Copy and paste all <code>*Model.java</code> files out of the build directory and into your <code>src/main/java</code> folder. </p> <p>Upgrade the gradle plugin from 0.9 to 1.0.0-rc4. Note your build will fail at this point because of the model code having undefined references to the old SQL Delight runtime (like <code>SqlDelightStatement</code>). To add these back in add an <code>implementation</code> dependency on <code>com.squareup.sqldelight:runtime:0.9.0</code>.</p> <p>At this point your build should still be working, but changes to <code>.sq</code> files will not be reflected in your <code>*Model.java</code> files. If things aren't working at this point, please file an issue!</p> <p>Begin by modifying your <code>SupportSQLiteOpenHelper.Callback</code> to call into the now generated <code>Database</code> which holds generated code for SQL Delight 1.0:</p> <pre><code>//Before\n@Override void onCreate(SupportSQLiteDatabase db) {\ndb.execSql(UserModel.CREATE_TABLE);\ndb.execSql(UserModel.INSERTDEFAULTDATA);\n// Other create table/initialization\n}\n</code></pre> <p>In SQL Delight 1.0 all unlabeled statements in <code>.sq</code> files (including <code>CREATE</code> statements) will be run during <code>onCreate</code>, so we can remove the <code>insertDefaultData</code> identifier from above:</p> <p><code>User.sq</code> <pre><code>...\n\n--insertDefaultData:\nINSERT INTO user\nVALUES (1, 'Alec');\n\n...\n</code></pre></p> <p>and now your <code>SupportSQLiteOpenHelper.Callback</code> should call into the <code>Database</code> for <code>create</code></p> <pre><code>@Override void onCreate(SupportSQLiteDatabase db) {\nSqlDriver driver = AndroidSqliteDriver(db)\nDatabase.Schema.create(driver)\n}\n</code></pre> <p>You can do the same for your migrations if you place them in <code>.sqm</code> files, but thats not necessary part of the upgrade.</p> <p>At this point things should still work normally.</p> <p>Next add in the code to create your <code>Database</code> as part of an object graph/singleton pattern/whevs:</p> <pre><code>@Provides @Singleton static SupportSQLiteOpenHelper provideDatabaseHelper(\n@App Context context) {\nSupportSQLiteOpenHelper.Configuration config =  SupportSQLiteOpenHelper.Configuration.builder(context)\n.name(DATABASE_NAME)\n.callback(new MyDatabaseCallback())\n.build();\nreturn new FrameworkSQLiteOpenHelperFactory().create(config);\n}\n\n@Provides @Singleton static Database provideDatabase(\nSupportSQLiteOpenHelper helper) {\nreturn new Database(new AndroidSqliteDriver(helper));\n}\n</code></pre> <p>If you're also using SQL Brite make sure you create a <code>BriteDatabase</code> with the same <code>SupportSQLiteOpenHelper</code> that's being used to create the <code>Database</code>.</p> <p>Things should still be working.</p> <p>The following assume you're using SQL Brite to get reactive callbacks from the database, but upgrades using only SQL Delight will be similar.</p> <p>Mutating queries can be converted individually by using the <code>Database</code>:</p> <p>before: <pre><code>private val insertUser: UserModel.InsertUser by lazy {\nUserModel.InsertUser(datbaseOpenHelper.writableDatabase)\n}\n\ninsertUser.bind(2, \"Jake\")\ninsertUser.executeInsert()\n</code></pre></p> <p>after: <pre><code>database.userQueries.insertUser(2, \"Jake\")\n</code></pre></p> <p>You no longer need a \"Factory\" type to perform queries, the query wrapper is all that is needed.</p> <p>before: <pre><code>val query = User.FACTORY.users()\nval usersObservable = briteDatabase.createQuery(query.tables, query.statement, query.args)\n.mapToList(User.FACTORY.usersMapper()::map)\n</code></pre></p> <p>after: <pre><code>val usersObservable = database.userQueries.users()\n.asObservable(Schedulers.io()) // The scheduler to run the query on.\n.mapToList()\n</code></pre></p> <p>If you still want to use a custom type, pass it as a parameter to the query.</p> <pre><code>val myUsersObservable = database.userQueries.users(::MyUser)\n.asObservable(Schedulers.io())\n.mapToList()\n</code></pre> <p>Once you no longer have references to <code>UserModel.java</code>, delete the whole class. Repeat for each of your <code>*Model.java</code> files until upgrading is complete!</p>"},{"location":"common/coroutines-multiplatform/","title":"Coroutines multiplatform","text":""},{"location":"common/coroutines-multiplatform/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n}\n</code></pre> <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"common/coroutines-usage/","title":"Coroutines usage","text":"<pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"common/coroutines/","title":"Coroutines","text":""},{"location":"common/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, add the coroutines extensions artifact as a dependency and use the extension functions it provides:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"common/custom_column_types/","title":"Custom column types","text":""},{"location":"common/custom_column_types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"common/custom_column_types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"common/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"common/gradle-dependencies/","title":"Gradle dependencies","text":""},{"location":"common/gradle-dependencies/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"common/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"common/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"common/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"common/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"common/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"common/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"common/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"common/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"common/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"common/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"common/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"common/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"common/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"common/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"common/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"common/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"common/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"common/index_gradle_database/","title":"Index gradle database","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre>"},{"location":"common/index_queries/","title":"Index queries","text":"<p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"common/index_schema/","title":"Index schema","text":"<p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p>"},{"location":"common/index_schema_sq/","title":"Index schema sq","text":"<p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre>"},{"location":"common/index_server/","title":"Index server","text":"<p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"common/index_server/#fresh-schema","title":"Fresh Schema","text":"<p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"common/index_server/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"Database\") {\n...\nsourceFolders.set(listOf(\"sqldelight\"))\nderiveSchemaFromMigrations.set(true)\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nDatabase {\n...\nsourceFolders = [\"sqldelight\"]\nderiveSchemaFromMigrations = true\n}\n}\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"common/index_server/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"common/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"common/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"common/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"common/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>You can also place a <code>.db</code> file in the <code>src/main/sqldelight</code> folder of the same <code>&lt;version number&gt;.db</code> format. If there is a <code>.db</code> file present, a new <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>test</code> task, meaning your migrations will be verified against that <code>.db</code> file. It confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generateSqlDelightSchema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration.</p>"},{"location":"common/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\ndriver = database,\noldVersion = 0,\nnewVersion = Database.Schema.version,\nAfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"common/migrations_server/","title":"Migrations server","text":""},{"location":"common/migrations_server/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\ndatabases {\nDatabase {\nmigrationOutputDirectory = file(\"$buildDir/resources/main/migrations\")\nmigrationOutputFileFormat = \".sql\" // Defaults to .sql\n}\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\ndependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"common/multiplatform/","title":"Multiplatform","text":"<p>To use SQLDelight in Kotlin multiplatform configure the Gradle plugin with a package to generate code into.</p> <pre><code>apply plugin: \"org.jetbrains.kotlin.multiplatform\"\napply plugin: \"app.cash.sqldelight\"\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.hockey\"\n}\n}\n}\n</code></pre> <p>Put <code>.sq</code> files in the <code>src/commonMain/sqldelight</code> directory, and then <code>expect</code> a <code>SqlDriver</code> to be provided by individual platforms when creating the <code>Database</code>. Migration files should also be in the same <code>src/commonMain/sqldelight</code> directory.</p>"},{"location":"common/query_arguments/","title":"Query arguments","text":""},{"location":"common/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"common/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"common/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"common/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"common/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"common/query_arguments_sqlite/","title":"Query arguments sqlite","text":""},{"location":"common/query_arguments_sqlite/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"common/query_arguments_sqlite/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"common/query_arguments_sqlite/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"common/query_arguments_sqlite/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"common/query_arguments_sqlite/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"common/query_arguments_sqlite/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"common/rxjava/","title":"RxJava","text":"<p>To observe a query, depend on the RxJava extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:rxjava3-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Observable&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asObservable()\n.mapToList()\n</code></pre> <p>Note: For RxJava 2, use <code>rxjava2-extensions</code> as the artifact name.</p>"},{"location":"common/transactions/","title":"Transactions","text":""},{"location":"common/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"common/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"common/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"common/types_server_migrations/","title":"Types server migrations","text":""},{"location":"common/types_server_migrations/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\nADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"common/types_sqlite/","title":"Types sqlite","text":""},{"location":"common/types_sqlite/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\nsome_double REAL,            -- Stored as REAL in db, retrieved as Double\nsome_string TEXT,            -- Stored as TEXT in db, retrieved as String\nsome_blob BLOB,              -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"common/types_sqlite/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"js_sqlite/","title":"Getting started on Kotlin JS with SQLDelight","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p> KotlinGroovy <pre><code>kotlin {\nsourceSets.jsMain.dependencies {\nimplementation(\"app.cash.sqldelight:sqljs-driver:2.0.0-SNAPSHOT\")\nimplementation(npm(\"sql.js\", \"1.6.2\"))\nimplementation(devNpm(\"copy-webpack-plugin\", \"9.1.0\"))\n}\n}\n</code></pre> <pre><code>kotlin {\nsourceSets.jsMain.dependencies {\nimplementation \"app.cash.sqldelight:sqljs-driver:2.0.0-SNAPSHOT\"\nimplementation npm(\"sql.js\", \"1.6.2\")  implementation devNpm(\"copy-webpack-plugin\", \"9.1.0\")\n}\n}\n</code></pre> <p>Unlike on other platforms, the SqlJs driver can not be instantiated directly. The driver must be loaded asynchronously by calling the <code>initSqlDriver</code> function which returns a <code>Promise&lt;SqlDriver&gt;</code>. <pre><code>// As a Promise\nval promise: Promise&lt;SqlDriver&gt; = initSqlDriver(Database.Schema)\npromise.then { driver -&gt; /* ... */ }\n\n// In a coroutine\nsuspend fun createDriver() {\nval driver: SqlDriver = initSqlDriver(Database.Schema).await()\n/* ... */\n}\n</code></pre></p> <p>If building for browsers, some additional webpack configuration is also required. <pre><code>// project/webpack.config.d/fs.js\nconfig.resolve = {\nfallback: {\nfs: false,\npath: false,\ncrypto: false,\n}\n};\n\n// project/webpack.config.d/wasm.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconfig.plugins.push(\nnew CopyWebpackPlugin({\npatterns: [\n'../../node_modules/sql.js/dist/sql-wasm.wasm'\n]\n})\n);\n</code></pre></p> <p>For browser testing with Karma, some similar configuration is required. <pre><code>// project/karma.config.d/wasm.js\nconst path = require(\"path\");\nconst abs = path.resolve(\"../../node_modules/sql.js/dist/sql-wasm.wasm\")\n\nconfig.files.push({\npattern: abs,\nserved: true,\nwatched: false,\nincluded: false,\nnocache: false,\n});\n\nconfig.proxies[\"/sql-wasm.wasm\"] = `/absolute${abs}`\n</code></pre></p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"js_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"js_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n}\n</code></pre> <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"js_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"js_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"js_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"js_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"js_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"js_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"js_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"js_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"js_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"js_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"js_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"js_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"js_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"js_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"js_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"js_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"js_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"js_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"js_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"js_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"js_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"js_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>You can also place a <code>.db</code> file in the <code>src/main/sqldelight</code> folder of the same <code>&lt;version number&gt;.db</code> format. If there is a <code>.db</code> file present, a new <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>test</code> task, meaning your migrations will be verified against that <code>.db</code> file. It confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generateSqlDelightSchema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration.</p>"},{"location":"js_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\ndriver = database,\noldVersion = 0,\nnewVersion = Database.Schema.version,\nAfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"js_sqlite/multiplatform/","title":"Multiplatform setup with the SqlJs Driver","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p> <pre><code>kotlin {\n// The drivers needed will change depending on what platforms you target:\n\nsourceSets.androidMain.dependencies {\nimplementation \"app.cash.sqldelight:android-driver:2.0.0-SNAPSHOT\"\n}\n\n// or sourceSets.iosMain, sourceSets.windowsMain, etc.\nsourceSets.nativeMain.dependencies {\nimplementation \"app.cash.sqldelight:native-driver:2.0.0-SNAPSHOT\"\n}\n\nsourceSets.jvmMain.dependencies {\nimplementation \"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\"\n}\n\nsourceSets.jsMain.dependencies {\nimplementation \"app.cash.sqldelight:sqljs-driver:2.0.0-SNAPSHOT\"\nimplementation npm(\"sql.js\", \"1.6.2\")\nimplementation devNpm(\"copy-webpack-plugin\", \"9.1.0\")\n}\n}\n</code></pre> <p>Because the SqlJs driver must be initialized asynchronously, the drivers for other platforms must be initialized in a compatible way to be usable in a common source set.</p> <p>The drivers can be initialized in a coroutine, and a higher-order function can be used to ensure that the driver is initialized before executing a block of code that requires the database:</p> <pre><code>// in src/commonMain/kotlin\nexpect suspend fun provideDbDriver(schema: SqlDriver.Schema): SqlDriver\n\nclass SharedDatabase(\nprivate val driverProvider: suspend (SqlDriver.Schema) -&gt; SqlDriver\n) {\nprivate var database: Database? = null\n\nsuspend fun initDatabase() {\nif (database == null) {\ndatabase = driverProvider(Database.Schema).createDatabase()\n}\n}\n\nsuspend operator fun &lt;R&gt; invoke(block: suspend (Database) -&gt; R): R {\ninitDatabase()\nreturn block(database!!)\n}\n\nprivate fun SqlDriver.createDatabase(): Database { /* ... */ }\n}\n\nval sharedDb = SharedDatabase(::createTestDbDriver)\nclass DataRepository(\nprivate val withDatabase: SharedDatabase = sharedDb\n) {\nsuspend fun getData() = withDatabase { database -&gt;\n/* Do something with the database */\n}\n}\n\n// in src/jsMain/kotlin\nactual suspend fun provideDbDriver(schema: SqlDriver.Schema): SqlDriver {\nreturn initSqlDriver(schema).await()\n}\n\n// in src/nativeMain/kotlin\nactual suspend fun provideDbDriver(schema: SqlDriver.Schema): SqlDriver {\nreturn NativeSqliteDriver(schema, \"test.db\")\n}\n\n// in src/jvmMain/kotlin\nactual suspend fun provideDbDriver(schema: SqlDriver.Schema): SqlDriver {\nreturn JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY).also { driver -&gt;\nschema.create(driver)\n}\n}\n</code></pre>"},{"location":"js_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"js_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"js_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"js_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"js_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"js_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"js_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"js_sqlite/transactions/","title":"Transactions","text":""},{"location":"js_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"js_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"js_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"js_sqlite/types/","title":"Types","text":""},{"location":"js_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\nsome_double REAL,            -- Stored as REAL in db, retrieved as Double\nsome_string TEXT,            -- Stored as TEXT in db, retrieved as String\nsome_blob BLOB,              -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"js_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"js_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"js_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"js_sqlite/worker/","title":"Running in a Web Worker","text":"<p>To use the SqlJs driver with sql.js running in a web worker, first update your gradle configuration to generate asynchronous SQLDelight interfaces.</p> <pre><code>sqldelight {\ndatabases {\nDatabase {\npackageName = \"com.example\"\ngenerateAsync = true\n}\n}\n}\n</code></pre> <p>The web worker driver only works with browser targets. In addition to the base webpack configuration needed for the SqlJs driver, the web worker script must also be copied.</p> <pre><code>// project/webpack.config.d/wasm.js\nconst CopyWebpackPlugin = require('copy-webpack-plugin');\nconfig.plugins.push(\nnew CopyWebpackPlugin({\npatterns: [\n'../../node_modules/sql.js/dist/sql-wasm.wasm',\n'../../node_modules/sql.js/dist/worker.sql-wasm.js'\n]\n})\n);\n</code></pre> <p>The function to initialize the driver is a <code>suspend</code> function and must be called within a coroutine. Since this driver is asynchronous, all query functions are also <code>suspend</code> functions.</p> <pre><code>suspend fun setupDb(): AsyncSqlDriver {\nreturn initAsyncSqlDriver(schema = Database.Schema)\n}\n\nsuspend fun getData(database: Database): List&lt;MyData&gt; {\nreturn database.myDataQueries.getAll().executeAsList()\n}\n</code></pre>"},{"location":"js_sqlite/worker/#custom-workers","title":"Custom Workers","text":"<p>By default, the js worker driver will load a web worker from <code>/worker.sql-wasm.js</code> (the additional file copied in the webpack config). The driver supports loading custom workers, or workers located at a different path by providing the URL to the <code>initAsyncSqlDriver()</code> function.</p> <pre><code>initAsyncSqlDriver(workerPath = \"/path/to/my/worker.js\")\n</code></pre> <p>Custom workers must be able to receive and process messages sent by the driver that are defined in the <code>WorkerMessage</code> interface. The driver expects a responding message to be sent that matches the <code>WorkerData</code> interface.</p>"},{"location":"js_sqlite/worker/#testing","title":"Testing","text":"<p>To run karma tests with the web worker, the karma config must be updated to copy and proxy the worker script file in addition to the WebAssembly file.</p> <pre><code>// project/karma.config.d/wasm.js\nconst path = require(\"path\");\nconst dist = path.resolve(\"../../node_modules/sql.js/dist/\")\nconst wasm = path.join(dist, \"sql-wasm.wasm\")\nconst worker = path.join(dist, \"worker.sql-wasm.js\")\n\nconfig.files.push({\npattern: wasm,\nserved: true,\nwatched: false,\nincluded: false,\nnocache: false,\n}, {\npattern: worker,\nserved: true,\nwatched: false,\nincluded: false,\nnocache: false,\n});\n\nconfig.proxies[\"/sql-wasm.wasm\"] = `/absolute${wasm}`\nconfig.proxies[\"/worker.sql-wasm.js\"] = `/absolute${worker}`\n</code></pre>"},{"location":"jvm_h2/","title":"\ud83d\udc77\u200d\u2640\ufe0f IN DEVELOPMENT","text":"<p>H2 is still incubating, and pieces of the dialect are missing. If you are using it and encounter parts of the dialect which are unsupported, please report at sql-psi</p>"},{"location":"jvm_h2/#getting-started-with-h2","title":"Getting Started with H2","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\ndialect(\"app.cash.sqldelight:hsql-dialect:2.0.0-SNAPSHOT\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\ndialect \"app.cash.sqldelight:hsql-dialect:2.0.0-SNAPSHOT\"\n}\n}\n}\n</code></pre> <p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"jvm_h2/#fresh-schema","title":"Fresh Schema","text":"<p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"jvm_h2/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"Database\") {\n...\nsourceFolders.set(listOf(\"sqldelight\"))\nderiveSchemaFromMigrations.set(true)\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nDatabase {\n...\nsourceFolders = [\"sqldelight\"]\nderiveSchemaFromMigrations = true\n}\n}\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"jvm_h2/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_h2/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_h2/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_h2/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_h2/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"jvm_h2/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_h2/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_h2/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_h2/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_h2/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_h2/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_h2/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_h2/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_h2/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_h2/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_h2/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_h2/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_h2/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_h2/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_h2/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_h2/migrations/","title":"Migrations","text":""},{"location":"jvm_h2/migrations/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\ndatabases {\nDatabase {\nmigrationOutputDirectory = file(\"$buildDir/resources/main/migrations\")\nmigrationOutputFileFormat = \".sql\" // Defaults to .sql\n}\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\ndependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"jvm_h2/query_arguments/","title":"Arguments","text":""},{"location":"jvm_h2/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as H2, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_h2/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_h2/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_h2/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_h2/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_h2/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_h2/transactions/","title":"Transactions","text":""},{"location":"jvm_h2/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_h2/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"jvm_h2/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"jvm_h2/types/","title":"Types","text":""},{"location":"jvm_h2/types/#mysql-types","title":"MySQL Types","text":"<p>SQLDelight column definitions are identical to regular H2 column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_tiny_int TINYINT,                           -- Retrieved as Byte\nsome_small_int SMALLINT,                         -- Retrieved as Short\nsome_integer INTEGER,                            -- Retrieved as Int\nsome_int INT,                                    -- Retrieved as Int\nsome_big_int BIGINT,                             -- Retrieved as Long\nsome_decimal DECIMAL(6,5),                       -- Retrieved as Int\nsome_dec DEC(6,5),                               -- Retrieved as Int\nsome_numeric NUMERIC(6,5),                       -- Retrieved as Int\nsome_float FLOAT(6),                             -- Retrieved as Double\nsome_real REAL,                                  -- Retrieved as Double\nsome_double DOUBLE,                              -- Retrieved as Double\nsome_double_precision DOUBLE PRECISION,          -- Retrieved as Double\nsome_boolean BOOLEAN,                            -- Retrieved as Boolean\nsome_date DATE,                                  -- Retrieved as String\nsome_time TIME,                                  -- Retrieved as String\nsome_timestamp2 TIMESTAMP(6),                    -- Retrieved as String\nsome_char CHAR,                                  -- Retrieved as String\nsome_character CHARACTER(6),                     -- Retrieved as String\nsome_char_varying CHAR VARYING(6),               -- Retrieved as String\nsome_longvarchar LONGVARCHAR,                    -- Retrieved as String\nsome_character_varying CHARACTER VARYING(6),     -- Retrieved as String\nsome_varchar VARCHAR(16),                        -- Retrieved as String\nsome_clo CHARACTER LARGE OBJECT(16),             -- Retrieved as String\nsome_clob clob(16 M CHARACTERS),                 -- Retrieved as String\nsome_binary BINARY,                              -- Retrieved as ByteArray\nsome_binary2 BINARY(6),                          -- Retrieved as ByteArray\nsome_longvarbinary LONGVARBINARY,                -- Retrieved as ByteArray\nsome_longvarbinary2 LONGVARBINARY(6),            -- Retrieved as ByteArray\nsome_binary_varying BINARY VARYING(6),           -- Retrieved as ByteArray\nsome_varbinary VARBINARY(8),                     -- Retrieved as ByteArray\nsome_uuid UUID,                                  -- Retrieved as ByteArray\nsome_blob BLOB,                                  -- Retrieved as ByteArray\nsome_blo BINARY LARGE OBJECT(6),                 -- Retrieved as ByteArray\nsome_bit BIT,                                    -- Retrieved as ByteArray\nsome_bit2 BIT(6),                                -- Retrieved as ByteArray\nsome_bit_varying BIT VARYING(6),                 -- Retrieved as ByteArray\nsome_interval INTERVAL YEAR TO MONTH,            -- Retrieved as ByteArray\nsome_interval2 INTERVAL YEAR(3),                 -- Retrieved as ByteArray\nsome_interval3 INTERVAL DAY(4) TO HOUR,          -- Retrieved as ByteArray\nsome_interval4 INTERVAL MINUTE(4) TO SECOND(6),  -- Retrieved as ByteArray\nsome_interval5 INTERVAL SECOND(4,6)              -- Retrieved as ByteArray\n);\n</code></pre>"},{"location":"jvm_h2/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"jvm_h2/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"jvm_h2/types/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\nADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"jvm_mysql/","title":"Getting Started with MySQL","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\ndialect(\"app.cash.sqldelight:mysql-dialect:2.0.0-SNAPSHOT\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\ndialect \"app.cash.sqldelight:mysql-dialect:2.0.0-SNAPSHOT\"\n}\n}\n}\n</code></pre> <p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"jvm_mysql/#fresh-schema","title":"Fresh Schema","text":"<p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"jvm_mysql/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"Database\") {\n...\nsourceFolders.set(listOf(\"sqldelight\"))\nderiveSchemaFromMigrations.set(true)\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nDatabase {\n...\nsourceFolders = [\"sqldelight\"]\nderiveSchemaFromMigrations = true\n}\n}\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"jvm_mysql/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_mysql/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_mysql/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_mysql/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_mysql/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"jvm_mysql/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_mysql/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_mysql/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_mysql/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_mysql/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_mysql/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_mysql/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_mysql/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_mysql/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_mysql/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_mysql/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_mysql/migrations/","title":"Migrations","text":""},{"location":"jvm_mysql/migrations/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\ndatabases {\nDatabase {\nmigrationOutputDirectory = file(\"$buildDir/resources/main/migrations\")\nmigrationOutputFileFormat = \".sql\" // Defaults to .sql\n}\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\ndependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"jvm_mysql/query_arguments/","title":"Arguments","text":""},{"location":"jvm_mysql/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as MySQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_mysql/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_mysql/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_mysql/transactions/","title":"Transactions","text":""},{"location":"jvm_mysql/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_mysql/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"jvm_mysql/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"jvm_mysql/types/","title":"Types","text":""},{"location":"jvm_mysql/types/#mysql-types","title":"MySQL Types","text":"<p>SQLDelight column definitions are identical to regular MySQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_tiny_int TINYINT,             -- Retrieved as Int\nsome_small_int SMALLINT,           -- Retrieved as Int\nsome_medium_int MEDIUMINT,         -- Retrieved as Int\nsome_integer INTEGER,              -- Retrieved as Int\nsome_int INT,                      -- Retrieved as Int\nsome_big_int BIGINT,               -- Retrieved as Long\nsome_decimal DECIMAL,              -- Retrieved as Double\nsome_dec DEC,                      -- Retrieved as Double\nsome_fixed FIXED,                  -- Retrieved as Double\nsome_numeric NUMERIC,              -- Retrieved as Double\nsome_float FLOAT,                  -- Retrieved as Double\nsome_real REAL,                    -- Retrieved as Double\nsome_double_prec DOUBLE PRECISION, -- Retrieved as Double\nsome_double DOUBLE,                -- Retrieved as Double\nsome_date DATE,                    -- Retrieved as String\nsome_time TIME,                    -- Retrieved as String\nsome_datetime DATETIME,            -- Retrieved as String\nsome_timestamp TIMESTAMP,          -- Retrieved as String\nsome_year YEAR,                    -- Retrieved as String\nsome_char CHAR,                    -- Retrieved as String\nsome_varchar VARCHAR(16),          -- Retrieved as String\nsome_tiny_text TINYTEXT,           -- Retrieved as String\nsome_text TEXT,                    -- Retrieved as String\nsome_medium_text MEDIUMTEXT,       -- Retrieved as String\nsome_long_text LONGTEXT,           -- Retrieved as String\nsome_enum ENUM,                    -- Retrieved as String\nsome_set SET,                      -- Retrieved as String\nsome_varbinary VARBINARY(8),       -- Retrieved as ByteArray\nsome_blob BLOB(8, 8),              -- Retrieved as ByteArray\nsome_binary BINARY,                -- Retrieved as ByteArray\nsome_json JSON,                    -- Retrieved as String\nsome_boolean BOOLEAN,              -- Retrieved as Boolean\n);\n</code></pre>"},{"location":"jvm_mysql/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"jvm_mysql/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"jvm_mysql/types/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\nADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"jvm_postgresql/","title":"Getting Started with PostgreSQL","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\ndialect(\"app.cash.sqldelight:postgresql-dialect:2.0.0-SNAPSHOT\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\ndialect \"app.cash.sqldelight:postgresql-dialect:2.0.0-SNAPSHOT\"\n}\n}\n}\n</code></pre> <p>SQLDelight needs to know the schema of your database. There are typically two approaches to setting up your database's  schema. The \"Fresh Schema\" approach assumes that you are starting with an empty database, and that all the statements  necessary to bring it to the desired state will be applied all at once. The \"Migration Schema\" approach on the other  hand assumes that you already have a database and schema set up (e.g. an existing production database), and that you'll  progressively apply migrations over time to update your database's schema.</p> <p>In SQLDelight, these approaches translate to either writing your table definitions in <code>.sq</code> files for a  \"Fresh Schema\", or by writing migration statements in <code>.sqm</code> files for a \"Migration Schema\". In both cases, your SQL queries will be written in <code>.sq</code> files (as shown here).</p>"},{"location":"jvm_postgresql/#fresh-schema","title":"Fresh Schema","text":"<p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>In the same <code>.sq</code> files you can start placing your sql statements to be executed at runtime.</p>"},{"location":"jvm_postgresql/#migration-schema","title":"Migration Schema","text":"<p>First, configure gradle to use migrations to assemble the schema:</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"Database\") {\n...\nsourceFolders.set(listOf(\"sqldelight\"))\nderiveSchemaFromMigrations.set(true)\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nDatabase {\n...\nsourceFolders = [\"sqldelight\"]\nderiveSchemaFromMigrations = true\n}\n}\n}\n</code></pre> <p>Migration files have the extension <code>.sqm</code>, and must have a number in their file name indicating what order the migration file runs in. For example, given this hierarchy:</p> <pre><code>src\n`-- main\n    `-- sqldelight\n        |-- v1__backend.sqm\n        `-- v2__backend.sqm\n</code></pre> <p>SQLDelight will create the schema by applying <code>v1__backend.sqm</code> and then <code>v2__backend.sqm</code>. Place your normal SQL <code>CREATE</code>/<code>ALTER</code> statements in these files. If another service reads from your migrations files (like flyway), make sure to read the info on migrations and how to output valid SQL.</p>"},{"location":"jvm_postgresql/#typesafe-sql","title":"Typesafe SQL","text":"<p>Before you're able to execute SQL statements at runtime, you need to create a <code>SqlDriver</code> to connect to your database. The easiest way is off of a <code>DataSource</code> that you would get from hikari or other connection managers.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:jdbc-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = dataSource.asJdbcDriver()\n</code></pre> <p>Regardless of if you specify the schema as fresh create table statements or through migrations, runtime SQL goes in <code>.sq</code> files.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_postgresql/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_postgresql/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_postgresql/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_postgresql/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"jvm_postgresql/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_postgresql/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_postgresql/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_postgresql/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_postgresql/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_postgresql/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_postgresql/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_postgresql/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_postgresql/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_postgresql/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_postgresql/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_postgresql/migrations/","title":"Migrations","text":""},{"location":"jvm_postgresql/migrations/#valid-sql-migrations","title":"Valid SQL migrations","text":"<p>Using custom kotlin types in migration files means those files are no longer valid SQL. You can optionally configure a gradle task to output your migration files as valid SQL for other services to read from:</p> <pre><code>sqldelight {\ndatabases {\nDatabase {\nmigrationOutputDirectory = file(\"$buildDir/resources/main/migrations\")\nmigrationOutputFileFormat = \".sql\" // Defaults to .sql\n}\n}\n</code></pre> <p>This creates a new task <code>generateMainDatabaseMigrations</code> which will output your <code>.sqm</code> files as valid SQL in the output directory, with the output format. Create a dependency from your compileKotlin task so that services such as flyway will have the files available on their classpath:</p> <pre><code>compileKotlin.configure {\ndependsOn \"generateMainDatabaseMigrations\"\n}\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/","title":"Arguments","text":""},{"location":"jvm_postgresql/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as PostgreSQL, including bound arguments. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_postgresql/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_postgresql/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_postgresql/transactions/","title":"Transactions","text":""},{"location":"jvm_postgresql/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_postgresql/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"jvm_postgresql/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"jvm_postgresql/types/","title":"Types","text":""},{"location":"jvm_postgresql/types/#postgresql-types","title":"PostgreSQL Types","text":"<p>SQLDelight column definitions are identical to regular PostgreSQL column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_smallint SMALLINT,               -- Retrieved as Short\nsome_int2 INT2,                       -- Retrieved as Short\nsome_integer INTEGER,                 -- Retrieved as Int\nsome_int INT,                         -- Retrieved as Int\nsome_int4 INT4,                       -- Retrieved as Int\nsome_bigint BIGINT,                   -- Retrieved as Long\nsome_int8 INT8,                       -- Retrieved as Long\nsome_numeric NUMERIC,                 -- Retrieved as Double\nsome_decimal DECIMAL,                 -- Retrieved as Double\nsome_real REAL,                       -- Retrieved as Double\nsome_float4 FLOAT4,                   -- Retrieved as Double\nsome_double_prec DOUBLE PRECISION,    -- Retrieved as Double\nsome_float8 FLOAT8,                   -- Retrieved as Double\nsome_smallserial SMALLSERIAL,         -- Retrieved as Short\nsome_serial2 SERIAL2,                 -- Retrieved as Short\nsome_serial SERIAL,                   -- Retrieved as Int\nsome_serial4 SERIAL4,                 -- Retrieved as Int\nsome_bigserial BIGSERIAL,             -- Retrieved as Long\nsome_serial8 SERIAL8,                 -- Retrieved as Long\nsome_character CHARACTER,             -- Retrieved as String\nsome_char CHAR,                       -- Retrieved as String\nsome_char_var CHARACTER VARYING(16),  -- Retrieved as String\nsome_varchar VARCHAR(16),             -- Retrieved as String\nsome_text TEXT,                       -- Retrieved as String\nsome_date DATE,                       -- Retrieved as String\nsome_time TIME,                       -- Retrieved as String\nsome_timestamp TIMESTAMP,             -- Retrieved as String\nsome_json JSON                        -- Retrieved as String\n);\n</code></pre>"},{"location":"jvm_postgresql/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"jvm_postgresql/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"jvm_postgresql/types/#custom-types-in-migrations","title":"Custom Types in Migrations","text":"<p>If migrations are the schema's source of truth, you can also specify the exposed kotlin type when altering a table:</p> <pre><code>import kotlin.String;\nimport kotlin.collection.List;\n\nALTER TABLE my_table\nADD COLUMN new_column VARCHAR(8) AS List&lt;String&gt;;\n</code></pre>"},{"location":"jvm_sqlite/","title":"Getting Started on JVM with SQLite","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val driver: SqlDriver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)\nDatabase.Schema.create(driver)\n</code></pre> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"jvm_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"jvm_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, add the coroutines extensions artifact as a dependency and use the extension functions it provides:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"jvm_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"jvm_sqlite/foreign_keys/","title":"Foreign Keys","text":"<p>You can enable foreign key constraints for the JVM SQLite driver by passing the setting to the driver's properties.</p> <pre><code>JdbcSqliteDriver(\nurl = \"...\", properties = Properties().apply { put(\"foreign_keys\", \"true\") }\n)\n</code></pre>"},{"location":"jvm_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"jvm_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"jvm_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"jvm_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"jvm_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"jvm_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"jvm_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"jvm_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"jvm_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"jvm_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"jvm_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"jvm_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"jvm_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"jvm_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"jvm_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"jvm_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"jvm_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>You can also place a <code>.db</code> file in the <code>src/main/sqldelight</code> folder of the same <code>&lt;version number&gt;.db</code> format. If there is a <code>.db</code> file present, a new <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>test</code> task, meaning your migrations will be verified against that <code>.db</code> file. It confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generateSqlDelightSchema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration.</p>"},{"location":"jvm_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\ndriver = database,\noldVersion = 0,\nnewVersion = Database.Schema.version,\nAfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"jvm_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"jvm_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"jvm_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"jvm_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"jvm_sqlite/rxjava/","title":"RxJava","text":"<p>To observe a query, depend on the RxJava extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:rxjava3-extensions:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:rxjava3-extensions:2.0.0-SNAPSHOT\"\n}\n</code></pre> <pre><code>val players: Observable&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asObservable()\n.mapToList()\n</code></pre> <p>Note: For RxJava 2, use <code>rxjava2-extensions</code> as the artifact name.</p>"},{"location":"jvm_sqlite/transactions/","title":"Transactions","text":""},{"location":"jvm_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"jvm_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"jvm_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"jvm_sqlite/types/","title":"Types","text":""},{"location":"jvm_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\nsome_double REAL,            -- Stored as REAL in db, retrieved as Double\nsome_string TEXT,            -- Stored as TEXT in db, retrieved as String\nsome_blob BLOB,              -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"jvm_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"jvm_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"jvm_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"multiplatform_sqlite/","title":"Getting Started with Multiplatform","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <p>Put your SQL statements in a <code>.sq</code> file under <code>src/commonMain/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/commonMain/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p> KotlinGroovy <pre><code>kotlin {\n// The drivers needed will change depending on what platforms you target:\n\nsourceSets.androidMain.dependencies {\nimplementation(\"app.cash.sqldelight:android-driver:2.0.0-SNAPSHOT\")\n}\n\n// or sourceSets.iosMain, sourceSets.windowsMain, etc.\nsourceSets.nativeMain.dependencies {\nimplementation(\"app.cash.sqldelight:native-driver:2.0.0-SNAPSHOT\")\n}\n\nsourceSets.jvmMain.dependencies {\nimplementation(\"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\")\n}\n}\n</code></pre> <pre><code>kotlin {\n// The drivers needed will change depending on what platforms you target:\n\nsourceSets.androidMain.dependencies {\nimplementation \"app.cash.sqldelight:android-driver:2.0.0-SNAPSHOT\"\n}\n\n// or sourceSets.iosMain, sourceSets.windowsMain, etc.\nsourceSets.nativeMain.dependencies {\nimplementation \"app.cash.sqldelight:native-driver:2.0.0-SNAPSHOT\"\n}\n\nsourceSets.jvmMain.dependencies {\nimplementation \"app.cash.sqldelight:sqlite-driver:2.0.0-SNAPSHOT\"\n}\n}\n</code></pre> <pre><code>// in src/commonMain/kotlin\nexpect class DriverFactory {\nexpect fun createDriver(): SqlDriver\n}\n\nfun createDatabase(driverFactory: DriverFactory): Database {\nval driver = driverFactory.createDriver()\nval database = Database(driver)\n\n// Do more work with the database (see below).\n}\n\n// in src/androidMain/kotlin\nactual class DriverFactory(private val context: Context) {\nactual fun createDriver(): SqlDriver {\nreturn AndroidSqliteDriver(Database.Schema, context, \"test.db\") }\n}\n\n// in src/nativeMain/kotlin\nactual class DriverFactory {\nactual fun createDriver(): SqlDriver {\nreturn NativeSqliteDriver(Database.Schema, \"test.db\")\n}\n}\n\n// in src/jvmMain/kotlin\nactual class DriverFactory {\nactual fun createDriver(): SqlDriver {\nval driver: SqlDriver = JdbcSqliteDriver(JdbcSqliteDriver.IN_MEMORY)\nDatabase.Schema.create(driver)\nreturn driver\n}\n}\n</code></pre> <p>For use with the SqlJs driver, see here.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"multiplatform_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"multiplatform_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n}\n</code></pre> <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"multiplatform_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"multiplatform_sqlite/foreign_keys/","title":"Foreign Keys","text":""},{"location":"multiplatform_sqlite/foreign_keys/#android-sqlite","title":"Android SQLite","text":"<p>You can enable foreign key constraints for the Android SQLite driver through the driver's <code>onOpen</code> callback.</p> <pre><code>AndroidSqliteDriver(\nschema = Database.Schema,\ncallback = object : AndroidSqliteDriver.Callback(Database.Schema) {\noverride fun onOpen(db: SupportSQLiteDatabase) {\ndb.setForeignKeyConstraintsEnabled(true)\n}\n}\n)\n</code></pre>"},{"location":"multiplatform_sqlite/foreign_keys/#jvm-sqlite","title":"JVM SQLite","text":"<p>You can enable foreign key constraints for the JVM SQLite driver by passing the setting to the driver's properties.</p> <pre><code>JdbcSqliteDriver(\nurl = \"...\", properties = Properties().apply { put(\"foreign_keys\", \"true\") }\n)\n</code></pre>"},{"location":"multiplatform_sqlite/foreign_keys/#native-sqlite","title":"Native SQLite","text":"<p>You can enable foreign key constraints for the Native SQLite driver by enabling them in the database configuration.</p> <pre><code>NativeSqliteDriver(\nschema = Database.Schema,\nonConfiguration = { config -&gt;\nconfig.copy(\nextendedConfig = DatabaseConfiguration.Extended(foreignKeyConstraints = true)\n)\n}\n)\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"multiplatform_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"multiplatform_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"multiplatform_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"multiplatform_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"multiplatform_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"multiplatform_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"multiplatform_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"multiplatform_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"multiplatform_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>You can also place a <code>.db</code> file in the <code>src/main/sqldelight</code> folder of the same <code>&lt;version number&gt;.db</code> format. If there is a <code>.db</code> file present, a new <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>test</code> task, meaning your migrations will be verified against that <code>.db</code> file. It confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generateSqlDelightSchema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration.</p>"},{"location":"multiplatform_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\ndriver = database,\noldVersion = 0,\nnewVersion = Database.Schema.version,\nAfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"multiplatform_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"multiplatform_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"multiplatform_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"multiplatform_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"multiplatform_sqlite/resources/","title":"Other Resources","text":""},{"location":"multiplatform_sqlite/resources/#guides","title":"Guides","text":"<ul> <li>Introduction to Multiplatform Persistence with SQLDelight</li> <li>Multiplatform Persistence with SQLDelight</li> </ul>"},{"location":"multiplatform_sqlite/resources/#samples","title":"Samples","text":"<ul> <li>https://github.com/joreilly/PeopleInSpace (Android/iOS/watchOS/macOS/Web)</li> <li>https://github.com/JakeWharton/SdkSearch (Android/Web)</li> <li>https://github.com/saket/press (Android/macOS)</li> <li>https://github.com/cashapp/sqldelight/tree/master/sample (Android/iOS/Web)</li> <li>https://github.com/russhwolf/To-Do (Android/iOS using Compose/SwiftUI)</li> </ul>"},{"location":"multiplatform_sqlite/transactions/","title":"Transactions","text":""},{"location":"multiplatform_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"multiplatform_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"multiplatform_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"multiplatform_sqlite/types/","title":"Types","text":""},{"location":"multiplatform_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\nsome_double REAL,            -- Stored as REAL in db, retrieved as Double\nsome_string TEXT,            -- Stored as TEXT in db, retrieved as String\nsome_blob BLOB,              -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"multiplatform_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"multiplatform_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"multiplatform_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"},{"location":"native_sqlite/","title":"Getting started on Kotlin Native with SQLDelight","text":"<p>First apply the gradle plugin in your project.</p> KotlinGroovy <pre><code>plugins {\nid(\"app.cash.sqldelight\") version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\ncreate(\"Database\") {\npackageName.set(\"com.example\")\n}\n}\n}\n</code></pre> <pre><code>plugins {\nid \"app.cash.sqldelight\" version \"2.0.0-SNAPSHOT\"\n}\n\nrepositories {\ngoogle()\nmavenCentral()\n}\n\nsqldelight {\ndatabases {\nDatabase { // This will be the name of the generated database class.\npackageName = \"com.example\"\n}\n}\n}\n</code></pre> <p>Put your SQL statements in a <code>.sq</code> file under <code>src/main/sqldelight</code>. Typically the first statement in the SQL file creates a table.</p> <pre><code>-- src/main/sqldelight/com/example/sqldelight/hockey/data/Player.sq\n\nCREATE TABLE hockeyPlayer (\nplayer_number INTEGER PRIMARY KEY NOT NULL,\nfull_name TEXT NOT NULL\n);\n\nCREATE INDEX hockeyPlayer_full_name ON hockeyPlayer(full_name);\n\nINSERT INTO hockeyPlayer (player_number, full_name)\nVALUES (15, 'Ryan Getzlaf');\n</code></pre> <p>From this SQLDelight will generate a <code>Database</code> Kotlin class with an associated <code>Schema</code> object that can be used to create your database and run your statements on it. Doing this also requires a driver, which SQLDelight provides implementations of:</p> KotlinGroovy <pre><code>kotlin {\n// or sourceSets.iosMain, sourceSets.windowsMain, etc.\nsourceSets.nativeMain.dependencies {\nimplementation(\"app.cash.sqldelight:native-driver:2.0.0-SNAPSHOT\")\n}\n}\n</code></pre> <pre><code>kotlin {\n// or sourceSets.iosMain, sourceSets.windowsMain, etc.\nsourceSets.nativeMain.dependencies {\nimplementation \"app.cash.sqldelight:native-driver:2.0.0-SNAPSHOT\"\n}\n}\n</code></pre> <pre><code>val driver: SqlDriver = NativeSqliteDriver(Database.Schema, \"test.db\")\n</code></pre>"},{"location":"native_sqlite/#kotlinnative-memory-models","title":"Kotlin/Native Memory Models","text":"<p>The SQLDelight native driver supports the updated memory model only since 2.0.0.</p> <p>SQL statements inside a <code>.sq</code> file can be labeled to have a typesafe function generated for them available at runtime.</p> <pre><code>selectAll:\nSELECT *\nFROM hockeyPlayer;\n\ninsert:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES (?, ?);\n\ninsertFullPlayerObject:\nINSERT INTO hockeyPlayer(player_number, full_name)\nVALUES ?;\n</code></pre> <p>Files with labeled statements in them will have a queries file generated from them that matches the <code>.sq</code> file name - putting the above sql into <code>Player.sq</code> generates <code>PlayerQueries.kt</code>. To get a reference to <code>PlayerQueries</code> you need to wrap the driver we made above:</p> <pre><code>// In reality the database and driver above should be created a single time\n// and passed around using your favourite dependency injection/service\n// locator/singleton pattern.\nval database = Database(driver)\n\nval playerQueries: PlayerQueries = database.playerQueries\n\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\")]\n\nplayerQueries.insert(player_number = 10, full_name = \"Corey Perry\")\nprintln(playerQueries.selectAll().executeAsList())\n// Prints [HockeyPlayer(15, \"Ryan Getzlaf\"), HockeyPlayer(10, \"Corey Perry\")]\n\nval player = HockeyPlayer(10, \"Ronald McDonald\")\nplayerQueries.insertFullPlayerObject(player)\n</code></pre> <p>And that's it! Check out the other pages on the sidebar for other functionality.</p>"},{"location":"native_sqlite/#reader-connection-pools","title":"Reader Connection Pools","text":"<p>Disk databases can (optionally) have multiple reader connections. To configure the reader pool, pass the <code>maxReaderConnections</code> parameter to the various constructors of <code>NativeSqliteDriver</code>:</p> <pre><code>val driver: SqlDriver = NativeSqliteDriver(\nDatabase.Schema, \"test.db\", maxReaderConnections = 4\n)\n</code></pre> <p>Reader connections are only used to run queries outside of a transaction. Any write calls, and anything in a transaction,  uses a single connection dedicated to transactions.</p>"},{"location":"native_sqlite/coroutines/","title":"Coroutines","text":""},{"location":"native_sqlite/coroutines/#flow","title":"Flow","text":"<p>To consume a query as a Flow, depend on the Coroutines extensions artifact and use the extension method it provides:</p> KotlinGroovy <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation(\"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\")\n}\n}\n</code></pre> <pre><code>kotlin {\nsourceSets.commonMain.dependencies {\nimplementation \"app.cash.sqldelight:coroutines-extensions:2.0.0-SNAPSHOT\"\n}\n}\n</code></pre> <pre><code>val players: Flow&lt;List&lt;HockeyPlayer&gt;&gt; = playerQueries.selectAll()\n.asFlow()\n.mapToList(Dispatchers.IO)\n</code></pre> <p>This flow emits the query result, and emits a new result every time the database changes for that query.</p>"},{"location":"native_sqlite/custom_projections/","title":"Type Projections","text":"<p>By default queries will return a data class with your projection, but you can override the behavior with a typesafe mapper.</p> <pre><code>val selectAllNames = playerQueries.selectAll(\nmapper = { player_number, full_name -&gt; full_name.toUppercase() }\n)\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre> <p>In general you should be leveraging SQL to do custom projections whenever possible.</p> <pre><code>selectNames:\nSELECT upper(full_name)\nFROM hockeyPlayer;\n</code></pre> <pre><code>val selectAllNames = playerQueries.selectNames()\nprintln(selectAllNames.executeAsList())\n// Prints [\"RYAN GETZLAF\", \"COREY PERRY\"]\n</code></pre>"},{"location":"native_sqlite/foreign_keys/","title":"Foreign Keys","text":"<p>You can enable foreign key constraints for the Native SQLite driver by enabling them in the database configuration.</p> <pre><code>NativeSqliteDriver(\nschema = Database.Schema,\nonConfiguration = { config -&gt;\nconfig.copy(\nextendedConfig = DatabaseConfiguration.Extended(foreignKeyConstraints = true)\n)\n}\n)\n</code></pre>"},{"location":"native_sqlite/gradle/","title":"Gradle","text":"<p>For greater customization, you can declare databases explicitly using the Gradle DSL.</p>"},{"location":"native_sqlite/gradle/#sqldelight-configuration","title":"SQLDelight Configuration","text":""},{"location":"native_sqlite/gradle/#databases","title":"<code>databases</code>","text":"<p>Container for databases. Configures SQLDelight to create each database with the given name.</p> KotlinGroovy <pre><code>sqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\n// Database configuration here.\n}\n}\n}\n</code></pre> <pre><code>sqldelight {\ndatabases {\nMyDatabase {\n// Database configuration here.\n}\n}\n}\n</code></pre>"},{"location":"native_sqlite/gradle/#linksqlite","title":"<code>linkSqlite</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>For native targets. Whether sqlite should be automatically linked.</p> <p>Defaults to <code>true</code>.</p> KotlinGroovy <pre><code>linkSqlite.set(true)\n</code></pre> <pre><code>linkSqlite = true\n</code></pre>"},{"location":"native_sqlite/gradle/#database-configuration","title":"Database Configuration","text":""},{"location":"native_sqlite/gradle/#packagename","title":"<code>packageName</code>","text":"<p>Type: <code>Property&lt;String&gt;</code></p> <p>Package name used for the database class.</p> KotlinGroovy <pre><code>packageName.set(\"com.example.db\")\n</code></pre> <pre><code>packageName = \"com.example.db\"\n</code></pre>"},{"location":"native_sqlite/gradle/#srcdirs","title":"<code>srcDirs</code>","text":"<p>Type: <code>ConfigurableFileCollection</code></p> <p>A collection of folders that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> <p>Defaults to <code>src/[prefix]main/sqldelight</code> with prefix depending on the applied kotlin plugin eg common for multiplatform.</p> Kotlin <pre><code>srcDirs.setFrom(\"src/main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs = ['src/main/sqldelight']\n</code></pre>"},{"location":"native_sqlite/gradle/#srcdirsvararg-objects-any","title":"<code>srcDirs(vararg objects: Any)</code>","text":"<p>A collection of objects that the plugin will look in for your <code>.sq</code> and <code>.sqm</code> files.</p> Kotlin <pre><code>srcDirs(\"src/main/sqldelight\", \"main/sqldelight\")\n</code></pre> Groovy <pre><code>srcDirs('src/main/sqldelight', 'main/sqldelight')\n</code></pre>"},{"location":"native_sqlite/gradle/#schemaoutputdirectory","title":"<code>schemaOutputDirectory</code>","text":"<p>Type: <code>DirectoryProperty</code></p> <p>The directory where <code>.db</code> schema files should be stored, relative to the project root. These files are used to verify that migrations yield a database with the latest schema.</p> <p>Defaults to <code>null</code>. If <code>null</code>, the migration verification tasks will not be created.</p> KotlinGroovy <pre><code>schemaOutputDirectory.set(file(\"src/main/sqldelight/databases\"))\n</code></pre> <pre><code>schemaOutputDirectory = file(\"src/main/sqldelight/databases\")\n</code></pre>"},{"location":"native_sqlite/gradle/#dependency","title":"<code>dependency</code>","text":"<p>Type: <code>Project</code></p> <p>Optionally specify schema dependencies on other gradle projects (see below).</p> KotlinGroovy <pre><code>dependency(project(\":other-project\"))\n</code></pre> <pre><code>dependency project(\":other-project\")\n</code></pre>"},{"location":"native_sqlite/gradle/#dialect","title":"<code>dialect</code>","text":"<p>Type: <code>String</code> or <code>Provider&lt;MinimalExternalModuleDependency&gt;</code></p> <p>The SQL dialect you would like to target. Dialects are selected using a gradle dependency. These dependencies can be specified as <code>app.cash.sqldelight:{dialect module}:2.0.0-SNAPSHOT</code>.  See below for available dialects.</p> <p>For Android projects, the SQLite version is automatically selected based on your <code>minSdk</code>.  Otherwise defaults to SQLite 3.18.</p> <p>Available dialects:</p> <ul> <li>HSQL: <code>hsql-dialect</code></li> <li>MySQL: <code>mysql-dialect</code></li> <li>PostgreSQL: <code>postgresql-dialect</code></li> <li>SQLite 3.18: <code>sqlite-3-18-dialect</code></li> <li>SQLite 3.24: <code>sqlite-3-24-dialect</code></li> <li>SQLite 3.25: <code>sqlite-3-25-dialect</code></li> <li>SQLite 3.30: <code>sqlite-3-30-dialect</code></li> <li>SQLite 3.33: <code>sqlite-3-33-dialect</code></li> <li>SQLite 3.35: <code>sqlite-3-35-dialect</code></li> <li>SQLite 3.38: <code>sqlite-3-38-dialect</code></li> </ul> KotlinGroovy <pre><code>dialect(\"app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT\")\n</code></pre> <pre><code>dialect 'app.cash.sqldelight:sqlite-3-24-dialect:2.0.0-SNAPSHOT'\n</code></pre>"},{"location":"native_sqlite/gradle/#verifymigrations","title":"<code>verifyMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, migration files will fail during the build process if there are any errors in them.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>verifyMigrations.set(true)\n</code></pre> <pre><code>verifyMigrations = true\n</code></pre>"},{"location":"native_sqlite/gradle/#treatnullasunknownforequality","title":"<code>treatNullAsUnknownForEquality</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will not replace an equality comparison with a nullable typed value when using <code>IS</code>.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>treatNullAsUnknownForEquality.set(true)\n</code></pre> <pre><code>treatNullAsUnknownForEquality = true\n</code></pre>"},{"location":"native_sqlite/gradle/#generateasync","title":"<code>generateAsync</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, SQLDelight will generate suspending query methods for us with asynchronous drivers.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>generateAsync.set(true)\n</code></pre> <pre><code>generateAsync = true\n</code></pre>"},{"location":"native_sqlite/gradle/#deriveschemafrommigrations","title":"<code>deriveSchemaFromMigrations</code>","text":"<p>Type: <code>Property&lt;Boolean&gt;</code></p> <p>If set to true, the schema for your database will be derived from your <code>.sqm</code> files as if each migration had been applied. If false, your schema is defined in <code>.sq</code> files.</p> <p>Defaults to <code>false</code>.</p> KotlinGroovy <pre><code>deriveSchemaFromMigrations.set(true)\n</code></pre> <pre><code>deriveSchemaFromMigrations = true\n</code></pre>"},{"location":"native_sqlite/gradle/#schema-dependencies","title":"Schema Dependencies","text":"<p>You can specify schema dependencies on another module:</p> KotlinGroovy <pre><code>// project-a/build.gradle.kts\n\nsqldelight {\ndatabases {\ncreate(\"MyDatabase\") {\npackageName.set(\"com.example.projecta\")\ndependency(project(\":ProjectB\"))\n}\n}\n}\n</code></pre> <pre><code>// project-a/build.gradle\n\nsqldelight {\ndatabases {\nMyDatabase {\npackageName = \"com.example.projecta\"\ndependency project(\":ProjectB\")\n}\n}\n}\n</code></pre> <p>This looks for <code>MyDatabase</code> in <code>ProjectB</code> and includes it's schema when compiling. For this to work, ProjectB must have a database with the same name (<code>MyDatabase</code> in this case) but generate in a different package, so here is what <code>ProjectB</code>'s gradle might look like:</p> KotlinGroovy <pre><code>// project-b/build.gradle.kts\n\nsqldelight {\ndatabases {\n// Same database name\ncreate(\"MyDatabase\") {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <pre><code>// project-b/build.gradle\n\nsqldelight {\ndatabases {\n// Same database name\nMyDatabase {\npackage = \"com.example.projectb\"\n}\n}\n}\n</code></pre> <p>If you use <code>deriveSchemaFromMigrations = true</code>, every module depending on this module must also enable this feature.</p>"},{"location":"native_sqlite/grouping_statements/","title":"Grouping Statements","text":"<p>You can group multiple SQL statements together to be executed at once inside a transaction:</p> <pre><code>upsert {\nUPDATE myTable\nSET column1 = :column1,\ncolumn2 = :column2\nWHERE id = :id;\n\nINSERT OR IGNORE INTO myTable (id, column1, column2)\nVALUES (:id, :column1, :column2);\n}\n</code></pre>"},{"location":"native_sqlite/intellij_plugin/","title":"IntelliJ Plugin","text":"<p>The IntelliJ plugin provides language-level features for <code>.sq</code> files, including:</p> <ul> <li>Syntax highlighting</li> <li>Refactoring/Find usages</li> <li>Code autocompletion</li> <li>Generate <code>Queries</code> files after edits</li> <li>Right click to copy as valid SQLite</li> <li>Compiler errors in IDE click through to file</li> </ul> <p></p>  It can be installed from your IDE by navigating Preferences -&gt; Plugins -&gt; Marketplace -&gt; Search for SQLDelight"},{"location":"native_sqlite/migrations/","title":"Migrations","text":"<p>An <code>.sq</code> file always describes how to create the latest schema in an empty database. If your database is currently on an earlier version, migration files bring those databases up-to-date. Migration files are stored in the same <code>sqldelight</code> folder as your <code>.sq</code> files:</p> <pre><code>src\n\u2514\u2500 main\n   \u2514\u2500 sqdelight\n      \u251c\u2500 com/example/hockey\n      |  \u251c\u2500 Team.sq\n      |  \u2514\u2500 Player.sq\n      \u2514\u2500 migrations\n         \u251c\u2500 1.sqm\n         \u2514\u2500 2.sqm\n</code></pre> <p>If the driver supports it, migrations are run in a transaction. You should not surround your migrations in <code>BEGIN/END TRANSACTION</code>, as this can cause a crash with some drivers.</p>"},{"location":"native_sqlite/migrations/#versioning","title":"Versioning","text":"<p>The first version of the schema is 1. Migration files are named <code>&lt;version to upgrade from&gt;.sqm</code>. To migrate to version 2, put migration statements in <code>1.sqm</code>:</p> <pre><code>ALTER TABLE hockeyPlayer ADD COLUMN draft_year INTEGER;\nALTER TABLE hockeyPlayer ADD COLUMN draft_order INTEGER;\n</code></pre> <p>These SQL statements are run by the <code>Database.Schema.migrate()</code> method. Migration files go in the same source set as your <code>.sq</code> files.</p>"},{"location":"native_sqlite/migrations/#verifying-migrations","title":"Verifying Migrations","text":"<p>You can also place a <code>.db</code> file in the <code>src/main/sqldelight</code> folder of the same <code>&lt;version number&gt;.db</code> format. If there is a <code>.db</code> file present, a new <code>verifySqlDelightMigration</code> task will be added to the gradle project, and it will run as part of the <code>test</code> task, meaning your migrations will be verified against that <code>.db</code> file. It confirms that the migrations yield a database with the latest schema.</p> <p>To generate a <code>.db</code> file from your latest schema, run the <code>generateSqlDelightSchema</code> task, which is available once you specify a <code>schemaOutputDirectory</code>, as described in the gradle.md. You should probably do this before you create your first migration.</p>"},{"location":"native_sqlite/migrations/#code-migrations","title":"Code Migrations","text":"<p>If you run your migration from code and would like to perform data migrations you can use the <code>Database.Schema.migrate</code> api:</p> <pre><code>Database.Schema.migrate(\ndriver = database,\noldVersion = 0,\nnewVersion = Database.Schema.version,\nAfterVersion(3) { driver -&gt; driver.execute(null, \"INSERT INTO test (value) VALUES('hello')\", 0) },\n)\n</code></pre> <p>In the following example, if you have 1.sqm, 2.sqm, 3.sqm, 4.sqm, and 5.sqm as migrations, the above callback will happen after 3.sqm completes when the database is on version 4. After the callback it will resume at 4.sqm and complete the remaining migrations, in this case 4.sqm and 5.sqm, meaning the final database version is 6.</p>"},{"location":"native_sqlite/query_arguments/","title":"Arguments","text":""},{"location":"native_sqlite/query_arguments/#bind-args","title":"Bind Args","text":"<p><code>.sq</code> files use the exact same syntax as SQLite, including SQLite Bind Args. If a statement contains bind args, the associated method will require corresponding arguments.</p>"},{"location":"native_sqlite/query_arguments/#type-inference","title":"Type Inference","text":"<p>SQLDelight will infer the correct type and nullability of runtime parameters, including custom column types.</p> <pre><code>selectByNumber:\nSELECT *\nFROM hockeyPlayer\nWHERE player_number = ?;\n</code></pre> <pre><code>val selectNumber10 = playerQueries.selectByNumber(player_number = 10)\nprintln(selectNumber10.executeAsOne())\n// Prints \"Corey Perry\"\n</code></pre>"},{"location":"native_sqlite/query_arguments/#named-arguments","title":"Named Arguments","text":"<p>Named parameters or indexed parameters can be used.</p> <pre><code>firstOrLastName:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name LIKE ('% ' || :name)\nOR full_name LIKE (:name || ' %');\n</code></pre> <pre><code>playerQueries.firstOrLastName(name = \"Ryan\")\n</code></pre>"},{"location":"native_sqlite/query_arguments/#variable-arguments","title":"Variable Arguments","text":"<p>Sets of values can also be passed as an argument.</p> <pre><code>selectByNames:\nSELECT *\nFROM hockeyPlayer\nWHERE full_name IN ?;\n</code></pre> <pre><code>playerQueries.selectByNames(listOf(\"Alec\", \"Jake\", \"Matt\"))\n</code></pre>"},{"location":"native_sqlite/query_arguments/#inserts","title":"Inserts","text":"<p><code>INSERT VALUES</code> arguments can be bound to with the table's data class.</p> <pre><code>insertPlayer:\nINSERT INTO hockeyPlayer\nVALUES ?;\n</code></pre> <pre><code>val rickardRakell = HockeyPlayer(\nfull_name = \"Rickard Rakell\",\nnumber = 67\n)\nplayerQueries.insertPlayer(rickardRakell)\n</code></pre>"},{"location":"native_sqlite/query_arguments/#input-sanitization","title":"Input Sanitization","text":"<p>SQLDelight uses query placeholders to pass arguments into queries. The actual sanitization of argument inputs is done by the underlying driver implementation on each respective platform and dialect.</p>"},{"location":"native_sqlite/transactions/","title":"Transactions","text":""},{"location":"native_sqlite/transactions/#api","title":"API","text":"<p>If you want to execute multiple statements under one transaction, use <code>transaction</code> function. </p> <pre><code>val players = listOf&lt;Player&gt;()\ndatabase.playerQueries.transaction {\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <p>To return a value from a transaction, use the <code>transactionWithResult</code> function.</p> <pre><code>val players: List&lt;Player&gt; = database.playerQueries.transactionWithResult {\ndatabase.playerQueries.selectAll().executeAsList()\n}\n</code></pre>"},{"location":"native_sqlite/transactions/#rollback","title":"Rollback","text":"<p>Transactions will roll back if an exception occurs anywhere in them. You can manually roll back a transaction anywhere inside of one, but if your transaction returns a value you will need to specify a value for the transaction to return.</p> <pre><code>database.playerQueries.transaction {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback()\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre> <pre><code>val numberInserted: Int = database.playerQueries.transactionWithResult {\nplayers.forEach { player -&gt;\nif (player.number == 0) rollback(0)\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\nplayers.size\n}\n</code></pre>"},{"location":"native_sqlite/transactions/#callbacks","title":"Callbacks","text":"<p>You can register callbacks to occur after a transaction has completed or rolled back:</p> <pre><code>database.playerQueries.transaction {\nafterRollback { log(\"No players were inserted.\") }\nafterCommit { log(\"${players.size} players were inserted.\") }\n\nplayers.forEach { player -&gt;\ndatabase.playerQueries.insert(\nplayer_number = player.number,\nfull_name = player.fullName\n)\n}\n}\n</code></pre>"},{"location":"native_sqlite/types/","title":"Types","text":""},{"location":"native_sqlite/types/#sqlite-types","title":"SQLite Types","text":"<p>SQLDelight column definitions are identical to regular SQLite column definitions but support an extra column constraint which specifies the Kotlin type of the column in the generated interface.</p> <pre><code>CREATE TABLE some_types (\nsome_long INTEGER,           -- Stored as INTEGER in db, retrieved as Long\nsome_double REAL,            -- Stored as REAL in db, retrieved as Double\nsome_string TEXT,            -- Stored as TEXT in db, retrieved as String\nsome_blob BLOB,              -- Stored as BLOB in db, retrieved as ByteArray\n);\n</code></pre>"},{"location":"native_sqlite/types/#primitives","title":"Primitives","text":"<p>A sibling module that adapts primitives for your convenience.</p> KotlinGroovy <pre><code>dependencies {\nimplementation(\"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\")\n}\n</code></pre> <pre><code>dependencies {\nimplementation \"app.cash.sqldelight:primitive-adapters:2.0.0-SNAPSHOT\"\n}\n</code></pre> <p>The following adapters exist:</p> <ul> <li><code>FloatColumnAdapter</code> \u2014 Retrieves <code>kotlin.Float</code> for an SQL type implicitly stored as <code>kotlin.Double</code></li> <li><code>IntColumnAdapter</code> \u2014 Retrieves <code>kotlin.Int</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> <li><code>ShortColumnAdapter</code> \u2014 Retrieves <code>kotlin.Short</code> for an SQL type implicitly stored as <code>kotlin.Long</code></li> </ul>"},{"location":"native_sqlite/types/#custom-column-types","title":"Custom Column Types","text":"<p>If you'd like to retrieve columns as custom types you can specify a Kotlin type:</p> <pre><code>import kotlin.String;\nimport kotlin.collections.List;\n\nCREATE TABLE hockeyPlayer (\ncup_wins TEXT AS List&lt;String&gt; NOT NULL\n);\n</code></pre> <p>However, creating the <code>Database</code> will require you to provide a <code>ColumnAdapter</code> which knows how to map between the database type and your custom type:</p> <pre><code>val listOfStringsAdapter = object : ColumnAdapter&lt;List&lt;String&gt;, String&gt; {\noverride fun decode(databaseValue: String) =\nif (databaseValue.isEmpty()) {\nlistOf()\n} else {\ndatabaseValue.split(\",\")\n}\noverride fun encode(value: List&lt;String&gt;) = value.joinToString(separator = \",\")\n}\n\nval queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = hockeyPlayer.Adapter(\ncup_winsAdapter = listOfStringsAdapter\n)\n)\n</code></pre>"},{"location":"native_sqlite/types/#enums","title":"Enums","text":"<p>As a convenience the SQLDelight runtime includes a <code>ColumnAdapter</code> for storing an enum as String data.</p> <pre><code>import com.example.hockey.HockeyPlayer;\n\nCREATE TABLE hockeyPlayer (\nposition TEXT AS HockeyPlayer.Position\n)\n</code></pre> <pre><code>val queryWrapper: Database = Database(\ndriver = driver,\nhockeyPlayerAdapter = HockeyPlayer.Adapter(\npositionAdapter = EnumColumnAdapter()\n)\n)\n</code></pre>"}]}