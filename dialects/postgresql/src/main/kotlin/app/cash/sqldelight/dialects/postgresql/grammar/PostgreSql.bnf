{
  // Specify the parent parser.
  overrides="com.alecstrong.sql.psi.core.SqlParser"
  elementTypeClass = "com.alecstrong.sql.psi.core.SqlElementType"

  implements="com.alecstrong.sql.psi.core.psi.SqlCompositeElement"
  extends="com.alecstrong.sql.psi.core.psi.SqlCompositeElementImpl"
  psiClassPrefix = "PostgreSql"

  parserImports=[
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ADD"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ABORT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ALL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ALTER"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ALWAYS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.AS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ASC"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.BY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CASCADE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.COLLATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.COLUMN"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.COMMA"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CONFLICT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CONSTRAINT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CREATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CURRENT_DATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CURRENT_TIME"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CURRENT_TIMESTAMP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DEFAULT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DESC"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DISTINCT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DOT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DROP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.EQ"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ESCAPE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.EXISTS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FAIL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FALSE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FOR"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FOREIGN"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.GENERATED"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.GROUP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.HAVING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ID"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.IF"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.IS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.IGNORE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INDEX"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INSERT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INTO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.KEY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.LIMIT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.LP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.MINUS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NOT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NOTHING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NULL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.OFFSET"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ON"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.OR"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ORDER"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.PLUS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.PRIMARY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.RENAME"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.REPLACE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ROLLBACK"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.RP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.SELECT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.SET"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.STRING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TEMP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TEMPORARY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TRUE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.UNIQUE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.UPDATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.USING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.VALUES"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.WHERE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.WITH"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.WITHOUT"
  ]
}
overrides ::= type_name
  | column_constraint
  | string_literal
  | bind_parameter
  | table_constraint
  | default_constraint
  | with_clause_auxiliary_stmt
  | delete_stmt_limited
  | insert_stmt
  | update_stmt_limited
  | generated_clause
  | alter_table_rules
  | compound_select_stmt
  | extension_expr
  | extension_stmt
  | create_index_stmt
  | select_stmt

column_constraint ::= [ CONSTRAINT {identifier} ] (
  PRIMARY KEY [ ASC | DESC ] {conflict_clause} |
  [ NOT ] NULL {conflict_clause} |
  UNIQUE {conflict_clause} |
  {check_constraint} |
  generated_clause |
  default_constraint |
  COLLATE {collation_name} |
  {foreign_key_clause}
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlColumnConstraintImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlColumnConstraint"
  override = true
}

current_timestamp_with_optional_interval ::= ( CURRENT_TIMESTAMP | 'NOW()' | interval_expression ) [ [ PLUS | MINUS ] interval_expression ] *
default_constraint ::= [ NOT NULL | NULL ] DEFAULT (
  current_timestamp_with_optional_interval |
  {signed_number} |
  {literal_value} |
  {function_expr} |
  LP <<expr '-1'>> RP
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlDefaultConstraintImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlDefaultConstraint"
  override = true
  pin = 2
}

type_name ::= (
  small_int_data_type |
  int_data_type |
  big_int_data_type |
  numeric_data_type |
  approximate_numeric_data_type |
  small_serial_data_type |
  serial_data_type |
  big_serial_data_type |
  string_data_type |
  uuid_data_type |
  date_data_type |
  boolean_data_type |
  json_data_type |
  blob_data_type |
  tsvector_data_type
) [ '[]' ] {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlTypeNameImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlTypeName"
  override = true
}
bind_parameter ::= DEFAULT | ( '?' | ':' {identifier} ) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.BindParameterMixin"
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlBindParameterImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlBindParameter"
  override = true
}
table_constraint ::= [ CONSTRAINT {identifier} ] (
  ( PRIMARY KEY | UNIQUE ) [{index_name}] LP {indexed_column} [ LP {signed_number} RP ] ( COMMA {indexed_column} [ LP {signed_number} RP ] ) * RP {conflict_clause} [comment_type] |
  {check_constraint} |
  FOREIGN KEY LP {column_name} ( COMMA {column_name} ) * RP {foreign_key_clause}
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlTableConstraintImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlTableConstraint"
  override = true
}

gin_operator_class_stmt ::= 'array_ops' | 'jsonb_ops' | 'jsonb_path_ops' | 'tsvector_ops'

create_index_stmt ::= CREATE [ UNIQUE ] INDEX [ 'CONCURRENTLY' ] [ IF NOT EXISTS ] [ {database_name} DOT ] {index_name} ON {table_name}
 ( USING 'GIN' LP {indexed_column} [ gin_operator_class_stmt ] ( COMMA {indexed_column} [ gin_operator_class_stmt ] ) * RP | LP {indexed_column} ( COMMA {indexed_column} ) * RP [ WHERE <<expr '-1'>> ] ) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlCreateIndexStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlGeneratedClause"
  override = true
  pin = 6
}


identity_clause ::= 'IDENTITY' [ LP [ 'SEQUENCE' 'NAME' sequence_name ] [ sequence_parameters* ] RP ]

generated_clause ::= GENERATED ( (ALWAYS AS LP <<expr '-1'>> RP 'STORED') | ( (ALWAYS | BY DEFAULT) AS identity_clause ) ) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlGeneratedClauseImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlGeneratedClause"
  override = true
}

small_int_data_type ::= 'SMALLINT' | 'INT2'
int_data_type ::= 'INTEGER' | 'INT' | 'INT4'
big_int_data_type ::= 'BIGINT' | 'INT8'
numeric_data_type ::= ('NUMERIC' | 'DECIMAL') [ LP {signed_number} RP | LP {signed_number} COMMA {signed_number} RP ]

approximate_numeric_data_type ::= ('REAL' | 'FLOAT4' | ( 'DOUBLE' 'PRECISION' ) | 'FLOAT8') | ('FLOAT' [ LP {signed_number} RP ])

small_serial_data_type ::= 'SMALLSERIAL' | 'SERIAL2'
serial_data_type ::= 'SERIAL' | 'SERIAL4'
big_serial_data_type ::= 'BIGSERIAL' | 'SERIAL8'

string_data_type ::= ((( 'CHARACTER' 'VARYING' ) | 'VARCHAR' | 'CHARACTER' | 'CHAR') [ LP {signed_number} RP ]) | 'TEXT' | 'CITEXT'

uuid_data_type ::= 'UUID'

date_data_type ::= 'DATE' | (('TIME' | 'TIMESTAMP') [ LP {signed_number} RP ] [(WITH | WITHOUT) 'TIME' 'ZONE']) | 'TIMESTAMPTZ' | 'INTERVAL'

boolean_data_type ::= 'BOOLEAN' | 'BOOL'

json_data_type ::= 'JSON' | 'JSONB'

blob_data_type ::= 'BYTEA'

tsvector_data_type ::= 'TSVECTOR'

interval_expression ::= 'INTERVAL' string_literal

with_clause_auxiliary_stmt ::= {compound_select_stmt} | delete_stmt_limited | insert_stmt | update_stmt_limited {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlWithClauseAuxiliaryStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlWithClauseAuxiliaryStmt"
  override = true
}

delete_stmt_limited ::= [ {with_clause} ] DELETE FROM {qualified_table_name} [ WHERE <<expr '-1'>> ] [ [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] LIMIT <<expr '-1'>> [ ( OFFSET | COMMA ) <<expr '-1'>> ] ] [ returning_clause ] {
  mixin =  "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlDeleteStmtLimitedMixin"
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlDeleteStmtLimitedImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlDeleteStmtLimited"
  pin = 2
  override = true
}

string_literal ::= string {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.StringLiteralMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlStringLiteral"
  override = true
}

literal_value ::= ( {numeric_literal}
                  | string_literal
                  | {blob_literal}
                  | NULL
                  | CURRENT_TIME
                  | CURRENT_DATE
                  | CURRENT_TIMESTAMP
                  | interval_expression ) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.LiteralValueMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlLiteralValue"
  override = true
}

insert_stmt ::= [ {with_clause} ]
    INSERT INTO [ {database_name} DOT ] {table_name} [ AS {table_alias} ]
    [ LP {column_name} ( COMMA {column_name} ) * RP ] {insert_stmt_values}
    [ ON CONFLICT ( [conflict_target] DO NOTHING | conflict_target conflict_update ) ]
    [ returning_clause ] {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlInsertStmtMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlInsertStmt"
  override = true
  pin = 5
}


conflict_target ::= LP {column_name} ( COMMA {column_name} ) * RP

conflict_update ::= DO UPDATE SET conflict_assign ( COMMA conflict_assign ) *

conflict_assign ::= {column_name} EQ <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlInsertExcludedTableMixin"
}

update_stmt_limited ::= [ {with_clause} ] UPDATE [ OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE ] {qualified_table_name}
  update_set_clause
  [ FROM {join_clause} ]
  [ WHERE <<expr '-1'>> ]
  [ [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ]
  LIMIT <<expr '-1'>> [ ( OFFSET | COMMA ) <<expr '-1'>> ] ]
  [ returning_clause ]{
  implements = "com.alecstrong.sql.psi.core.psi.SqlUpdateStmtLimited"
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.UpdateStmtLimitedMixin"
  override = true
  pin = 4
}
private update_set_clause ::= SET (( {column_name} EQ {setter_expression} {update_stmt_subsequent_setter} * ) | ( LP {column_name} ( COMMA {column_name} ) * RP ) EQ ( LP {setter_expression} ( COMMA {setter_expression} ) * RP )) {
  pin(".*") = 1
}

returning_clause ::= 'RETURNING' {result_column} ( COMMA {result_column} ) * {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.ReturningClauseMixin"
  implements = "com.alecstrong.sql.psi.core.psi.QueryElement"
}

alter_table_rules ::= (
  {alter_table_add_column}
  | {alter_table_rename_table}
  | alter_table_rename_column
  | alter_table_drop_column
  | alter_table_add_constraint
  | alter_table_alter_column
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlAlterTableRulesImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlAlterTableRules"
  override = true
}

alter_table_rename_column ::= RENAME [ COLUMN ] {column_name} TO alter_table_column_alias {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableRenameColumnMixin"
  pin = 1
}

alter_table_column_alias ::= id | string {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableColumnAliasMixin"
  implements = [
    "com.alecstrong.sql.psi.core.psi.AliasElement";
    "com.alecstrong.sql.psi.core.psi.NamedElement";
    "com.alecstrong.sql.psi.core.psi.SqlCompositeElement"
    "com.alecstrong.sql.psi.core.psi.SqlColumnName"
  ]
}

alter_table_drop_column ::= DROP [ COLUMN ] {column_name} {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableDropColumnMixin"
  pin = 1
}

alter_table_add_constraint ::= ADD table_constraint {
    mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableAddConstraintMixin"
}

type_clause ::= 'TYPE'

data_clause ::= 'DATA'

column_not_null_clause ::= (SET | DROP) NOT NULL
column_default_clause ::= SET {default_constraint} | DROP DEFAULT

alter_table_alter_column ::= ALTER [COLUMN] {column_name}
( [ SET data_clause ] type_clause {column_type} [USING {column_name}'::'{column_type}]
| column_not_null_clause
| column_default_clause | DROP identity_clause [ IF EXISTS ] | ADD {generated_clause}
| ( SET GENERATED (ALWAYS | BY DEFAULT)  |  SET sequence_parameters | 'RESTART' [ WITH {signed_number} ] ) *
) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableAlterColumnMixin"
  pin = 1
}

distinct_on_expr ::= DISTINCT ON LP {result_column} ( COMMA {result_column} ) * RP {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.DistinctOnExpressionMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlCompositeElement"
}

select_stmt ::= SELECT ( [ distinct_on_expr ] | [ DISTINCT | ALL ] ) {result_column} ( COMMA {result_column} ) * [ FROM {join_clause} ] [ WHERE <<expr '-1'>> ] [{group_by}] [HAVING <<expr '-1'>>] | VALUES {values_expression} ( COMMA {values_expression} ) * {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlSelectStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlSelectStmt"
  override = true
  pin = 1
}

compound_select_stmt ::= [ {with_clause} ] {select_stmt}  ( {compound_operator} {select_stmt} ) * [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] [ LIMIT {limiting_term} ] [ ( OFFSET | COMMA ) {limiting_term} ] [ FOR UPDATE [ 'SKIP' 'LOCKED' ] ] {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlCompoundSelectStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlCompoundSelectStmt"
  override = true
}

extension_expr ::= match_operator_expression | array_agg_stmt| string_agg_stmt | json_expression | boolean_literal | boolean_not_expression | window_function_expr {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlExtensionExprImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlExtensionExpr"
  override = true
}

window_function_expr ::= {function_expr} 'WITHIN' GROUP LP ORDER BY <<expr '-1'>> ( COMMA <<expr '-1'>> ) * RP {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.WindowFunctionMixin"
}

boolean_not_expression ::= NOT (boolean_literal | {column_name})

boolean_literal ::= TRUE | FALSE

json_expression ::= {column_expr} ( jsona_binary_operator | jsonb_binary_operator | jsonb_boolean_operator ) <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.JsonExpressionMixin"
  pin = 2
}
jsona_binary_operator ::= '->' | '->>' | '#>' | '#>>'
jsonb_binary_operator ::= '#-'
jsonb_boolean_operator ::= '@>' | '<@' | '@?' | '??|' | '??&' | '??'
match_operator ::= '@@'

match_operator_expression ::= ( {function_expr} | {column_expr} ) match_operator <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.MatchOperatorExpressionMixin"
  pin = 2
}

extension_stmt ::= create_sequence_stmt | copy_stdin | truncate_stmt | set_stmt | drop_sequence_stmt | alter_sequence_stmt | create_extension_stmt | drop_extension_stmt | alter_extension_stmt {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlExtensionStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlExtensionStmt"
  override = true
}

extension_name ::= id | string

extension_version ::= id | string

create_extension_stmt ::= CREATE 'EXTENSION' [ IF NOT EXISTS ] extension_name [ WITH ] [ 'SCHEMA' id ] [ 'VERSION' extension_version ] [ CASCADE ]

drop_extension_stmt ::= DROP 'EXTENSION' [ IF EXISTS ] extension_name [ ( COMMA extension_name ) * ] [ CASCADE | 'RESTRICT' ]

alter_extension_stmt ::= ALTER 'EXTENSION' [ IF EXISTS ] extension_name ( UPDATE [ TO extension_version ] | SET 'SCHEMA' id )

copy_stdin ::= 'COPY' [ {database_name} DOT ] {table_name} [ AS {table_alias} ] [ LP {column_name} ( COMMA {column_name} ) * RP ] FROM 'STDIN' [ [ WITH ] LP copy_option ( COMMA copy_option) * RP ] [ WHERE <<expr '-1'>> ] {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.CopyMixin"
}

sequence_name ::= id | string

sequence_data_type ::= ( small_int_data_type
                         | int_data_type
                         | big_int_data_type )

create_sequence_stmt ::= CREATE [ (TEMPORARY | TEMP) | 'UNLOGGED' ] 'SEQUENCE' [ IF NOT EXISTS ] sequence_name
     [ AS sequence_data_type ] (sequence_parameters) *   {
 mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.CreateSequenceMixin"
}

alter_sequence_stmt ::= ALTER 'SEQUENCE' [ IF EXISTS ] sequence_name
     ( 'OWNER' TO ( id | 'CURRENT_USER' | 'SESSION_USER' )
     | RENAME TO sequence_name
     | SET 'SCHEMA' id
     | ( [ AS sequence_data_type ] (sequence_parameters) * ) )
     {
 mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterSequenceMixin"
}

drop_sequence_stmt ::= DROP 'SEQUENCE' [ IF EXISTS ] sequence_name ( COMMA sequence_name ) * [ 'CASCADE' | 'RESTRICT' ]

sequence_parameters ::= 'INCREMENT' [ BY ] {signed_number}
 | 'MINVALUE' {signed_number} | NO 'MINVALUE' | 'MAXVALUE' {signed_number} | NO 'MAXVALUE'
 | 'START' [ WITH ] {signed_number} | 'CACHE' {signed_number} | [ NO ] 'CYCLE'
 | 'OWNED' BY ( {table_name} DOT {column_name} ) | 'NONE' {
  pin=2
}

copy_option ::= copy_option_format | copy_option_freeze | copy_option_delimiter | copy_option_null | copy_option_header | copy_option_quote | copy_option_escape | copy_option_force_not_null | copy_option_force_null | copy_option_encoding
copy_option_format ::= 'FORMAT' ('TEXT' | 'CSV' | 'BINARY')
copy_option_freeze ::= 'FREEZE' [ (boolean_literal) ]
copy_option_delimiter ::= 'DELIMITER' string_literal
copy_option_null ::= NULL string_literal
copy_option_header ::= 'HEADER' [ (boolean_literal) ]
copy_option_quote ::= 'QUOTE' string_literal
copy_option_escape ::= ESCAPE string_literal
copy_option_force_not_null ::= 'FORCE_NOT_NULL' LP {column_name} ( COMMA {column_name}) * RP
copy_option_force_null ::= 'FORCE_NULL' LP {column_name} ( COMMA {column_name}) * RP
copy_option_encoding ::= 'ENCODING' string_literal

truncate_stmt ::= 'TRUNCATE' [ 'TABLE' ] ( truncate_only | truncate_descendant ) [ truncate_option * ]
truncate_only ::= 'ONLY' {table_name} ( COMMA {table_name} ) *
truncate_descendant ::= {table_name} ['*'] ( COMMA {table_name} ['*'] ) *
truncate_option ::= truncate_option_identity | truncate_option_cascade
truncate_option_identity ::= ( 'RESTART' | 'CONTINUE' ) 'IDENTITY'
truncate_option_cascade ::=  'CASCADE' | 'RESTRICT'

string_agg_stmt ::= 'string_agg' LP [ ALL | DISTINCT ] <<expr '-1'>> COMMA string_literal [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] RP
[ 'FILTER' LP WHERE <<expr '-1'>> RP ] {
}

array_agg_stmt ::= 'array_agg' LP [ ALL | DISTINCT ] <<expr '-1'>> [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] RP
[ 'FILTER' LP WHERE <<expr '-1'>> RP ] {
 mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AggregateExpressionMixin"
}

set_stmt ::= 'SET' [ ('SESSION' | 'LOCAL') ] ( set_config | set_timezone | set_schema | set_names | set_seed )
set_value ::= literal_value | {identifier} | DEFAULT
set_config ::= {identifier} ( TO | EQ ) set_value
set_schema ::= 'SCHEMA' string_literal
set_names ::= 'NAMES' set_value
set_seed ::= 'SEED' TO ( set_value | [PLUS | MINUS]{numeric_literal} )
set_timezone ::= 'TIME' 'ZONE'
( [PLUS | MINUS]{numeric_literal}
| interval_expression ['HOUR' TO 'MINUTE']
| 'LOCAL'
| set_value
)
