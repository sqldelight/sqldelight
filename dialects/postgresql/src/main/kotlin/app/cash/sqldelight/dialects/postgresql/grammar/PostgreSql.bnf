{
  // Specify the parent parser.
  overrides="com.alecstrong.sql.psi.core.SqlParser"
  elementTypeClass = "com.alecstrong.sql.psi.core.SqlElementType"

  implements="com.alecstrong.sql.psi.core.psi.SqlCompositeElement"
  extends="com.alecstrong.sql.psi.core.psi.SqlCompositeElementImpl"
  psiClassPrefix = "PostgreSql"

  parserImports=[
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ADD"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ABORT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ALL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ALTER"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ALWAYS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.AND"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.AS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ASC"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.BETWEEN"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.BY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CASCADE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.COLLATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.COLUMN"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.COMMA"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CONFLICT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CONSTRAINT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CREATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CROSS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CURRENT_DATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CURRENT_TIME"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.CURRENT_TIMESTAMP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DEFAULT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DELETE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DESC"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DISTINCT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DOT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.DROP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.EQ"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ESCAPE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.EXISTS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FAIL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FALSE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FOR"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FOREIGN"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.FROM"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.GENERATED"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.GLOB"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.GROUP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.HAVING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ID"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.IF"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.IS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.IGNORE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INDEX"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INDEXED"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INNER"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INSERT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.INTO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.JOIN"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.KEY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.LIKE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.LIMIT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.LP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.MATCH"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.MINUS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.MULTIPLY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NATURAL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NOT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NOTHING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.NULL"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.OFFSET"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ON"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.OR"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ORDER"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.OUTER"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.PARTITION"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.PLUS"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.PRIMARY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.REGEXP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.RENAME"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.REPLACE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.RESTRICT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ROLLBACK"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.ROW"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.RP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.SELECT"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.SET"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.STRING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TEMP"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TEMPORARY"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TO"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.TRUE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.UNIQUE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.UPDATE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.USING"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.VALUES"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.WHERE"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.WITH"
    "static com.alecstrong.sql.psi.core.psi.SqlTypes.WITHOUT"
  ]
}
overrides ::= type_name
  | column_constraint
  | string_literal
  | bind_parameter
  | table_constraint
  | default_constraint
  | with_clause_auxiliary_stmt
  | delete_stmt_limited
  | insert_stmt
  | update_stmt_limited
  | generated_clause
  | join_operator
  | join_clause
  | result_column
  | alter_table_add_column
  | alter_table_rules
  | table_or_subquery
  | compound_select_stmt
  | extension_expr
  | extension_stmt
  | create_index_stmt
  | select_stmt
  | ordering_term
  | binary_like_operator
  | literal_value

column_constraint ::= [ CONSTRAINT {identifier} ] (
  PRIMARY KEY [ ASC | DESC ] {conflict_clause} |
  [ NOT ] NULL {conflict_clause} |
  UNIQUE {conflict_clause} |
  {check_constraint} |
  generated_clause |
  default_constraint |
  COLLATE {collation_name} |
  {foreign_key_clause}
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlColumnConstraintImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlColumnConstraint"
  override = true
}

current_timestamp_with_optional_interval ::= ( current_date_time_functions | 'NOW()' | interval_expression ) [ [ PLUS | MINUS ] interval_expression ] *
default_constraint ::= [ NOT NULL | NULL ] DEFAULT (
  current_timestamp_with_optional_interval |
  {signed_number} |
  {literal_value} |
  {function_expr} |
  LP <<expr '-1'>> RP
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlDefaultConstraintImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlDefaultConstraint"
  override = true
  pin = 2
}

type_name ::= (
  small_int_data_type |
  int_data_type |
  big_int_data_type |
  numeric_data_type |
  approximate_numeric_data_type |
  small_serial_data_type |
  serial_data_type |
  big_serial_data_type |
  string_data_type |
  uuid_data_type |
  date_data_type |
  boolean_data_type |
  json_data_type |
  blob_data_type |
  tsvector_data_type |
  xml_data_type
) [ '[]' ] {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlTypeNameImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlTypeName"
  override = true
}
bind_parameter ::= DEFAULT | ( '?' | ':' {identifier} ) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.BindParameterMixin"
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlBindParameterImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlBindParameter"
  override = true
}
table_constraint ::= [ CONSTRAINT {identifier} ] (
  ( PRIMARY KEY | UNIQUE ) [{index_name}] LP {indexed_column} [ LP {signed_number} RP ] ( COMMA {indexed_column} [ LP {signed_number} RP ] ) * RP {conflict_clause} [comment_type] |
  {check_constraint} |
  FOREIGN KEY LP {column_name} ( COMMA {column_name} ) * RP {foreign_key_clause}
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlTableConstraintImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlTableConstraint"
  override = true
}

operator_class_stmt ::= {identifier} [ LP {identifier} EQ ( {identifier} | {numeric_literal} ) { RP ]
storage_parameter ::= TRUE | FALSE | 'ON' | 'OFF' | {identifier} | {numeric_literal}
storage_parameters ::= 'autosummarize' | 'buffering' | 'deduplicate_items' | 'fastupdate' | 'fillfactor' | 'gin_pending_list_limit' | 'pages_per_range'
with_storage_parameter ::= WITH LP storage_parameters EQ ( storage_parameter ) ( COMMA storage_parameters EQ ( storage_parameter ) ) * RP
index_method ::=  'BRIN' | 'BTREE' | 'GIN' | 'GIST' | 'HASH'

create_index_stmt ::= CREATE [ UNIQUE ] INDEX [ 'CONCURRENTLY' ] [ IF NOT EXISTS ] [ {database_name} DOT ] {index_name} ON {table_name}
 ( USING index_method LP {indexed_column} [ operator_class_stmt ] ( COMMA {indexed_column} [ operator_class_stmt ] ) * RP [ with_storage_parameter ] | LP {indexed_column} [ operator_class_stmt ] ( COMMA {indexed_column} [ operator_class_stmt ] ) * RP [ WHERE <<expr '-1'>> ] )  {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.CreateIndexMixin"
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlCreateIndexStmtImpl"
  override = true
  pin = 6
}

binary_like_operator ::= ( 'ILIKE' | LIKE | GLOB | REGEXP | MATCH ) {
   extends = "com.alecstrong.sql.psi.core.psi.impl.SqlBinaryLikeOperatorImpl"
   implements = "com.alecstrong.sql.psi.core.psi.SqlBinaryLikeOperator"
   override = true
}

identity_clause ::= 'IDENTITY' [ LP [ 'SEQUENCE' 'NAME' sequence_name ] [ sequence_parameters* ] RP ]

generated_clause ::= GENERATED ( (ALWAYS AS LP <<expr '-1'>> RP 'STORED') | ( (ALWAYS | BY DEFAULT) AS identity_clause ) ) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlGeneratedClauseImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlGeneratedClause"
  override = true
}

small_int_data_type ::= 'SMALLINT' | 'INT2'
int_data_type ::= 'INTEGER' | 'INT' | 'INT4'
big_int_data_type ::= 'BIGINT' | 'INT8'
numeric_data_type ::= ('NUMERIC' | 'DECIMAL') [ LP {signed_number} RP | LP {signed_number} COMMA {signed_number} RP ]

approximate_numeric_data_type ::= ('REAL' | 'FLOAT4' | ( 'DOUBLE' 'PRECISION' ) | 'FLOAT8') | ('FLOAT' [ LP {signed_number} RP ])

small_serial_data_type ::= 'SMALLSERIAL' | 'SERIAL2'
serial_data_type ::= 'SERIAL' | 'SERIAL4'
big_serial_data_type ::= 'BIGSERIAL' | 'SERIAL8'

string_data_type ::= ((( 'CHARACTER' 'VARYING' ) | 'VARCHAR' | 'CHARACTER' | 'CHAR') [ LP {signed_number} RP ]) | 'TEXT' | 'CITEXT'

uuid_data_type ::= 'UUID'

date_data_type ::= 'DATE' | (('TIME' | 'TIMESTAMP') [ LP {signed_number} RP ] [(WITH | WITHOUT) 'TIME' 'ZONE']) | 'TIMESTAMPTZ' | 'INTERVAL'

boolean_data_type ::= 'BOOLEAN' | 'BOOL'

json_data_type ::= 'JSON' | 'JSONB'

blob_data_type ::= 'BYTEA'

tsvector_data_type ::= 'TSVECTOR'

xml_data_type ::= 'XML'

interval_expression ::= 'INTERVAL' {string_literal}

timestamp_expression ::= 'TIMESTAMP' [ (WITH | WITHOUT) 'TIME' 'ZONE' ] {string_literal}

date_expression ::= 'DATE' {string_literal}

time_expression ::= 'TIME' {string_literal}

with_clause_auxiliary_stmt ::= {compound_select_stmt} | delete_stmt_limited | insert_stmt | update_stmt_limited {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlWithClauseAuxiliaryStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlWithClauseAuxiliaryStmt"
  override = true
}

delete_stmt_limited ::= [ {with_clause} ] DELETE FROM {qualified_table_name} [ WHERE <<expr '-1'>> ] [ [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] LIMIT <<expr '-1'>> [ ( OFFSET | COMMA ) <<expr '-1'>> ] ] [ returning_clause ] {
  mixin =  "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlDeleteStmtLimitedMixin"
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlDeleteStmtLimitedImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlDeleteStmtLimited"
  pin = 2
  override = true
}

string_literal ::= string {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.StringLiteralMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlStringLiteral"
  override = true
}

precision_literal ::= ( '0' | '1' | '2' | '3' | '4' | '5' | '6' )
current_date_time_functions ::= CURRENT_DATE
  | 'CURRENT_TIME' [ LP precision_literal RP]
  | 'CURRENT_TIMESTAMP' [ LP precision_literal RP]
  | 'LOCALTIME' [ LP precision_literal RP]
  | 'LOCALTIMESTAMP' [ LP precision_literal RP]

literal_value ::= ( {numeric_literal}
                  | string_literal
                  | {blob_literal}
                  | NULL
                  | boolean_literal
                  | current_date_time_functions
                  | interval_expression
                  | timestamp_expression
                  | date_expression
                  | time_expression ) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.LiteralValueMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlLiteralValue"
  override = true
}

insert_stmt ::= [ {with_clause} ]
    INSERT INTO [ {database_name} DOT ] {table_name} [ AS {table_alias} ]
    [ LP {column_name} ( COMMA {column_name} ) * RP ] {insert_stmt_values}
    [ ON CONFLICT ( [conflict_target] DO NOTHING | conflict_target conflict_update ) ]
    [ returning_clause ] {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlInsertStmtMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlInsertStmt"
  override = true
  pin = 5
}


conflict_target ::= LP {column_name} ( COMMA {column_name} ) * RP

conflict_update ::= DO UPDATE SET conflict_assign ( COMMA conflict_assign ) *

conflict_assign ::= {column_name} EQ <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlInsertExcludedTableMixin"
}

update_stmt_limited ::= [ {with_clause} ] UPDATE [ OR ROLLBACK | OR ABORT | OR REPLACE | OR FAIL | OR IGNORE ] {qualified_table_name}
  update_set_clause
  [ FROM {join_clause} ]
  [ WHERE <<expr '-1'>> ]
  [ [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ]
  LIMIT <<expr '-1'>> [ ( OFFSET | COMMA ) <<expr '-1'>> ] ]
  [ returning_clause ]{
  implements = "com.alecstrong.sql.psi.core.psi.SqlUpdateStmtLimited"
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.UpdateStmtLimitedMixin"
  override = true
  pin = 4
}
private update_set_clause ::= SET (( {column_name} EQ {setter_expression} {update_stmt_subsequent_setter} * ) | ( LP {column_name} ( COMMA {column_name} ) * RP ) EQ ( LP {setter_expression} ( COMMA {setter_expression} ) * RP )) {
  pin(".*") = 1
}

returning_clause ::= 'RETURNING' {result_column} ( COMMA {result_column} ) * {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.ReturningClauseMixin"
  implements = "com.alecstrong.sql.psi.core.psi.QueryElement"
}

alter_table_rules ::= (
  {alter_table_add_column}
  | {alter_table_rename_table}
  | alter_table_rename_column
  | alter_table_drop_constraint
  | alter_table_drop_column
  | alter_table_add_constraint
  | alter_table_alter_column
) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlAlterTableRulesImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlAlterTableRules"
  override = true
}

alter_table_rename_column ::= RENAME [ COLUMN ] {column_name} TO alter_table_column_alias {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableRenameColumnMixin"
  pin = 1
}

alter_table_column_alias ::= id | string {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableColumnAliasMixin"
  implements = [
    "com.alecstrong.sql.psi.core.psi.AliasElement";
    "com.alecstrong.sql.psi.core.psi.NamedElement";
    "com.alecstrong.sql.psi.core.psi.SqlCompositeElement"
    "com.alecstrong.sql.psi.core.psi.SqlColumnName"
  ]
}

alter_table_drop_column ::= DROP [ COLUMN ] {column_name} {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableDropColumnMixin"
  pin = 1
}

alter_table_add_constraint ::= ADD table_constraint {
    mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableAddConstraintMixin"
}

alter_table_drop_constraint ::= DROP CONSTRAINT [ IF EXISTS ] {identifier} [ RESTRICT | CASCADE ] {
  pin = 2
}

type_clause ::= 'TYPE'

data_clause ::= 'DATA'

column_not_null_clause ::= (SET | DROP) NOT NULL
column_default_clause ::= SET {default_constraint} | DROP DEFAULT

if_not_exists ::= IF NOT EXISTS
alter_table_add_column ::= ADD [ COLUMN ] [ if_not_exists
 ] {column_def} {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableAddColumnMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlAlterTableAddColumn"
  override = true
}

alter_table_alter_column ::= ALTER [COLUMN] {column_name}
( [ SET data_clause ] type_clause {column_type} [USING {column_name}'::'{column_type}]
| column_not_null_clause
| column_default_clause | DROP identity_clause [ IF EXISTS ] | ADD {generated_clause}
| ( SET GENERATED (ALWAYS | BY DEFAULT)  |  SET sequence_parameters | 'RESTART' [ WITH {signed_number} ] ) *
) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterTableAlterColumnMixin"
  pin = 1
}

distinct_on_expr ::= DISTINCT ON LP {result_column} ( COMMA {result_column} ) * RP {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.DistinctOnExpressionMixin"
  implements = "com.alecstrong.sql.psi.core.psi.SqlCompositeElement"
}

select_stmt ::= SELECT ( distinct_on_expr | [ DISTINCT | ALL ] ) {result_column} ( COMMA {result_column} ) * [ FROM {join_clause} ] [ WHERE <<expr '-1'>> ] [{group_by}] [HAVING <<expr '-1'>>] | VALUES {values_expression} ( COMMA {values_expression} ) * {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlSelectStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlSelectStmt"
  override = true
  pin = 1
}

lateral ::= 'LATERAL'
join_operator ::= ( COMMA [ lateral ]
                  | [ NATURAL ] [ ( {left_join_operator} | {right_join_operator} | {full_join_operator} ) [ OUTER ] | INNER | CROSS ] JOIN [ lateral ] ) {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlJoinOperatorImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlJoinOperator"
  override = true
}

join_clause ::= {table_or_subquery} ( {join_operator} {table_or_subquery} [ {join_constraint} ] ) * {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.SqlJoinClauseMixin"
  override = true
}

compound_select_stmt ::= [ {with_clause} ] {select_stmt}  ( {compound_operator} {select_stmt} ) * [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] [ LIMIT {limiting_term} ] [ ( OFFSET | COMMA ) {limiting_term} ] [ FOR UPDATE [ 'SKIP' 'LOCKED' ] ] {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlCompoundSelectStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlCompoundSelectStmt"
  override = true
}

extension_expr ::= extract_temporal_expression | double_colon_cast_operator_expression | contains_operator_expression | at_time_zone_operator_expression | regex_match_operator_expression | match_operator_expression | json_function_stmt | array_agg_stmt| string_agg_stmt | json_expression | boolean_not_expression | window_function_expr {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlExtensionExprImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlExtensionExpr"
  override = true
}

window_function_expr ::= {function_expr}
  ( ['FILTER' LP WHERE <<expr '-1'>> RP] 'OVER' ( window_defn | window_name) | 'WITHIN' GROUP LP ORDER BY <<expr '-1'>> ( COMMA <<expr '-1'>> ) * RP ) {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.WindowFunctionMixin"
}

base_window_name ::= id
window_name ::= id

window_defn ::= LP [ base_window_name ]
  [ PARTITION BY <<expr '-1'>> ( COMMA <<expr '-1'>> ) * ]
  [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ]
  [ frame_spec ]
RP {
  pin = 1
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.WindowDefinitionMixin"
}

frame_spec ::= ( 'RANGE' | 'ROWS' | 'GROUPS' )
  (
    BETWEEN (
      'UNBOUNDED' 'PRECEDING' |
      'CURRENT' ROW |
      <<expr '-1'>> 'PRECEDING' |
      <<expr '-1'>> 'FOLLOWING'
    ) AND (
      'UNBOUNDED' 'FOLLOWING' |
      'CURRENT' ROW |
      <<expr '-1'>> 'PRECEDING' |
      <<expr '-1'>> 'FOLLOWING'
    ) |
    'UNBOUNDED' 'PRECEDING' |
    'CURRENT' ROW |
    <<expr '-1'>> 'PRECEDING'
  ) [ 'EXCLUDE' NO 'OTHERS' | 'EXCLUDE' 'CURRENT' ROW | 'EXCLUDE' GROUP | 'EXCLUDE' 'TIES' ] {
  pin = 1
}

boolean_not_expression ::= NOT (boolean_literal | {column_name})

boolean_literal ::= TRUE | FALSE

json_expression ::= {column_expr} ( jsona_binary_operator | jsonb_binary_operator | jsonb_boolean_operator ) <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.JsonExpressionMixin"
  pin = 2
}
jsona_binary_operator ::= '->' | '->>' | '#>' | '#>>'
jsonb_binary_operator ::= '#-'
jsonb_boolean_operator ::= '@?' | '??|' | '??&' | '??'
contains_operator ::= '@>' | '<@' | '&&'
match_operator ::= '@@'

contains_operator_expression ::= ( {function_expr} | {column_expr} ) contains_operator <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.ContainsOperatorExpressionMixin"
  pin = 2
}

match_operator_expression ::= ( {function_expr} | {column_expr} ) match_operator <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.MatchOperatorExpressionMixin"
  pin = 2
}

regex_match_operator ::=  '~~*' | '~*' | '!~~*' | '!~*' | '~~' | '~' | '!~~' | '!~'

regex_match_operator_expression ::= ( {function_expr} | {column_expr} ) regex_match_operator <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.RegExMatchOperatorExpressionMixin"
  pin = 2
}

double_colon_cast_operator ::= '::' type_name

double_colon_cast_operator_expression ::= ( {bind_expr} | {literal_expr} | {cast_expr} | {function_expr} | {column_expr} ) double_colon_cast_operator [ double_colon_cast_operator ] * {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.DoubleColonCastOperatorExpressionMixin"
  pin = 2
}

at_time_zone_operator ::= 'AT' 'TIME' 'ZONE' <<expr '-1'>> {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AtTimeZoneOperatorMixin"
}

at_time_zone_operator_expression ::= ( {literal_expr} | {cast_expr} | {function_expr} | {column_expr} ) at_time_zone_operator [ at_time_zone_operator ] *  {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AtTimeZoneOperatorExpressionMixin"
  pin = 2
}

extension_stmt ::= create_sequence_stmt | copy_stdin | truncate_stmt | set_stmt | drop_sequence_stmt |
 alter_sequence_stmt | create_extension_stmt | drop_extension_stmt | alter_extension_stmt {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlExtensionStmtImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlExtensionStmt"
  override = true
}

extension_name ::= id | string

extension_version ::= id | string

create_extension_stmt ::= CREATE 'EXTENSION' [ IF NOT EXISTS ] extension_name [ WITH ] [ 'SCHEMA' id ] [ 'VERSION' extension_version ] [ CASCADE ]

drop_extension_stmt ::= DROP 'EXTENSION' [ IF EXISTS ] extension_name [ ( COMMA extension_name ) * ] [ CASCADE | 'RESTRICT' ]

alter_extension_stmt ::= ALTER 'EXTENSION' [ IF EXISTS ] extension_name ( UPDATE [ TO extension_version ] | SET 'SCHEMA' id )

copy_stdin ::= 'COPY' [ {database_name} DOT ] {table_name} [ AS {table_alias} ] [ LP {column_name} ( COMMA {column_name} ) * RP ] FROM 'STDIN' [ [ WITH ] LP copy_option ( COMMA copy_option) * RP ] [ WHERE <<expr '-1'>> ] {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.CopyMixin"
}

sequence_name ::= id | string

sequence_data_type ::= ( small_int_data_type
                         | int_data_type
                         | big_int_data_type )

create_sequence_stmt ::= CREATE [ (TEMPORARY | TEMP) | 'UNLOGGED' ] 'SEQUENCE' [ IF NOT EXISTS ] sequence_name
     [ AS sequence_data_type ] (sequence_parameters) *   {
 mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.CreateSequenceMixin"
}

alter_sequence_stmt ::= ALTER 'SEQUENCE' [ IF EXISTS ] sequence_name
     ( 'OWNER' TO ( id | 'CURRENT_USER' | 'SESSION_USER' )
     | RENAME TO sequence_name
     | SET 'SCHEMA' id
     | ( [ AS sequence_data_type ] (sequence_parameters) * ) )
     {
 mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AlterSequenceMixin"
}

drop_sequence_stmt ::= DROP 'SEQUENCE' [ IF EXISTS ] sequence_name ( COMMA sequence_name ) * [ 'CASCADE' | 'RESTRICT' ]

sequence_parameters ::= 'INCREMENT' [ BY ] {signed_number}
 | 'MINVALUE' {signed_number} | NO 'MINVALUE' | 'MAXVALUE' {signed_number} | NO 'MAXVALUE'
 | 'START' [ WITH ] {signed_number} | 'CACHE' {signed_number} | [ NO ] 'CYCLE'
 | 'OWNED' BY ( {table_name} DOT {column_name} ) | 'NONE' {
  pin=2
}

copy_option ::= copy_option_format | copy_option_freeze | copy_option_delimiter | copy_option_null | copy_option_header | copy_option_quote | copy_option_escape | copy_option_force_not_null | copy_option_force_null | copy_option_encoding
copy_option_format ::= 'FORMAT' ('TEXT' | 'CSV' | 'BINARY')
copy_option_freeze ::= 'FREEZE' [ (boolean_literal) ]
copy_option_delimiter ::= 'DELIMITER' string_literal
copy_option_null ::= NULL string_literal
copy_option_header ::= 'HEADER' [ (boolean_literal) ]
copy_option_quote ::= 'QUOTE' string_literal
copy_option_escape ::= ESCAPE string_literal
copy_option_force_not_null ::= 'FORCE_NOT_NULL' LP {column_name} ( COMMA {column_name}) * RP
copy_option_force_null ::= 'FORCE_NULL' LP {column_name} ( COMMA {column_name}) * RP
copy_option_encoding ::= 'ENCODING' string_literal

truncate_stmt ::= 'TRUNCATE' [ 'TABLE' ] ( truncate_only | truncate_descendant ) [ truncate_option * ]
truncate_only ::= 'ONLY' {table_name} ( COMMA {table_name} ) *
truncate_descendant ::= {table_name} ['*'] ( COMMA {table_name} ['*'] ) *
truncate_option ::= truncate_option_identity | truncate_option_cascade
truncate_option_identity ::= ( 'RESTART' | 'CONTINUE' ) 'IDENTITY'
truncate_option_cascade ::=  'CASCADE' | 'RESTRICT'

json_function_stmt ::= ( 'row_to_json' | 'json_agg' | 'to_json' | 'to_jsonb' ) LP ( {table_alias} | {table_name} ) RP

string_agg_stmt ::= 'string_agg' LP [ ALL | DISTINCT ] <<expr '-1'>> COMMA string_literal [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] RP
[ 'FILTER' LP WHERE <<expr '-1'>> RP ] {
}

array_agg_stmt ::= 'array_agg' LP [ ALL | DISTINCT ] <<expr '-1'>> [ ORDER BY {ordering_term} ( COMMA {ordering_term} ) * ] RP
[ 'FILTER' LP WHERE <<expr '-1'>> RP ] {
 mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.AggregateExpressionMixin"
}

set_stmt ::= 'SET' [ ('SESSION' | 'LOCAL') ] ( set_config | set_timezone | set_schema | set_names | set_seed )
set_value ::= literal_value | {identifier} | DEFAULT
set_config ::= {identifier} ( TO | EQ ) set_value
set_schema ::= 'SCHEMA' string_literal
set_names ::= 'NAMES' set_value
set_seed ::= 'SEED' TO ( set_value | [PLUS | MINUS]{numeric_literal} )
set_timezone ::= 'TIME' 'ZONE'
( [PLUS | MINUS]{numeric_literal}
| interval_expression ['HOUR' TO 'MINUTE']
| 'LOCAL'
| set_value
)

ordering_term ::= <<expr '-1'>> [ ASC | DESC ] [ 'NULLS' ( 'FIRST' | 'LAST' ) ] {
  extends = "com.alecstrong.sql.psi.core.psi.impl.SqlOrderingTermImpl"
  implements = "com.alecstrong.sql.psi.core.psi.SqlOrderingTerm"
  override = true
}

extract_temporal_field ::= 'century' | 'day' | 'decade' | 'dow' | 'doy' | 'epoch' | 'hour' | 'isodow' | 'isoyear' | 'julian'
 | 'microseconds' | 'millennium' | 'milliseconds' | 'minute' | 'month' | 'quarter' | 'second' | 'timezone' | 'timezone_hour'
 | 'timezone_minute' | 'week' | 'year'

extract_temporal_expression ::= 'EXTRACT' LP extract_temporal_field FROM <<expr '-1'>> RP {
  mixin = "app.cash.sqldelight.dialects.postgresql.grammar.mixins.ExtractTemporalExpressionMixin"
  pin = 2
}
